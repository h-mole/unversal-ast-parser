// Code generated from CPP14Parser.g4 by ANTLR 4.13.1. DO NOT EDIT.

package parser // CPP14Parser

import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type CPP14Parser struct {
	CPP14ParserBase
}

var CPP14ParserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func cpp14parserParserInit() {
	staticData := &CPP14ParserParserStaticData
	staticData.LiteralNames = []string{
		"", "", "", "", "", "", "", "", "", "", "'alignas'", "'alignof'", "'asm'",
		"'auto'", "'bool'", "'break'", "'case'", "'catch'", "'char'", "'char16_t'",
		"'char32_t'", "'class'", "'const'", "'constexpr'", "'const_cast'", "'continue'",
		"'decltype'", "'default'", "'delete'", "'do'", "'double'", "'dynamic_cast'",
		"'else'", "'enum'", "'explicit'", "'export'", "'extern'", "'false'",
		"'final'", "'float'", "'for'", "'friend'", "'goto'", "'if'", "'inline'",
		"'int'", "'long'", "'mutable'", "'namespace'", "'new'", "'noexcept'",
		"'nullptr'", "'operator'", "'override'", "'private'", "'protected'",
		"'public'", "'register'", "'reinterpret_cast'", "'return'", "'short'",
		"'signed'", "'sizeof'", "'static'", "'static_assert'", "'static_cast'",
		"'struct'", "'switch'", "'template'", "'this'", "'thread_local'", "'throw'",
		"'true'", "'try'", "'typedef'", "'typeid'", "'typename'", "'union'",
		"'unsigned'", "'using'", "'virtual'", "'void'", "'volatile'", "'wchar_t'",
		"'while'", "'('", "')'", "'['", "']'", "'{'", "'}'", "'+'", "'-'", "'*'",
		"'/'", "'%'", "'^'", "'&'", "'|'", "'~'", "", "'='", "'<'", "'>'", "'+='",
		"'-='", "'*='", "'/='", "'%='", "'^='", "'&='", "'|='", "'<<='", "'>>='",
		"'=='", "'!='", "'<='", "'>='", "", "", "'++'", "'--'", "','", "'->*'",
		"'->'", "'?'", "':'", "'::'", "';'", "'.'", "'.*'", "'...'",
	}
	staticData.SymbolicNames = []string{
		"", "IntegerLiteral", "CharacterLiteral", "FloatingLiteral", "StringLiteral",
		"BooleanLiteral", "PointerLiteral", "UserDefinedLiteral", "MultiLineMacro",
		"Directive", "Alignas", "Alignof", "Asm", "Auto", "Bool", "Break", "Case",
		"Catch", "Char", "Char16", "Char32", "Class", "Const", "Constexpr",
		"Const_cast", "Continue", "Decltype", "Default", "Delete", "Do", "Double",
		"Dynamic_cast", "Else", "Enum", "Explicit", "Export", "Extern", "False_",
		"Final", "Float", "For", "Friend", "Goto", "If", "Inline", "Int", "Long",
		"Mutable", "Namespace", "New", "Noexcept", "Nullptr", "Operator", "Override",
		"Private", "Protected", "Public", "Register", "Reinterpret_cast", "Return",
		"Short", "Signed", "Sizeof", "Static", "Static_assert", "Static_cast",
		"Struct", "Switch", "Template", "This", "Thread_local", "Throw", "True_",
		"Try", "Typedef", "Typeid_", "Typename_", "Union", "Unsigned", "Using",
		"Virtual", "Void", "Volatile", "Wchar", "While", "LeftParen", "RightParen",
		"LeftBracket", "RightBracket", "LeftBrace", "RightBrace", "Plus", "Minus",
		"Star", "Div", "Mod", "Caret", "And", "Or", "Tilde", "Not", "Assign",
		"Less", "Greater", "PlusAssign", "MinusAssign", "StarAssign", "DivAssign",
		"ModAssign", "XorAssign", "AndAssign", "OrAssign", "LeftShiftAssign",
		"RightShiftAssign", "Equal", "NotEqual", "LessEqual", "GreaterEqual",
		"AndAnd", "OrOr", "PlusPlus", "MinusMinus", "Comma", "ArrowStar", "Arrow",
		"Question", "Colon", "Doublecolon", "Semi", "Dot", "DotStar", "Ellipsis",
		"Identifier", "DecimalLiteral", "OctalLiteral", "HexadecimalLiteral",
		"BinaryLiteral", "Integersuffix", "UserDefinedIntegerLiteral", "UserDefinedFloatingLiteral",
		"UserDefinedStringLiteral", "UserDefinedCharacterLiteral", "Whitespace",
		"Newline", "BlockComment", "LineComment",
	}
	staticData.RuleNames = []string{
		"translationUnit", "primaryExpression", "idExpression", "unqualifiedId",
		"qualifiedId", "nestedNameSpecifier", "lambdaExpression", "lambdaIntroducer",
		"lambdaCapture", "captureDefault", "captureList", "capture", "simpleCapture",
		"initcapture", "lambdaDeclarator", "postfixExpression", "typeIdOfTheTypeId",
		"expressionList", "pseudoDestructorName", "unaryExpression", "unaryOperator",
		"newExpression_", "newPlacement", "newTypeId", "newDeclarator_", "noPointerNewDeclarator",
		"newInitializer_", "deleteExpression", "noExceptExpression", "castExpression",
		"pointerMemberExpression", "multiplicativeExpression", "additiveExpression",
		"shiftExpression", "shiftOperator", "relationalExpression", "equalityExpression",
		"andExpression", "exclusiveOrExpression", "inclusiveOrExpression", "logicalAndExpression",
		"logicalOrExpression", "conditionalExpression", "assignmentExpression",
		"assignmentOperator", "expression", "constantExpression", "statement",
		"labeledStatement", "expressionStatement", "compoundStatement", "statementSeq",
		"selectionStatement", "condition", "iterationStatement", "forInitStatement",
		"forRangeDeclaration", "forRangeInitializer", "jumpStatement", "declarationStatement",
		"declarationseq", "declaration", "blockDeclaration", "aliasDeclaration",
		"simpleDeclaration", "staticAssertDeclaration", "emptyDeclaration_",
		"attributeDeclaration", "declSpecifier", "declSpecifierSeq", "storageClassSpecifier",
		"functionSpecifier", "typedefName", "typeSpecifier", "trailingTypeSpecifier",
		"typeSpecifierSeq", "trailingTypeSpecifierSeq", "simpleTypeLengthModifier",
		"simpleTypeSignednessModifier", "simpleTypeSpecifier", "theTypeName",
		"decltypeSpecifier", "elaboratedTypeSpecifier", "enumName", "enumSpecifier",
		"enumHead", "opaqueEnumDeclaration", "enumkey", "enumbase", "enumeratorList",
		"enumeratorDefinition", "enumerator", "namespaceName", "originalNamespaceName",
		"namespaceDefinition", "namespaceAlias", "namespaceAliasDefinition",
		"qualifiednamespacespecifier", "usingDeclaration", "usingDirective",
		"asmDefinition", "linkageSpecification", "attributeSpecifierSeq", "attributeSpecifier",
		"alignmentspecifier", "attributeList", "attribute", "attributeNamespace",
		"attributeArgumentClause", "balancedTokenSeq", "balancedtoken", "initDeclaratorList",
		"initDeclarator", "declarator", "pointerDeclarator", "noPointerDeclarator",
		"parametersAndQualifiers", "trailingReturnType", "pointerOperator",
		"cvqualifierseq", "cvQualifier", "refqualifier", "declaratorid", "theTypeId",
		"abstractDeclarator", "pointerAbstractDeclarator", "noPointerAbstractDeclarator",
		"abstractPackDeclarator", "noPointerAbstractPackDeclarator", "parameterDeclarationClause",
		"parameterDeclarationList", "parameterDeclaration", "functionDefinition",
		"functionBody", "initializer", "braceOrEqualInitializer", "initializerClause",
		"initializerList", "bracedInitList", "className", "classSpecifier",
		"classHead", "classHeadName", "classVirtSpecifier", "classKey", "memberSpecification",
		"memberdeclaration", "memberDeclaratorList", "memberDeclarator", "virtualSpecifierSeq",
		"virtualSpecifier", "pureSpecifier", "baseClause", "baseSpecifierList",
		"baseSpecifier", "classOrDeclType", "baseTypeSpecifier", "accessSpecifier",
		"conversionFunctionId", "conversionTypeId", "conversionDeclarator",
		"constructorInitializer", "memInitializerList", "memInitializer", "meminitializerid",
		"operatorFunctionId", "literalOperatorId", "templateDeclaration", "templateparameterList",
		"templateParameter", "typeParameter", "simpleTemplateId", "templateId",
		"templateName", "templateArgumentList", "templateArgument", "typeNameSpecifier",
		"explicitInstantiation", "explicitSpecialization", "tryBlock", "functionTryBlock",
		"handlerSeq", "handler", "exceptionDeclaration", "throwExpression",
		"exceptionSpecification", "dynamicExceptionSpecification", "typeIdList",
		"noeExceptSpecification", "theOperator", "literal",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 145, 2081, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2,
		113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7,
		117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2,
		122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7,
		126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2,
		131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7,
		135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2,
		140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 2, 144, 7,
		144, 2, 145, 7, 145, 2, 146, 7, 146, 2, 147, 7, 147, 2, 148, 7, 148, 2,
		149, 7, 149, 2, 150, 7, 150, 2, 151, 7, 151, 2, 152, 7, 152, 2, 153, 7,
		153, 2, 154, 7, 154, 2, 155, 7, 155, 2, 156, 7, 156, 2, 157, 7, 157, 2,
		158, 7, 158, 2, 159, 7, 159, 2, 160, 7, 160, 2, 161, 7, 161, 2, 162, 7,
		162, 2, 163, 7, 163, 2, 164, 7, 164, 2, 165, 7, 165, 2, 166, 7, 166, 2,
		167, 7, 167, 2, 168, 7, 168, 2, 169, 7, 169, 2, 170, 7, 170, 2, 171, 7,
		171, 2, 172, 7, 172, 2, 173, 7, 173, 2, 174, 7, 174, 2, 175, 7, 175, 2,
		176, 7, 176, 2, 177, 7, 177, 2, 178, 7, 178, 2, 179, 7, 179, 2, 180, 7,
		180, 2, 181, 7, 181, 2, 182, 7, 182, 2, 183, 7, 183, 2, 184, 7, 184, 2,
		185, 7, 185, 2, 186, 7, 186, 2, 187, 7, 187, 2, 188, 7, 188, 2, 189, 7,
		189, 2, 190, 7, 190, 1, 0, 3, 0, 384, 8, 0, 1, 0, 1, 0, 1, 1, 4, 1, 389,
		8, 1, 11, 1, 12, 1, 390, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1,
		400, 8, 1, 1, 2, 1, 2, 3, 2, 404, 8, 2, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 3, 3, 413, 8, 3, 1, 3, 3, 3, 416, 8, 3, 1, 4, 1, 4, 3, 4, 420,
		8, 4, 1, 4, 1, 4, 1, 5, 1, 5, 1, 5, 1, 5, 3, 5, 428, 8, 5, 1, 5, 1, 5,
		1, 5, 1, 5, 1, 5, 3, 5, 435, 8, 5, 1, 5, 3, 5, 438, 8, 5, 1, 5, 5, 5, 441,
		8, 5, 10, 5, 12, 5, 444, 9, 5, 1, 6, 1, 6, 3, 6, 448, 8, 6, 1, 6, 1, 6,
		1, 7, 1, 7, 3, 7, 454, 8, 7, 1, 7, 1, 7, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8,
		462, 8, 8, 3, 8, 464, 8, 8, 1, 9, 1, 9, 1, 10, 1, 10, 1, 10, 5, 10, 471,
		8, 10, 10, 10, 12, 10, 474, 9, 10, 1, 10, 3, 10, 477, 8, 10, 1, 11, 1,
		11, 3, 11, 481, 8, 11, 1, 12, 3, 12, 484, 8, 12, 1, 12, 1, 12, 3, 12, 488,
		8, 12, 1, 13, 3, 13, 491, 8, 13, 1, 13, 1, 13, 1, 13, 1, 14, 1, 14, 3,
		14, 498, 8, 14, 1, 14, 1, 14, 3, 14, 502, 8, 14, 1, 14, 3, 14, 505, 8,
		14, 1, 14, 3, 14, 508, 8, 14, 1, 14, 3, 14, 511, 8, 14, 1, 15, 1, 15, 1,
		15, 1, 15, 3, 15, 517, 8, 15, 1, 15, 1, 15, 3, 15, 521, 8, 15, 1, 15, 1,
		15, 3, 15, 525, 8, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15,
		1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 3, 15, 539, 8, 15, 1, 15, 1, 15, 3,
		15, 543, 8, 15, 1, 15, 1, 15, 1, 15, 1, 15, 3, 15, 549, 8, 15, 1, 15, 1,
		15, 1, 15, 1, 15, 1, 15, 3, 15, 556, 8, 15, 1, 15, 1, 15, 1, 15, 1, 15,
		3, 15, 562, 8, 15, 1, 15, 1, 15, 3, 15, 566, 8, 15, 1, 15, 1, 15, 5, 15,
		570, 8, 15, 10, 15, 12, 15, 573, 9, 15, 1, 16, 1, 16, 1, 17, 1, 17, 1,
		18, 3, 18, 580, 8, 18, 1, 18, 1, 18, 1, 18, 3, 18, 585, 8, 18, 1, 18, 1,
		18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 3, 18,
		598, 8, 18, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 3, 19, 605, 8, 19, 1, 19,
		1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 3, 19, 617,
		8, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 3, 19, 627,
		8, 19, 1, 20, 1, 20, 1, 21, 3, 21, 632, 8, 21, 1, 21, 1, 21, 3, 21, 636,
		8, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 3, 21, 643, 8, 21, 1, 21, 3,
		21, 646, 8, 21, 1, 22, 1, 22, 1, 22, 1, 22, 1, 23, 1, 23, 3, 23, 654, 8,
		23, 1, 24, 1, 24, 3, 24, 658, 8, 24, 1, 24, 3, 24, 661, 8, 24, 1, 25, 1,
		25, 1, 25, 1, 25, 1, 25, 3, 25, 668, 8, 25, 1, 25, 1, 25, 1, 25, 1, 25,
		1, 25, 3, 25, 675, 8, 25, 5, 25, 677, 8, 25, 10, 25, 12, 25, 680, 9, 25,
		1, 26, 1, 26, 3, 26, 684, 8, 26, 1, 26, 1, 26, 3, 26, 688, 8, 26, 1, 27,
		3, 27, 691, 8, 27, 1, 27, 1, 27, 1, 27, 3, 27, 696, 8, 27, 1, 27, 1, 27,
		1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1,
		29, 3, 29, 711, 8, 29, 1, 30, 1, 30, 1, 30, 5, 30, 716, 8, 30, 10, 30,
		12, 30, 719, 9, 30, 1, 31, 1, 31, 1, 31, 5, 31, 724, 8, 31, 10, 31, 12,
		31, 727, 9, 31, 1, 32, 1, 32, 1, 32, 5, 32, 732, 8, 32, 10, 32, 12, 32,
		735, 9, 32, 1, 33, 1, 33, 1, 33, 1, 33, 5, 33, 741, 8, 33, 10, 33, 12,
		33, 744, 9, 33, 1, 34, 1, 34, 1, 34, 1, 34, 3, 34, 750, 8, 34, 1, 35, 1,
		35, 1, 35, 5, 35, 755, 8, 35, 10, 35, 12, 35, 758, 9, 35, 1, 36, 1, 36,
		1, 36, 5, 36, 763, 8, 36, 10, 36, 12, 36, 766, 9, 36, 1, 37, 1, 37, 1,
		37, 5, 37, 771, 8, 37, 10, 37, 12, 37, 774, 9, 37, 1, 38, 1, 38, 1, 38,
		5, 38, 779, 8, 38, 10, 38, 12, 38, 782, 9, 38, 1, 39, 1, 39, 1, 39, 5,
		39, 787, 8, 39, 10, 39, 12, 39, 790, 9, 39, 1, 40, 1, 40, 1, 40, 5, 40,
		795, 8, 40, 10, 40, 12, 40, 798, 9, 40, 1, 41, 1, 41, 1, 41, 5, 41, 803,
		8, 41, 10, 41, 12, 41, 806, 9, 41, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1,
		42, 3, 42, 814, 8, 42, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 3, 43,
		822, 8, 43, 1, 44, 1, 44, 1, 45, 1, 45, 1, 45, 5, 45, 829, 8, 45, 10, 45,
		12, 45, 832, 9, 45, 1, 46, 1, 46, 1, 47, 1, 47, 1, 47, 3, 47, 839, 8, 47,
		1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 3, 47, 847, 8, 47, 3, 47, 849,
		8, 47, 1, 48, 3, 48, 852, 8, 48, 1, 48, 1, 48, 1, 48, 1, 48, 3, 48, 858,
		8, 48, 1, 48, 1, 48, 1, 48, 1, 49, 3, 49, 864, 8, 49, 1, 49, 1, 49, 1,
		50, 1, 50, 3, 50, 870, 8, 50, 1, 50, 1, 50, 1, 51, 4, 51, 875, 8, 51, 11,
		51, 12, 51, 876, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 3, 52,
		886, 8, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 3, 52, 894, 8, 52,
		1, 53, 1, 53, 3, 53, 898, 8, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 3,
		53, 905, 8, 53, 3, 53, 907, 8, 53, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1,
		54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54,
		1, 54, 1, 54, 3, 54, 927, 8, 54, 1, 54, 1, 54, 3, 54, 931, 8, 54, 1, 54,
		1, 54, 1, 54, 1, 54, 3, 54, 937, 8, 54, 1, 54, 1, 54, 1, 54, 3, 54, 942,
		8, 54, 1, 55, 1, 55, 3, 55, 946, 8, 55, 1, 56, 3, 56, 949, 8, 56, 1, 56,
		1, 56, 1, 56, 1, 57, 1, 57, 3, 57, 956, 8, 57, 1, 58, 1, 58, 1, 58, 1,
		58, 1, 58, 3, 58, 963, 8, 58, 1, 58, 1, 58, 3, 58, 967, 8, 58, 1, 58, 1,
		58, 1, 59, 1, 59, 1, 60, 4, 60, 974, 8, 60, 11, 60, 12, 60, 975, 1, 61,
		1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 3, 61, 987, 8,
		61, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 1, 62, 3, 62, 997,
		8, 62, 1, 63, 1, 63, 1, 63, 3, 63, 1002, 8, 63, 1, 63, 1, 63, 1, 63, 1,
		63, 1, 64, 3, 64, 1009, 8, 64, 1, 64, 3, 64, 1012, 8, 64, 1, 64, 1, 64,
		1, 64, 3, 64, 1017, 8, 64, 1, 64, 1, 64, 1, 64, 3, 64, 1022, 8, 64, 1,
		65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 66, 1, 66, 1, 67,
		1, 67, 1, 67, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 3, 68, 1043, 8,
		68, 1, 69, 4, 69, 1046, 8, 69, 11, 69, 12, 69, 1047, 1, 69, 3, 69, 1051,
		8, 69, 1, 70, 1, 70, 1, 71, 1, 71, 1, 72, 1, 72, 1, 73, 1, 73, 1, 73, 3,
		73, 1062, 8, 73, 1, 74, 1, 74, 1, 74, 1, 74, 3, 74, 1068, 8, 74, 1, 75,
		4, 75, 1071, 8, 75, 11, 75, 12, 75, 1072, 1, 75, 3, 75, 1076, 8, 75, 1,
		76, 4, 76, 1079, 8, 76, 11, 76, 12, 76, 1080, 1, 76, 3, 76, 1084, 8, 76,
		1, 77, 1, 77, 1, 78, 1, 78, 1, 79, 3, 79, 1091, 8, 79, 1, 79, 1, 79, 1,
		79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79,
		1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 3, 79, 1114, 8,
		79, 1, 80, 1, 80, 1, 80, 1, 80, 3, 80, 1120, 8, 80, 1, 81, 1, 81, 1, 81,
		1, 81, 3, 81, 1126, 8, 81, 1, 81, 1, 81, 1, 82, 1, 82, 3, 82, 1132, 8,
		82, 1, 82, 3, 82, 1135, 8, 82, 1, 82, 1, 82, 1, 82, 1, 82, 3, 82, 1141,
		8, 82, 1, 82, 1, 82, 3, 82, 1145, 8, 82, 1, 82, 1, 82, 3, 82, 1149, 8,
		82, 1, 82, 3, 82, 1152, 8, 82, 1, 83, 1, 83, 1, 84, 1, 84, 1, 84, 1, 84,
		3, 84, 1160, 8, 84, 3, 84, 1162, 8, 84, 1, 84, 1, 84, 1, 85, 1, 85, 3,
		85, 1168, 8, 85, 1, 85, 3, 85, 1171, 8, 85, 1, 85, 3, 85, 1174, 8, 85,
		1, 85, 3, 85, 1177, 8, 85, 1, 86, 1, 86, 3, 86, 1181, 8, 86, 1, 86, 1,
		86, 3, 86, 1185, 8, 86, 1, 86, 1, 86, 1, 87, 1, 87, 3, 87, 1191, 8, 87,
		1, 88, 1, 88, 1, 88, 1, 89, 1, 89, 1, 89, 5, 89, 1199, 8, 89, 10, 89, 12,
		89, 1202, 9, 89, 1, 90, 1, 90, 1, 90, 3, 90, 1207, 8, 90, 1, 91, 1, 91,
		1, 92, 1, 92, 3, 92, 1213, 8, 92, 1, 93, 1, 93, 1, 94, 3, 94, 1218, 8,
		94, 1, 94, 1, 94, 1, 94, 3, 94, 1223, 8, 94, 1, 94, 1, 94, 3, 94, 1227,
		8, 94, 1, 94, 1, 94, 1, 95, 1, 95, 1, 96, 1, 96, 1, 96, 1, 96, 1, 96, 1,
		96, 1, 97, 3, 97, 1240, 8, 97, 1, 97, 1, 97, 1, 98, 1, 98, 3, 98, 1246,
		8, 98, 1, 98, 1, 98, 3, 98, 1250, 8, 98, 1, 98, 1, 98, 1, 98, 1, 99, 3,
		99, 1256, 8, 99, 1, 99, 1, 99, 1, 99, 3, 99, 1261, 8, 99, 1, 99, 1, 99,
		1, 99, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 101, 1, 101,
		1, 101, 1, 101, 3, 101, 1276, 8, 101, 1, 101, 1, 101, 3, 101, 1280, 8,
		101, 1, 102, 4, 102, 1283, 8, 102, 11, 102, 12, 102, 1284, 1, 103, 1, 103,
		1, 103, 3, 103, 1290, 8, 103, 1, 103, 1, 103, 1, 103, 3, 103, 1295, 8,
		103, 1, 104, 1, 104, 1, 104, 1, 104, 3, 104, 1301, 8, 104, 1, 104, 3, 104,
		1304, 8, 104, 1, 104, 1, 104, 1, 105, 1, 105, 1, 105, 5, 105, 1311, 8,
		105, 10, 105, 12, 105, 1314, 9, 105, 1, 105, 3, 105, 1317, 8, 105, 1, 106,
		1, 106, 1, 106, 3, 106, 1322, 8, 106, 1, 106, 1, 106, 3, 106, 1326, 8,
		106, 1, 107, 1, 107, 1, 108, 1, 108, 3, 108, 1332, 8, 108, 1, 108, 1, 108,
		1, 109, 4, 109, 1337, 8, 109, 11, 109, 12, 109, 1338, 1, 110, 1, 110, 1,
		110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1,
		110, 1, 110, 4, 110, 1354, 8, 110, 11, 110, 12, 110, 1355, 3, 110, 1358,
		8, 110, 1, 111, 1, 111, 1, 111, 5, 111, 1363, 8, 111, 10, 111, 12, 111,
		1366, 9, 111, 1, 112, 1, 112, 3, 112, 1370, 8, 112, 1, 113, 1, 113, 1,
		113, 1, 113, 1, 113, 3, 113, 1377, 8, 113, 1, 114, 1, 114, 3, 114, 1381,
		8, 114, 5, 114, 1383, 8, 114, 10, 114, 12, 114, 1386, 9, 114, 1, 114, 1,
		114, 1, 115, 1, 115, 1, 115, 3, 115, 1393, 8, 115, 1, 115, 1, 115, 1, 115,
		1, 115, 3, 115, 1399, 8, 115, 1, 115, 1, 115, 1, 115, 1, 115, 3, 115, 1405,
		8, 115, 1, 115, 1, 115, 3, 115, 1409, 8, 115, 3, 115, 1411, 8, 115, 5,
		115, 1413, 8, 115, 10, 115, 12, 115, 1416, 9, 115, 1, 116, 1, 116, 3, 116,
		1420, 8, 116, 1, 116, 1, 116, 3, 116, 1424, 8, 116, 1, 116, 3, 116, 1427,
		8, 116, 1, 116, 3, 116, 1430, 8, 116, 1, 116, 3, 116, 1433, 8, 116, 1,
		117, 1, 117, 1, 117, 3, 117, 1438, 8, 117, 1, 118, 1, 118, 3, 118, 1442,
		8, 118, 1, 118, 3, 118, 1445, 8, 118, 1, 118, 1, 118, 3, 118, 1449, 8,
		118, 1, 118, 3, 118, 1452, 8, 118, 3, 118, 1454, 8, 118, 1, 119, 4, 119,
		1457, 8, 119, 11, 119, 12, 119, 1458, 1, 120, 1, 120, 1, 121, 1, 121, 1,
		122, 3, 122, 1466, 8, 122, 1, 122, 1, 122, 1, 123, 1, 123, 3, 123, 1472,
		8, 123, 1, 124, 1, 124, 3, 124, 1476, 8, 124, 1, 124, 1, 124, 1, 124, 1,
		124, 3, 124, 1482, 8, 124, 1, 125, 1, 125, 4, 125, 1486, 8, 125, 11, 125,
		12, 125, 1487, 1, 125, 3, 125, 1491, 8, 125, 3, 125, 1493, 8, 125, 1, 126,
		1, 126, 1, 126, 1, 126, 3, 126, 1499, 8, 126, 1, 126, 1, 126, 3, 126, 1503,
		8, 126, 1, 126, 1, 126, 1, 126, 1, 126, 3, 126, 1509, 8, 126, 1, 126, 1,
		126, 1, 126, 1, 126, 1, 126, 3, 126, 1516, 8, 126, 1, 126, 1, 126, 3, 126,
		1520, 8, 126, 3, 126, 1522, 8, 126, 5, 126, 1524, 8, 126, 10, 126, 12,
		126, 1527, 9, 126, 1, 127, 5, 127, 1530, 8, 127, 10, 127, 12, 127, 1533,
		9, 127, 1, 127, 1, 127, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128,
		1, 128, 3, 128, 1544, 8, 128, 1, 128, 1, 128, 3, 128, 1548, 8, 128, 3,
		128, 1550, 8, 128, 5, 128, 1552, 8, 128, 10, 128, 12, 128, 1555, 9, 128,
		1, 129, 1, 129, 3, 129, 1559, 8, 129, 1, 129, 3, 129, 1562, 8, 129, 1,
		130, 1, 130, 1, 130, 5, 130, 1567, 8, 130, 10, 130, 12, 130, 1570, 9, 130,
		1, 131, 3, 131, 1573, 8, 131, 1, 131, 1, 131, 1, 131, 3, 131, 1578, 8,
		131, 3, 131, 1580, 8, 131, 1, 131, 1, 131, 3, 131, 1584, 8, 131, 1, 132,
		3, 132, 1587, 8, 132, 1, 132, 3, 132, 1590, 8, 132, 1, 132, 1, 132, 3,
		132, 1594, 8, 132, 1, 132, 1, 132, 1, 133, 3, 133, 1599, 8, 133, 1, 133,
		1, 133, 1, 133, 1, 133, 1, 133, 3, 133, 1606, 8, 133, 1, 134, 1, 134, 1,
		134, 1, 134, 1, 134, 3, 134, 1613, 8, 134, 1, 135, 1, 135, 1, 135, 3, 135,
		1618, 8, 135, 1, 136, 1, 136, 3, 136, 1622, 8, 136, 1, 137, 1, 137, 3,
		137, 1626, 8, 137, 1, 137, 1, 137, 1, 137, 3, 137, 1631, 8, 137, 5, 137,
		1633, 8, 137, 10, 137, 12, 137, 1636, 9, 137, 1, 138, 1, 138, 1, 138, 3,
		138, 1641, 8, 138, 3, 138, 1643, 8, 138, 1, 138, 1, 138, 1, 139, 1, 139,
		3, 139, 1649, 8, 139, 1, 140, 1, 140, 1, 140, 3, 140, 1654, 8, 140, 1,
		140, 1, 140, 1, 141, 1, 141, 3, 141, 1660, 8, 141, 1, 141, 1, 141, 3, 141,
		1664, 8, 141, 3, 141, 1666, 8, 141, 1, 141, 3, 141, 1669, 8, 141, 1, 141,
		1, 141, 3, 141, 1673, 8, 141, 1, 141, 1, 141, 3, 141, 1677, 8, 141, 3,
		141, 1679, 8, 141, 3, 141, 1681, 8, 141, 1, 142, 3, 142, 1684, 8, 142,
		1, 142, 1, 142, 1, 143, 1, 143, 1, 144, 1, 144, 1, 145, 1, 145, 1, 145,
		1, 145, 4, 145, 1696, 8, 145, 11, 145, 12, 145, 1697, 1, 146, 3, 146, 1701,
		8, 146, 1, 146, 3, 146, 1704, 8, 146, 1, 146, 3, 146, 1707, 8, 146, 1,
		146, 1, 146, 1, 146, 1, 146, 1, 146, 1, 146, 1, 146, 3, 146, 1716, 8, 146,
		1, 147, 1, 147, 1, 147, 5, 147, 1721, 8, 147, 10, 147, 12, 147, 1724, 9,
		147, 1, 148, 1, 148, 1, 148, 1, 148, 1, 148, 1, 148, 1, 148, 1, 148, 1,
		148, 3, 148, 1735, 8, 148, 1, 148, 1, 148, 3, 148, 1739, 8, 148, 1, 148,
		3, 148, 1742, 8, 148, 1, 148, 1, 148, 3, 148, 1746, 8, 148, 1, 149, 4,
		149, 1749, 8, 149, 11, 149, 12, 149, 1750, 1, 150, 1, 150, 1, 151, 1, 151,
		1, 151, 1, 152, 1, 152, 1, 152, 1, 153, 1, 153, 3, 153, 1763, 8, 153, 1,
		153, 1, 153, 1, 153, 3, 153, 1768, 8, 153, 5, 153, 1770, 8, 153, 10, 153,
		12, 153, 1773, 9, 153, 1, 154, 3, 154, 1776, 8, 154, 1, 154, 1, 154, 1,
		154, 3, 154, 1781, 8, 154, 1, 154, 1, 154, 1, 154, 3, 154, 1786, 8, 154,
		1, 154, 1, 154, 3, 154, 1790, 8, 154, 1, 155, 3, 155, 1793, 8, 155, 1,
		155, 1, 155, 3, 155, 1797, 8, 155, 1, 156, 1, 156, 1, 157, 1, 157, 1, 158,
		1, 158, 1, 158, 1, 159, 1, 159, 3, 159, 1808, 8, 159, 1, 160, 1, 160, 3,
		160, 1812, 8, 160, 1, 161, 1, 161, 1, 161, 1, 162, 1, 162, 3, 162, 1819,
		8, 162, 1, 162, 1, 162, 1, 162, 3, 162, 1824, 8, 162, 5, 162, 1826, 8,
		162, 10, 162, 12, 162, 1829, 9, 162, 1, 163, 1, 163, 1, 163, 3, 163, 1834,
		8, 163, 1, 163, 1, 163, 3, 163, 1838, 8, 163, 1, 164, 1, 164, 3, 164, 1842,
		8, 164, 1, 165, 1, 165, 1, 165, 1, 166, 1, 166, 1, 166, 1, 166, 3, 166,
		1851, 8, 166, 1, 167, 1, 167, 1, 167, 1, 167, 1, 167, 1, 167, 1, 168, 1,
		168, 1, 168, 5, 168, 1862, 8, 168, 10, 168, 12, 168, 1865, 9, 168, 1, 169,
		1, 169, 3, 169, 1869, 8, 169, 1, 170, 1, 170, 1, 170, 1, 170, 1, 170, 3,
		170, 1876, 8, 170, 1, 170, 1, 170, 3, 170, 1880, 8, 170, 1, 170, 3, 170,
		1883, 8, 170, 1, 170, 3, 170, 1886, 8, 170, 1, 170, 3, 170, 1889, 8, 170,
		1, 170, 1, 170, 3, 170, 1893, 8, 170, 1, 171, 1, 171, 1, 171, 3, 171, 1898,
		8, 171, 1, 171, 1, 171, 1, 172, 1, 172, 1, 172, 3, 172, 1905, 8, 172, 1,
		172, 1, 172, 3, 172, 1909, 8, 172, 1, 172, 1, 172, 3, 172, 1913, 8, 172,
		1, 173, 1, 173, 1, 174, 1, 174, 3, 174, 1919, 8, 174, 1, 174, 1, 174, 1,
		174, 3, 174, 1924, 8, 174, 5, 174, 1926, 8, 174, 10, 174, 12, 174, 1929,
		9, 174, 1, 175, 1, 175, 1, 175, 3, 175, 1934, 8, 175, 1, 176, 1, 176, 1,
		176, 1, 176, 3, 176, 1940, 8, 176, 1, 176, 3, 176, 1943, 8, 176, 1, 177,
		3, 177, 1946, 8, 177, 1, 177, 1, 177, 1, 177, 1, 178, 1, 178, 1, 178, 1,
		178, 1, 178, 1, 179, 1, 179, 1, 179, 1, 179, 1, 180, 1, 180, 3, 180, 1962,
		8, 180, 1, 180, 1, 180, 1, 180, 1, 181, 4, 181, 1968, 8, 181, 11, 181,
		12, 181, 1969, 1, 182, 1, 182, 1, 182, 1, 182, 1, 182, 1, 182, 1, 183,
		3, 183, 1979, 8, 183, 1, 183, 1, 183, 1, 183, 3, 183, 1984, 8, 183, 1,
		183, 3, 183, 1987, 8, 183, 1, 184, 1, 184, 3, 184, 1991, 8, 184, 1, 185,
		1, 185, 3, 185, 1995, 8, 185, 1, 186, 1, 186, 1, 186, 3, 186, 2000, 8,
		186, 1, 186, 1, 186, 1, 187, 1, 187, 3, 187, 2006, 8, 187, 1, 187, 1, 187,
		1, 187, 3, 187, 2011, 8, 187, 5, 187, 2013, 8, 187, 10, 187, 12, 187, 2016,
		9, 187, 1, 188, 1, 188, 1, 188, 1, 188, 1, 188, 1, 188, 3, 188, 2024, 8,
		188, 1, 189, 1, 189, 1, 189, 3, 189, 2029, 8, 189, 1, 189, 1, 189, 1, 189,
		3, 189, 2034, 8, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1,
		189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1,
		189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1,
		189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1,
		189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 1, 189, 3, 189, 2077,
		8, 189, 1, 190, 1, 190, 1, 190, 1, 1047, 6, 10, 30, 50, 230, 252, 256,
		191, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34,
		36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70,
		72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104,
		106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134,
		136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164,
		166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194,
		196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224,
		226, 228, 230, 232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254,
		256, 258, 260, 262, 264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284,
		286, 288, 290, 292, 294, 296, 298, 300, 302, 304, 306, 308, 310, 312, 314,
		316, 318, 320, 322, 324, 326, 328, 330, 332, 334, 336, 338, 340, 342, 344,
		346, 348, 350, 352, 354, 356, 358, 360, 362, 364, 366, 368, 370, 372, 374,
		376, 378, 380, 0, 23, 2, 0, 97, 97, 101, 101, 4, 0, 24, 24, 31, 31, 58,
		58, 65, 65, 2, 0, 124, 124, 129, 129, 1, 0, 120, 121, 2, 0, 91, 93, 97,
		100, 2, 0, 123, 123, 130, 130, 1, 0, 93, 95, 1, 0, 91, 92, 2, 0, 102, 103,
		116, 117, 1, 0, 114, 115, 2, 0, 101, 101, 104, 113, 5, 0, 36, 36, 47, 47,
		57, 57, 63, 63, 70, 70, 3, 0, 34, 34, 44, 44, 80, 80, 2, 0, 46, 46, 60,
		60, 2, 0, 61, 61, 78, 78, 2, 0, 21, 21, 66, 66, 1, 0, 85, 90, 2, 0, 97,
		97, 118, 118, 2, 0, 22, 22, 82, 82, 1, 0, 27, 28, 2, 0, 38, 38, 53, 53,
		1, 0, 54, 56, 1, 0, 1, 7, 2308, 0, 383, 1, 0, 0, 0, 2, 399, 1, 0, 0, 0,
		4, 403, 1, 0, 0, 0, 6, 415, 1, 0, 0, 0, 8, 417, 1, 0, 0, 0, 10, 423, 1,
		0, 0, 0, 12, 445, 1, 0, 0, 0, 14, 451, 1, 0, 0, 0, 16, 463, 1, 0, 0, 0,
		18, 465, 1, 0, 0, 0, 20, 467, 1, 0, 0, 0, 22, 480, 1, 0, 0, 0, 24, 487,
		1, 0, 0, 0, 26, 490, 1, 0, 0, 0, 28, 495, 1, 0, 0, 0, 30, 542, 1, 0, 0,
		0, 32, 574, 1, 0, 0, 0, 34, 576, 1, 0, 0, 0, 36, 597, 1, 0, 0, 0, 38, 626,
		1, 0, 0, 0, 40, 628, 1, 0, 0, 0, 42, 631, 1, 0, 0, 0, 44, 647, 1, 0, 0,
		0, 46, 651, 1, 0, 0, 0, 48, 660, 1, 0, 0, 0, 50, 662, 1, 0, 0, 0, 52, 687,
		1, 0, 0, 0, 54, 690, 1, 0, 0, 0, 56, 699, 1, 0, 0, 0, 58, 710, 1, 0, 0,
		0, 60, 712, 1, 0, 0, 0, 62, 720, 1, 0, 0, 0, 64, 728, 1, 0, 0, 0, 66, 736,
		1, 0, 0, 0, 68, 749, 1, 0, 0, 0, 70, 751, 1, 0, 0, 0, 72, 759, 1, 0, 0,
		0, 74, 767, 1, 0, 0, 0, 76, 775, 1, 0, 0, 0, 78, 783, 1, 0, 0, 0, 80, 791,
		1, 0, 0, 0, 82, 799, 1, 0, 0, 0, 84, 807, 1, 0, 0, 0, 86, 821, 1, 0, 0,
		0, 88, 823, 1, 0, 0, 0, 90, 825, 1, 0, 0, 0, 92, 833, 1, 0, 0, 0, 94, 848,
		1, 0, 0, 0, 96, 851, 1, 0, 0, 0, 98, 863, 1, 0, 0, 0, 100, 867, 1, 0, 0,
		0, 102, 874, 1, 0, 0, 0, 104, 893, 1, 0, 0, 0, 106, 906, 1, 0, 0, 0, 108,
		941, 1, 0, 0, 0, 110, 945, 1, 0, 0, 0, 112, 948, 1, 0, 0, 0, 114, 955,
		1, 0, 0, 0, 116, 966, 1, 0, 0, 0, 118, 970, 1, 0, 0, 0, 120, 973, 1, 0,
		0, 0, 122, 986, 1, 0, 0, 0, 124, 996, 1, 0, 0, 0, 126, 998, 1, 0, 0, 0,
		128, 1021, 1, 0, 0, 0, 130, 1023, 1, 0, 0, 0, 132, 1031, 1, 0, 0, 0, 134,
		1033, 1, 0, 0, 0, 136, 1042, 1, 0, 0, 0, 138, 1045, 1, 0, 0, 0, 140, 1052,
		1, 0, 0, 0, 142, 1054, 1, 0, 0, 0, 144, 1056, 1, 0, 0, 0, 146, 1061, 1,
		0, 0, 0, 148, 1067, 1, 0, 0, 0, 150, 1070, 1, 0, 0, 0, 152, 1078, 1, 0,
		0, 0, 154, 1085, 1, 0, 0, 0, 156, 1087, 1, 0, 0, 0, 158, 1113, 1, 0, 0,
		0, 160, 1119, 1, 0, 0, 0, 162, 1121, 1, 0, 0, 0, 164, 1151, 1, 0, 0, 0,
		166, 1153, 1, 0, 0, 0, 168, 1155, 1, 0, 0, 0, 170, 1165, 1, 0, 0, 0, 172,
		1178, 1, 0, 0, 0, 174, 1188, 1, 0, 0, 0, 176, 1192, 1, 0, 0, 0, 178, 1195,
		1, 0, 0, 0, 180, 1203, 1, 0, 0, 0, 182, 1208, 1, 0, 0, 0, 184, 1212, 1,
		0, 0, 0, 186, 1214, 1, 0, 0, 0, 188, 1217, 1, 0, 0, 0, 190, 1230, 1, 0,
		0, 0, 192, 1232, 1, 0, 0, 0, 194, 1239, 1, 0, 0, 0, 196, 1243, 1, 0, 0,
		0, 198, 1255, 1, 0, 0, 0, 200, 1265, 1, 0, 0, 0, 202, 1271, 1, 0, 0, 0,
		204, 1282, 1, 0, 0, 0, 206, 1294, 1, 0, 0, 0, 208, 1296, 1, 0, 0, 0, 210,
		1307, 1, 0, 0, 0, 212, 1321, 1, 0, 0, 0, 214, 1327, 1, 0, 0, 0, 216, 1329,
		1, 0, 0, 0, 218, 1336, 1, 0, 0, 0, 220, 1357, 1, 0, 0, 0, 222, 1359, 1,
		0, 0, 0, 224, 1367, 1, 0, 0, 0, 226, 1376, 1, 0, 0, 0, 228, 1384, 1, 0,
		0, 0, 230, 1398, 1, 0, 0, 0, 232, 1417, 1, 0, 0, 0, 234, 1434, 1, 0, 0,
		0, 236, 1453, 1, 0, 0, 0, 238, 1456, 1, 0, 0, 0, 240, 1460, 1, 0, 0, 0,
		242, 1462, 1, 0, 0, 0, 244, 1465, 1, 0, 0, 0, 246, 1469, 1, 0, 0, 0, 248,
		1481, 1, 0, 0, 0, 250, 1492, 1, 0, 0, 0, 252, 1508, 1, 0, 0, 0, 254, 1531,
		1, 0, 0, 0, 256, 1536, 1, 0, 0, 0, 258, 1556, 1, 0, 0, 0, 260, 1563, 1,
		0, 0, 0, 262, 1572, 1, 0, 0, 0, 264, 1586, 1, 0, 0, 0, 266, 1605, 1, 0,
		0, 0, 268, 1612, 1, 0, 0, 0, 270, 1617, 1, 0, 0, 0, 272, 1621, 1, 0, 0,
		0, 274, 1623, 1, 0, 0, 0, 276, 1637, 1, 0, 0, 0, 278, 1648, 1, 0, 0, 0,
		280, 1650, 1, 0, 0, 0, 282, 1680, 1, 0, 0, 0, 284, 1683, 1, 0, 0, 0, 286,
		1687, 1, 0, 0, 0, 288, 1689, 1, 0, 0, 0, 290, 1695, 1, 0, 0, 0, 292, 1715,
		1, 0, 0, 0, 294, 1717, 1, 0, 0, 0, 296, 1745, 1, 0, 0, 0, 298, 1748, 1,
		0, 0, 0, 300, 1752, 1, 0, 0, 0, 302, 1754, 1, 0, 0, 0, 304, 1757, 1, 0,
		0, 0, 306, 1760, 1, 0, 0, 0, 308, 1775, 1, 0, 0, 0, 310, 1796, 1, 0, 0,
		0, 312, 1798, 1, 0, 0, 0, 314, 1800, 1, 0, 0, 0, 316, 1802, 1, 0, 0, 0,
		318, 1805, 1, 0, 0, 0, 320, 1809, 1, 0, 0, 0, 322, 1813, 1, 0, 0, 0, 324,
		1816, 1, 0, 0, 0, 326, 1830, 1, 0, 0, 0, 328, 1841, 1, 0, 0, 0, 330, 1843,
		1, 0, 0, 0, 332, 1846, 1, 0, 0, 0, 334, 1852, 1, 0, 0, 0, 336, 1858, 1,
		0, 0, 0, 338, 1868, 1, 0, 0, 0, 340, 1879, 1, 0, 0, 0, 342, 1894, 1, 0,
		0, 0, 344, 1912, 1, 0, 0, 0, 346, 1914, 1, 0, 0, 0, 348, 1916, 1, 0, 0,
		0, 350, 1933, 1, 0, 0, 0, 352, 1935, 1, 0, 0, 0, 354, 1945, 1, 0, 0, 0,
		356, 1950, 1, 0, 0, 0, 358, 1955, 1, 0, 0, 0, 360, 1959, 1, 0, 0, 0, 362,
		1967, 1, 0, 0, 0, 364, 1971, 1, 0, 0, 0, 366, 1986, 1, 0, 0, 0, 368, 1988,
		1, 0, 0, 0, 370, 1994, 1, 0, 0, 0, 372, 1996, 1, 0, 0, 0, 374, 2003, 1,
		0, 0, 0, 376, 2023, 1, 0, 0, 0, 378, 2076, 1, 0, 0, 0, 380, 2078, 1, 0,
		0, 0, 382, 384, 3, 120, 60, 0, 383, 382, 1, 0, 0, 0, 383, 384, 1, 0, 0,
		0, 384, 385, 1, 0, 0, 0, 385, 386, 5, 0, 0, 1, 386, 1, 1, 0, 0, 0, 387,
		389, 3, 380, 190, 0, 388, 387, 1, 0, 0, 0, 389, 390, 1, 0, 0, 0, 390, 388,
		1, 0, 0, 0, 390, 391, 1, 0, 0, 0, 391, 400, 1, 0, 0, 0, 392, 400, 5, 69,
		0, 0, 393, 394, 5, 85, 0, 0, 394, 395, 3, 90, 45, 0, 395, 396, 5, 86, 0,
		0, 396, 400, 1, 0, 0, 0, 397, 400, 3, 4, 2, 0, 398, 400, 3, 12, 6, 0, 399,
		388, 1, 0, 0, 0, 399, 392, 1, 0, 0, 0, 399, 393, 1, 0, 0, 0, 399, 397,
		1, 0, 0, 0, 399, 398, 1, 0, 0, 0, 400, 3, 1, 0, 0, 0, 401, 404, 3, 6, 3,
		0, 402, 404, 3, 8, 4, 0, 403, 401, 1, 0, 0, 0, 403, 402, 1, 0, 0, 0, 404,
		5, 1, 0, 0, 0, 405, 416, 5, 132, 0, 0, 406, 416, 3, 330, 165, 0, 407, 416,
		3, 316, 158, 0, 408, 416, 3, 332, 166, 0, 409, 412, 5, 99, 0, 0, 410, 413,
		3, 278, 139, 0, 411, 413, 3, 162, 81, 0, 412, 410, 1, 0, 0, 0, 412, 411,
		1, 0, 0, 0, 413, 416, 1, 0, 0, 0, 414, 416, 3, 344, 172, 0, 415, 405, 1,
		0, 0, 0, 415, 406, 1, 0, 0, 0, 415, 407, 1, 0, 0, 0, 415, 408, 1, 0, 0,
		0, 415, 409, 1, 0, 0, 0, 415, 414, 1, 0, 0, 0, 416, 7, 1, 0, 0, 0, 417,
		419, 3, 10, 5, 0, 418, 420, 5, 68, 0, 0, 419, 418, 1, 0, 0, 0, 419, 420,
		1, 0, 0, 0, 420, 421, 1, 0, 0, 0, 421, 422, 3, 6, 3, 0, 422, 9, 1, 0, 0,
		0, 423, 427, 6, 5, -1, 0, 424, 428, 3, 160, 80, 0, 425, 428, 3, 184, 92,
		0, 426, 428, 3, 162, 81, 0, 427, 424, 1, 0, 0, 0, 427, 425, 1, 0, 0, 0,
		427, 426, 1, 0, 0, 0, 427, 428, 1, 0, 0, 0, 428, 429, 1, 0, 0, 0, 429,
		430, 5, 127, 0, 0, 430, 442, 1, 0, 0, 0, 431, 437, 10, 1, 0, 0, 432, 438,
		5, 132, 0, 0, 433, 435, 5, 68, 0, 0, 434, 433, 1, 0, 0, 0, 434, 435, 1,
		0, 0, 0, 435, 436, 1, 0, 0, 0, 436, 438, 3, 342, 171, 0, 437, 432, 1, 0,
		0, 0, 437, 434, 1, 0, 0, 0, 438, 439, 1, 0, 0, 0, 439, 441, 5, 127, 0,
		0, 440, 431, 1, 0, 0, 0, 441, 444, 1, 0, 0, 0, 442, 440, 1, 0, 0, 0, 442,
		443, 1, 0, 0, 0, 443, 11, 1, 0, 0, 0, 444, 442, 1, 0, 0, 0, 445, 447, 3,
		14, 7, 0, 446, 448, 3, 28, 14, 0, 447, 446, 1, 0, 0, 0, 447, 448, 1, 0,
		0, 0, 448, 449, 1, 0, 0, 0, 449, 450, 3, 100, 50, 0, 450, 13, 1, 0, 0,
		0, 451, 453, 5, 87, 0, 0, 452, 454, 3, 16, 8, 0, 453, 452, 1, 0, 0, 0,
		453, 454, 1, 0, 0, 0, 454, 455, 1, 0, 0, 0, 455, 456, 5, 88, 0, 0, 456,
		15, 1, 0, 0, 0, 457, 464, 3, 20, 10, 0, 458, 461, 3, 18, 9, 0, 459, 460,
		5, 122, 0, 0, 460, 462, 3, 20, 10, 0, 461, 459, 1, 0, 0, 0, 461, 462, 1,
		0, 0, 0, 462, 464, 1, 0, 0, 0, 463, 457, 1, 0, 0, 0, 463, 458, 1, 0, 0,
		0, 464, 17, 1, 0, 0, 0, 465, 466, 7, 0, 0, 0, 466, 19, 1, 0, 0, 0, 467,
		472, 3, 22, 11, 0, 468, 469, 5, 122, 0, 0, 469, 471, 3, 22, 11, 0, 470,
		468, 1, 0, 0, 0, 471, 474, 1, 0, 0, 0, 472, 470, 1, 0, 0, 0, 472, 473,
		1, 0, 0, 0, 473, 476, 1, 0, 0, 0, 474, 472, 1, 0, 0, 0, 475, 477, 5, 131,
		0, 0, 476, 475, 1, 0, 0, 0, 476, 477, 1, 0, 0, 0, 477, 21, 1, 0, 0, 0,
		478, 481, 3, 24, 12, 0, 479, 481, 3, 26, 13, 0, 480, 478, 1, 0, 0, 0, 480,
		479, 1, 0, 0, 0, 481, 23, 1, 0, 0, 0, 482, 484, 5, 97, 0, 0, 483, 482,
		1, 0, 0, 0, 483, 484, 1, 0, 0, 0, 484, 485, 1, 0, 0, 0, 485, 488, 5, 132,
		0, 0, 486, 488, 5, 69, 0, 0, 487, 483, 1, 0, 0, 0, 487, 486, 1, 0, 0, 0,
		488, 25, 1, 0, 0, 0, 489, 491, 5, 97, 0, 0, 490, 489, 1, 0, 0, 0, 490,
		491, 1, 0, 0, 0, 491, 492, 1, 0, 0, 0, 492, 493, 5, 132, 0, 0, 493, 494,
		3, 268, 134, 0, 494, 27, 1, 0, 0, 0, 495, 497, 5, 85, 0, 0, 496, 498, 3,
		258, 129, 0, 497, 496, 1, 0, 0, 0, 497, 498, 1, 0, 0, 0, 498, 499, 1, 0,
		0, 0, 499, 501, 5, 86, 0, 0, 500, 502, 5, 47, 0, 0, 501, 500, 1, 0, 0,
		0, 501, 502, 1, 0, 0, 0, 502, 504, 1, 0, 0, 0, 503, 505, 3, 370, 185, 0,
		504, 503, 1, 0, 0, 0, 504, 505, 1, 0, 0, 0, 505, 507, 1, 0, 0, 0, 506,
		508, 3, 204, 102, 0, 507, 506, 1, 0, 0, 0, 507, 508, 1, 0, 0, 0, 508, 510,
		1, 0, 0, 0, 509, 511, 3, 234, 117, 0, 510, 509, 1, 0, 0, 0, 510, 511, 1,
		0, 0, 0, 511, 29, 1, 0, 0, 0, 512, 513, 6, 15, -1, 0, 513, 543, 3, 2, 1,
		0, 514, 517, 3, 158, 79, 0, 515, 517, 3, 352, 176, 0, 516, 514, 1, 0, 0,
		0, 516, 515, 1, 0, 0, 0, 517, 524, 1, 0, 0, 0, 518, 520, 5, 85, 0, 0, 519,
		521, 3, 34, 17, 0, 520, 519, 1, 0, 0, 0, 520, 521, 1, 0, 0, 0, 521, 522,
		1, 0, 0, 0, 522, 525, 5, 86, 0, 0, 523, 525, 3, 276, 138, 0, 524, 518,
		1, 0, 0, 0, 524, 523, 1, 0, 0, 0, 525, 543, 1, 0, 0, 0, 526, 527, 7, 1,
		0, 0, 527, 528, 5, 102, 0, 0, 528, 529, 3, 246, 123, 0, 529, 530, 5, 103,
		0, 0, 530, 531, 5, 85, 0, 0, 531, 532, 3, 90, 45, 0, 532, 533, 5, 86, 0,
		0, 533, 543, 1, 0, 0, 0, 534, 535, 3, 32, 16, 0, 535, 538, 5, 85, 0, 0,
		536, 539, 3, 90, 45, 0, 537, 539, 3, 246, 123, 0, 538, 536, 1, 0, 0, 0,
		538, 537, 1, 0, 0, 0, 539, 540, 1, 0, 0, 0, 540, 541, 5, 86, 0, 0, 541,
		543, 1, 0, 0, 0, 542, 512, 1, 0, 0, 0, 542, 516, 1, 0, 0, 0, 542, 526,
		1, 0, 0, 0, 542, 534, 1, 0, 0, 0, 543, 571, 1, 0, 0, 0, 544, 545, 10, 7,
		0, 0, 545, 548, 5, 87, 0, 0, 546, 549, 3, 90, 45, 0, 547, 549, 3, 276,
		138, 0, 548, 546, 1, 0, 0, 0, 548, 547, 1, 0, 0, 0, 549, 550, 1, 0, 0,
		0, 550, 551, 5, 88, 0, 0, 551, 570, 1, 0, 0, 0, 552, 553, 10, 6, 0, 0,
		553, 555, 5, 85, 0, 0, 554, 556, 3, 34, 17, 0, 555, 554, 1, 0, 0, 0, 555,
		556, 1, 0, 0, 0, 556, 557, 1, 0, 0, 0, 557, 570, 5, 86, 0, 0, 558, 559,
		10, 4, 0, 0, 559, 565, 7, 2, 0, 0, 560, 562, 5, 68, 0, 0, 561, 560, 1,
		0, 0, 0, 561, 562, 1, 0, 0, 0, 562, 563, 1, 0, 0, 0, 563, 566, 3, 4, 2,
		0, 564, 566, 3, 36, 18, 0, 565, 561, 1, 0, 0, 0, 565, 564, 1, 0, 0, 0,
		566, 570, 1, 0, 0, 0, 567, 568, 10, 3, 0, 0, 568, 570, 7, 3, 0, 0, 569,
		544, 1, 0, 0, 0, 569, 552, 1, 0, 0, 0, 569, 558, 1, 0, 0, 0, 569, 567,
		1, 0, 0, 0, 570, 573, 1, 0, 0, 0, 571, 569, 1, 0, 0, 0, 571, 572, 1, 0,
		0, 0, 572, 31, 1, 0, 0, 0, 573, 571, 1, 0, 0, 0, 574, 575, 5, 75, 0, 0,
		575, 33, 1, 0, 0, 0, 576, 577, 3, 274, 137, 0, 577, 35, 1, 0, 0, 0, 578,
		580, 3, 10, 5, 0, 579, 578, 1, 0, 0, 0, 579, 580, 1, 0, 0, 0, 580, 584,
		1, 0, 0, 0, 581, 582, 3, 160, 80, 0, 582, 583, 5, 127, 0, 0, 583, 585,
		1, 0, 0, 0, 584, 581, 1, 0, 0, 0, 584, 585, 1, 0, 0, 0, 585, 586, 1, 0,
		0, 0, 586, 587, 5, 99, 0, 0, 587, 598, 3, 160, 80, 0, 588, 589, 3, 10,
		5, 0, 589, 590, 5, 68, 0, 0, 590, 591, 3, 342, 171, 0, 591, 592, 5, 127,
		0, 0, 592, 593, 5, 99, 0, 0, 593, 594, 3, 160, 80, 0, 594, 598, 1, 0, 0,
		0, 595, 596, 5, 99, 0, 0, 596, 598, 3, 162, 81, 0, 597, 579, 1, 0, 0, 0,
		597, 588, 1, 0, 0, 0, 597, 595, 1, 0, 0, 0, 598, 37, 1, 0, 0, 0, 599, 627,
		3, 30, 15, 0, 600, 605, 5, 120, 0, 0, 601, 605, 5, 121, 0, 0, 602, 605,
		3, 40, 20, 0, 603, 605, 5, 62, 0, 0, 604, 600, 1, 0, 0, 0, 604, 601, 1,
		0, 0, 0, 604, 602, 1, 0, 0, 0, 604, 603, 1, 0, 0, 0, 605, 606, 1, 0, 0,
		0, 606, 627, 3, 38, 19, 0, 607, 616, 5, 62, 0, 0, 608, 609, 5, 85, 0, 0,
		609, 610, 3, 246, 123, 0, 610, 611, 5, 86, 0, 0, 611, 617, 1, 0, 0, 0,
		612, 613, 5, 131, 0, 0, 613, 614, 5, 85, 0, 0, 614, 615, 5, 132, 0, 0,
		615, 617, 5, 86, 0, 0, 616, 608, 1, 0, 0, 0, 616, 612, 1, 0, 0, 0, 617,
		627, 1, 0, 0, 0, 618, 619, 5, 11, 0, 0, 619, 620, 5, 85, 0, 0, 620, 621,
		3, 246, 123, 0, 621, 622, 5, 86, 0, 0, 622, 627, 1, 0, 0, 0, 623, 627,
		3, 56, 28, 0, 624, 627, 3, 42, 21, 0, 625, 627, 3, 54, 27, 0, 626, 599,
		1, 0, 0, 0, 626, 604, 1, 0, 0, 0, 626, 607, 1, 0, 0, 0, 626, 618, 1, 0,
		0, 0, 626, 623, 1, 0, 0, 0, 626, 624, 1, 0, 0, 0, 626, 625, 1, 0, 0, 0,
		627, 39, 1, 0, 0, 0, 628, 629, 7, 4, 0, 0, 629, 41, 1, 0, 0, 0, 630, 632,
		5, 127, 0, 0, 631, 630, 1, 0, 0, 0, 631, 632, 1, 0, 0, 0, 632, 633, 1,
		0, 0, 0, 633, 635, 5, 49, 0, 0, 634, 636, 3, 44, 22, 0, 635, 634, 1, 0,
		0, 0, 635, 636, 1, 0, 0, 0, 636, 642, 1, 0, 0, 0, 637, 643, 3, 46, 23,
		0, 638, 639, 5, 85, 0, 0, 639, 640, 3, 246, 123, 0, 640, 641, 5, 86, 0,
		0, 641, 643, 1, 0, 0, 0, 642, 637, 1, 0, 0, 0, 642, 638, 1, 0, 0, 0, 643,
		645, 1, 0, 0, 0, 644, 646, 3, 52, 26, 0, 645, 644, 1, 0, 0, 0, 645, 646,
		1, 0, 0, 0, 646, 43, 1, 0, 0, 0, 647, 648, 5, 85, 0, 0, 648, 649, 3, 34,
		17, 0, 649, 650, 5, 86, 0, 0, 650, 45, 1, 0, 0, 0, 651, 653, 3, 150, 75,
		0, 652, 654, 3, 48, 24, 0, 653, 652, 1, 0, 0, 0, 653, 654, 1, 0, 0, 0,
		654, 47, 1, 0, 0, 0, 655, 657, 3, 236, 118, 0, 656, 658, 3, 48, 24, 0,
		657, 656, 1, 0, 0, 0, 657, 658, 1, 0, 0, 0, 658, 661, 1, 0, 0, 0, 659,
		661, 3, 50, 25, 0, 660, 655, 1, 0, 0, 0, 660, 659, 1, 0, 0, 0, 661, 49,
		1, 0, 0, 0, 662, 663, 6, 25, -1, 0, 663, 664, 5, 87, 0, 0, 664, 665, 3,
		90, 45, 0, 665, 667, 5, 88, 0, 0, 666, 668, 3, 204, 102, 0, 667, 666, 1,
		0, 0, 0, 667, 668, 1, 0, 0, 0, 668, 678, 1, 0, 0, 0, 669, 670, 10, 1, 0,
		0, 670, 671, 5, 87, 0, 0, 671, 672, 3, 92, 46, 0, 672, 674, 5, 88, 0, 0,
		673, 675, 3, 204, 102, 0, 674, 673, 1, 0, 0, 0, 674, 675, 1, 0, 0, 0, 675,
		677, 1, 0, 0, 0, 676, 669, 1, 0, 0, 0, 677, 680, 1, 0, 0, 0, 678, 676,
		1, 0, 0, 0, 678, 679, 1, 0, 0, 0, 679, 51, 1, 0, 0, 0, 680, 678, 1, 0,
		0, 0, 681, 683, 5, 85, 0, 0, 682, 684, 3, 34, 17, 0, 683, 682, 1, 0, 0,
		0, 683, 684, 1, 0, 0, 0, 684, 685, 1, 0, 0, 0, 685, 688, 5, 86, 0, 0, 686,
		688, 3, 276, 138, 0, 687, 681, 1, 0, 0, 0, 687, 686, 1, 0, 0, 0, 688, 53,
		1, 0, 0, 0, 689, 691, 5, 127, 0, 0, 690, 689, 1, 0, 0, 0, 690, 691, 1,
		0, 0, 0, 691, 692, 1, 0, 0, 0, 692, 695, 5, 28, 0, 0, 693, 694, 5, 87,
		0, 0, 694, 696, 5, 88, 0, 0, 695, 693, 1, 0, 0, 0, 695, 696, 1, 0, 0, 0,
		696, 697, 1, 0, 0, 0, 697, 698, 3, 58, 29, 0, 698, 55, 1, 0, 0, 0, 699,
		700, 5, 50, 0, 0, 700, 701, 5, 85, 0, 0, 701, 702, 3, 90, 45, 0, 702, 703,
		5, 86, 0, 0, 703, 57, 1, 0, 0, 0, 704, 711, 3, 38, 19, 0, 705, 706, 5,
		85, 0, 0, 706, 707, 3, 246, 123, 0, 707, 708, 5, 86, 0, 0, 708, 709, 3,
		58, 29, 0, 709, 711, 1, 0, 0, 0, 710, 704, 1, 0, 0, 0, 710, 705, 1, 0,
		0, 0, 711, 59, 1, 0, 0, 0, 712, 717, 3, 58, 29, 0, 713, 714, 7, 5, 0, 0,
		714, 716, 3, 58, 29, 0, 715, 713, 1, 0, 0, 0, 716, 719, 1, 0, 0, 0, 717,
		715, 1, 0, 0, 0, 717, 718, 1, 0, 0, 0, 718, 61, 1, 0, 0, 0, 719, 717, 1,
		0, 0, 0, 720, 725, 3, 60, 30, 0, 721, 722, 7, 6, 0, 0, 722, 724, 3, 60,
		30, 0, 723, 721, 1, 0, 0, 0, 724, 727, 1, 0, 0, 0, 725, 723, 1, 0, 0, 0,
		725, 726, 1, 0, 0, 0, 726, 63, 1, 0, 0, 0, 727, 725, 1, 0, 0, 0, 728, 733,
		3, 62, 31, 0, 729, 730, 7, 7, 0, 0, 730, 732, 3, 62, 31, 0, 731, 729, 1,
		0, 0, 0, 732, 735, 1, 0, 0, 0, 733, 731, 1, 0, 0, 0, 733, 734, 1, 0, 0,
		0, 734, 65, 1, 0, 0, 0, 735, 733, 1, 0, 0, 0, 736, 742, 3, 64, 32, 0, 737,
		738, 3, 68, 34, 0, 738, 739, 3, 64, 32, 0, 739, 741, 1, 0, 0, 0, 740, 737,
		1, 0, 0, 0, 741, 744, 1, 0, 0, 0, 742, 740, 1, 0, 0, 0, 742, 743, 1, 0,
		0, 0, 743, 67, 1, 0, 0, 0, 744, 742, 1, 0, 0, 0, 745, 746, 5, 103, 0, 0,
		746, 750, 5, 103, 0, 0, 747, 748, 5, 102, 0, 0, 748, 750, 5, 102, 0, 0,
		749, 745, 1, 0, 0, 0, 749, 747, 1, 0, 0, 0, 750, 69, 1, 0, 0, 0, 751, 756,
		3, 66, 33, 0, 752, 753, 7, 8, 0, 0, 753, 755, 3, 66, 33, 0, 754, 752, 1,
		0, 0, 0, 755, 758, 1, 0, 0, 0, 756, 754, 1, 0, 0, 0, 756, 757, 1, 0, 0,
		0, 757, 71, 1, 0, 0, 0, 758, 756, 1, 0, 0, 0, 759, 764, 3, 70, 35, 0, 760,
		761, 7, 9, 0, 0, 761, 763, 3, 70, 35, 0, 762, 760, 1, 0, 0, 0, 763, 766,
		1, 0, 0, 0, 764, 762, 1, 0, 0, 0, 764, 765, 1, 0, 0, 0, 765, 73, 1, 0,
		0, 0, 766, 764, 1, 0, 0, 0, 767, 772, 3, 72, 36, 0, 768, 769, 5, 97, 0,
		0, 769, 771, 3, 72, 36, 0, 770, 768, 1, 0, 0, 0, 771, 774, 1, 0, 0, 0,
		772, 770, 1, 0, 0, 0, 772, 773, 1, 0, 0, 0, 773, 75, 1, 0, 0, 0, 774, 772,
		1, 0, 0, 0, 775, 780, 3, 74, 37, 0, 776, 777, 5, 96, 0, 0, 777, 779, 3,
		74, 37, 0, 778, 776, 1, 0, 0, 0, 779, 782, 1, 0, 0, 0, 780, 778, 1, 0,
		0, 0, 780, 781, 1, 0, 0, 0, 781, 77, 1, 0, 0, 0, 782, 780, 1, 0, 0, 0,
		783, 788, 3, 76, 38, 0, 784, 785, 5, 98, 0, 0, 785, 787, 3, 76, 38, 0,
		786, 784, 1, 0, 0, 0, 787, 790, 1, 0, 0, 0, 788, 786, 1, 0, 0, 0, 788,
		789, 1, 0, 0, 0, 789, 79, 1, 0, 0, 0, 790, 788, 1, 0, 0, 0, 791, 796, 3,
		78, 39, 0, 792, 793, 5, 118, 0, 0, 793, 795, 3, 78, 39, 0, 794, 792, 1,
		0, 0, 0, 795, 798, 1, 0, 0, 0, 796, 794, 1, 0, 0, 0, 796, 797, 1, 0, 0,
		0, 797, 81, 1, 0, 0, 0, 798, 796, 1, 0, 0, 0, 799, 804, 3, 80, 40, 0, 800,
		801, 5, 119, 0, 0, 801, 803, 3, 80, 40, 0, 802, 800, 1, 0, 0, 0, 803, 806,
		1, 0, 0, 0, 804, 802, 1, 0, 0, 0, 804, 805, 1, 0, 0, 0, 805, 83, 1, 0,
		0, 0, 806, 804, 1, 0, 0, 0, 807, 813, 3, 82, 41, 0, 808, 809, 5, 125, 0,
		0, 809, 810, 3, 90, 45, 0, 810, 811, 5, 126, 0, 0, 811, 812, 3, 86, 43,
		0, 812, 814, 1, 0, 0, 0, 813, 808, 1, 0, 0, 0, 813, 814, 1, 0, 0, 0, 814,
		85, 1, 0, 0, 0, 815, 822, 3, 84, 42, 0, 816, 817, 3, 82, 41, 0, 817, 818,
		3, 88, 44, 0, 818, 819, 3, 272, 136, 0, 819, 822, 1, 0, 0, 0, 820, 822,
		3, 368, 184, 0, 821, 815, 1, 0, 0, 0, 821, 816, 1, 0, 0, 0, 821, 820, 1,
		0, 0, 0, 822, 87, 1, 0, 0, 0, 823, 824, 7, 10, 0, 0, 824, 89, 1, 0, 0,
		0, 825, 830, 3, 86, 43, 0, 826, 827, 5, 122, 0, 0, 827, 829, 3, 86, 43,
		0, 828, 826, 1, 0, 0, 0, 829, 832, 1, 0, 0, 0, 830, 828, 1, 0, 0, 0, 830,
		831, 1, 0, 0, 0, 831, 91, 1, 0, 0, 0, 832, 830, 1, 0, 0, 0, 833, 834, 3,
		84, 42, 0, 834, 93, 1, 0, 0, 0, 835, 849, 3, 96, 48, 0, 836, 849, 3, 118,
		59, 0, 837, 839, 3, 204, 102, 0, 838, 837, 1, 0, 0, 0, 838, 839, 1, 0,
		0, 0, 839, 846, 1, 0, 0, 0, 840, 847, 3, 98, 49, 0, 841, 847, 3, 100, 50,
		0, 842, 847, 3, 104, 52, 0, 843, 847, 3, 108, 54, 0, 844, 847, 3, 116,
		58, 0, 845, 847, 3, 358, 179, 0, 846, 840, 1, 0, 0, 0, 846, 841, 1, 0,
		0, 0, 846, 842, 1, 0, 0, 0, 846, 843, 1, 0, 0, 0, 846, 844, 1, 0, 0, 0,
		846, 845, 1, 0, 0, 0, 847, 849, 1, 0, 0, 0, 848, 835, 1, 0, 0, 0, 848,
		836, 1, 0, 0, 0, 848, 838, 1, 0, 0, 0, 849, 95, 1, 0, 0, 0, 850, 852, 3,
		204, 102, 0, 851, 850, 1, 0, 0, 0, 851, 852, 1, 0, 0, 0, 852, 857, 1, 0,
		0, 0, 853, 858, 5, 132, 0, 0, 854, 855, 5, 16, 0, 0, 855, 858, 3, 92, 46,
		0, 856, 858, 5, 27, 0, 0, 857, 853, 1, 0, 0, 0, 857, 854, 1, 0, 0, 0, 857,
		856, 1, 0, 0, 0, 858, 859, 1, 0, 0, 0, 859, 860, 5, 126, 0, 0, 860, 861,
		3, 94, 47, 0, 861, 97, 1, 0, 0, 0, 862, 864, 3, 90, 45, 0, 863, 862, 1,
		0, 0, 0, 863, 864, 1, 0, 0, 0, 864, 865, 1, 0, 0, 0, 865, 866, 5, 128,
		0, 0, 866, 99, 1, 0, 0, 0, 867, 869, 5, 89, 0, 0, 868, 870, 3, 102, 51,
		0, 869, 868, 1, 0, 0, 0, 869, 870, 1, 0, 0, 0, 870, 871, 1, 0, 0, 0, 871,
		872, 5, 90, 0, 0, 872, 101, 1, 0, 0, 0, 873, 875, 3, 94, 47, 0, 874, 873,
		1, 0, 0, 0, 875, 876, 1, 0, 0, 0, 876, 874, 1, 0, 0, 0, 876, 877, 1, 0,
		0, 0, 877, 103, 1, 0, 0, 0, 878, 879, 5, 43, 0, 0, 879, 880, 5, 85, 0,
		0, 880, 881, 3, 106, 53, 0, 881, 882, 5, 86, 0, 0, 882, 885, 3, 94, 47,
		0, 883, 884, 5, 32, 0, 0, 884, 886, 3, 94, 47, 0, 885, 883, 1, 0, 0, 0,
		885, 886, 1, 0, 0, 0, 886, 894, 1, 0, 0, 0, 887, 888, 5, 67, 0, 0, 888,
		889, 5, 85, 0, 0, 889, 890, 3, 106, 53, 0, 890, 891, 5, 86, 0, 0, 891,
		892, 3, 94, 47, 0, 892, 894, 1, 0, 0, 0, 893, 878, 1, 0, 0, 0, 893, 887,
		1, 0, 0, 0, 894, 105, 1, 0, 0, 0, 895, 907, 3, 90, 45, 0, 896, 898, 3,
		204, 102, 0, 897, 896, 1, 0, 0, 0, 897, 898, 1, 0, 0, 0, 898, 899, 1, 0,
		0, 0, 899, 900, 3, 138, 69, 0, 900, 904, 3, 226, 113, 0, 901, 902, 5, 101,
		0, 0, 902, 905, 3, 272, 136, 0, 903, 905, 3, 276, 138, 0, 904, 901, 1,
		0, 0, 0, 904, 903, 1, 0, 0, 0, 905, 907, 1, 0, 0, 0, 906, 895, 1, 0, 0,
		0, 906, 897, 1, 0, 0, 0, 907, 107, 1, 0, 0, 0, 908, 909, 5, 84, 0, 0, 909,
		910, 5, 85, 0, 0, 910, 911, 3, 106, 53, 0, 911, 912, 5, 86, 0, 0, 912,
		913, 3, 94, 47, 0, 913, 942, 1, 0, 0, 0, 914, 915, 5, 29, 0, 0, 915, 916,
		3, 94, 47, 0, 916, 917, 5, 84, 0, 0, 917, 918, 5, 85, 0, 0, 918, 919, 3,
		90, 45, 0, 919, 920, 5, 86, 0, 0, 920, 921, 5, 128, 0, 0, 921, 942, 1,
		0, 0, 0, 922, 923, 5, 40, 0, 0, 923, 936, 5, 85, 0, 0, 924, 926, 3, 110,
		55, 0, 925, 927, 3, 106, 53, 0, 926, 925, 1, 0, 0, 0, 926, 927, 1, 0, 0,
		0, 927, 928, 1, 0, 0, 0, 928, 930, 5, 128, 0, 0, 929, 931, 3, 90, 45, 0,
		930, 929, 1, 0, 0, 0, 930, 931, 1, 0, 0, 0, 931, 937, 1, 0, 0, 0, 932,
		933, 3, 112, 56, 0, 933, 934, 5, 126, 0, 0, 934, 935, 3, 114, 57, 0, 935,
		937, 1, 0, 0, 0, 936, 924, 1, 0, 0, 0, 936, 932, 1, 0, 0, 0, 937, 938,
		1, 0, 0, 0, 938, 939, 5, 86, 0, 0, 939, 940, 3, 94, 47, 0, 940, 942, 1,
		0, 0, 0, 941, 908, 1, 0, 0, 0, 941, 914, 1, 0, 0, 0, 941, 922, 1, 0, 0,
		0, 942, 109, 1, 0, 0, 0, 943, 946, 3, 98, 49, 0, 944, 946, 3, 128, 64,
		0, 945, 943, 1, 0, 0, 0, 945, 944, 1, 0, 0, 0, 946, 111, 1, 0, 0, 0, 947,
		949, 3, 204, 102, 0, 948, 947, 1, 0, 0, 0, 948, 949, 1, 0, 0, 0, 949, 950,
		1, 0, 0, 0, 950, 951, 3, 138, 69, 0, 951, 952, 3, 226, 113, 0, 952, 113,
		1, 0, 0, 0, 953, 956, 3, 90, 45, 0, 954, 956, 3, 276, 138, 0, 955, 953,
		1, 0, 0, 0, 955, 954, 1, 0, 0, 0, 956, 115, 1, 0, 0, 0, 957, 967, 5, 15,
		0, 0, 958, 967, 5, 25, 0, 0, 959, 962, 5, 59, 0, 0, 960, 963, 3, 90, 45,
		0, 961, 963, 3, 276, 138, 0, 962, 960, 1, 0, 0, 0, 962, 961, 1, 0, 0, 0,
		962, 963, 1, 0, 0, 0, 963, 967, 1, 0, 0, 0, 964, 965, 5, 42, 0, 0, 965,
		967, 5, 132, 0, 0, 966, 957, 1, 0, 0, 0, 966, 958, 1, 0, 0, 0, 966, 959,
		1, 0, 0, 0, 966, 964, 1, 0, 0, 0, 967, 968, 1, 0, 0, 0, 968, 969, 5, 128,
		0, 0, 969, 117, 1, 0, 0, 0, 970, 971, 3, 124, 62, 0, 971, 119, 1, 0, 0,
		0, 972, 974, 3, 122, 61, 0, 973, 972, 1, 0, 0, 0, 974, 975, 1, 0, 0, 0,
		975, 973, 1, 0, 0, 0, 975, 976, 1, 0, 0, 0, 976, 121, 1, 0, 0, 0, 977,
		987, 3, 124, 62, 0, 978, 987, 3, 264, 132, 0, 979, 987, 3, 334, 167, 0,
		980, 987, 3, 354, 177, 0, 981, 987, 3, 356, 178, 0, 982, 987, 3, 202, 101,
		0, 983, 987, 3, 188, 94, 0, 984, 987, 3, 132, 66, 0, 985, 987, 3, 134,
		67, 0, 986, 977, 1, 0, 0, 0, 986, 978, 1, 0, 0, 0, 986, 979, 1, 0, 0, 0,
		986, 980, 1, 0, 0, 0, 986, 981, 1, 0, 0, 0, 986, 982, 1, 0, 0, 0, 986,
		983, 1, 0, 0, 0, 986, 984, 1, 0, 0, 0, 986, 985, 1, 0, 0, 0, 987, 123,
		1, 0, 0, 0, 988, 997, 3, 128, 64, 0, 989, 997, 3, 200, 100, 0, 990, 997,
		3, 192, 96, 0, 991, 997, 3, 196, 98, 0, 992, 997, 3, 198, 99, 0, 993, 997,
		3, 130, 65, 0, 994, 997, 3, 126, 63, 0, 995, 997, 3, 172, 86, 0, 996, 988,
		1, 0, 0, 0, 996, 989, 1, 0, 0, 0, 996, 990, 1, 0, 0, 0, 996, 991, 1, 0,
		0, 0, 996, 992, 1, 0, 0, 0, 996, 993, 1, 0, 0, 0, 996, 994, 1, 0, 0, 0,
		996, 995, 1, 0, 0, 0, 997, 125, 1, 0, 0, 0, 998, 999, 5, 79, 0, 0, 999,
		1001, 5, 132, 0, 0, 1000, 1002, 3, 204, 102, 0, 1001, 1000, 1, 0, 0, 0,
		1001, 1002, 1, 0, 0, 0, 1002, 1003, 1, 0, 0, 0, 1003, 1004, 5, 101, 0,
		0, 1004, 1005, 3, 246, 123, 0, 1005, 1006, 5, 128, 0, 0, 1006, 127, 1,
		0, 0, 0, 1007, 1009, 3, 138, 69, 0, 1008, 1007, 1, 0, 0, 0, 1008, 1009,
		1, 0, 0, 0, 1009, 1011, 1, 0, 0, 0, 1010, 1012, 3, 222, 111, 0, 1011, 1010,
		1, 0, 0, 0, 1011, 1012, 1, 0, 0, 0, 1012, 1013, 1, 0, 0, 0, 1013, 1022,
		5, 128, 0, 0, 1014, 1016, 3, 204, 102, 0, 1015, 1017, 3, 138, 69, 0, 1016,
		1015, 1, 0, 0, 0, 1016, 1017, 1, 0, 0, 0, 1017, 1018, 1, 0, 0, 0, 1018,
		1019, 3, 222, 111, 0, 1019, 1020, 5, 128, 0, 0, 1020, 1022, 1, 0, 0, 0,
		1021, 1008, 1, 0, 0, 0, 1021, 1014, 1, 0, 0, 0, 1022, 129, 1, 0, 0, 0,
		1023, 1024, 5, 64, 0, 0, 1024, 1025, 5, 85, 0, 0, 1025, 1026, 3, 92, 46,
		0, 1026, 1027, 5, 122, 0, 0, 1027, 1028, 5, 4, 0, 0, 1028, 1029, 5, 86,
		0, 0, 1029, 1030, 5, 128, 0, 0, 1030, 131, 1, 0, 0, 0, 1031, 1032, 5, 128,
		0, 0, 1032, 133, 1, 0, 0, 0, 1033, 1034, 3, 204, 102, 0, 1034, 1035, 5,
		128, 0, 0, 1035, 135, 1, 0, 0, 0, 1036, 1043, 3, 140, 70, 0, 1037, 1043,
		3, 146, 73, 0, 1038, 1043, 3, 142, 71, 0, 1039, 1043, 5, 41, 0, 0, 1040,
		1043, 5, 74, 0, 0, 1041, 1043, 5, 23, 0, 0, 1042, 1036, 1, 0, 0, 0, 1042,
		1037, 1, 0, 0, 0, 1042, 1038, 1, 0, 0, 0, 1042, 1039, 1, 0, 0, 0, 1042,
		1040, 1, 0, 0, 0, 1042, 1041, 1, 0, 0, 0, 1043, 137, 1, 0, 0, 0, 1044,
		1046, 3, 136, 68, 0, 1045, 1044, 1, 0, 0, 0, 1046, 1047, 1, 0, 0, 0, 1047,
		1048, 1, 0, 0, 0, 1047, 1045, 1, 0, 0, 0, 1048, 1050, 1, 0, 0, 0, 1049,
		1051, 3, 204, 102, 0, 1050, 1049, 1, 0, 0, 0, 1050, 1051, 1, 0, 0, 0, 1051,
		139, 1, 0, 0, 0, 1052, 1053, 7, 11, 0, 0, 1053, 141, 1, 0, 0, 0, 1054,
		1055, 7, 12, 0, 0, 1055, 143, 1, 0, 0, 0, 1056, 1057, 5, 132, 0, 0, 1057,
		145, 1, 0, 0, 0, 1058, 1062, 3, 148, 74, 0, 1059, 1062, 3, 280, 140, 0,
		1060, 1062, 3, 168, 84, 0, 1061, 1058, 1, 0, 0, 0, 1061, 1059, 1, 0, 0,
		0, 1061, 1060, 1, 0, 0, 0, 1062, 147, 1, 0, 0, 0, 1063, 1068, 3, 158, 79,
		0, 1064, 1068, 3, 164, 82, 0, 1065, 1068, 3, 352, 176, 0, 1066, 1068, 3,
		240, 120, 0, 1067, 1063, 1, 0, 0, 0, 1067, 1064, 1, 0, 0, 0, 1067, 1065,
		1, 0, 0, 0, 1067, 1066, 1, 0, 0, 0, 1068, 149, 1, 0, 0, 0, 1069, 1071,
		3, 146, 73, 0, 1070, 1069, 1, 0, 0, 0, 1071, 1072, 1, 0, 0, 0, 1072, 1070,
		1, 0, 0, 0, 1072, 1073, 1, 0, 0, 0, 1073, 1075, 1, 0, 0, 0, 1074, 1076,
		3, 204, 102, 0, 1075, 1074, 1, 0, 0, 0, 1075, 1076, 1, 0, 0, 0, 1076, 151,
		1, 0, 0, 0, 1077, 1079, 3, 148, 74, 0, 1078, 1077, 1, 0, 0, 0, 1079, 1080,
		1, 0, 0, 0, 1080, 1078, 1, 0, 0, 0, 1080, 1081, 1, 0, 0, 0, 1081, 1083,
		1, 0, 0, 0, 1082, 1084, 3, 204, 102, 0, 1083, 1082, 1, 0, 0, 0, 1083, 1084,
		1, 0, 0, 0, 1084, 153, 1, 0, 0, 0, 1085, 1086, 7, 13, 0, 0, 1086, 155,
		1, 0, 0, 0, 1087, 1088, 7, 14, 0, 0, 1088, 157, 1, 0, 0, 0, 1089, 1091,
		3, 10, 5, 0, 1090, 1089, 1, 0, 0, 0, 1090, 1091, 1, 0, 0, 0, 1091, 1092,
		1, 0, 0, 0, 1092, 1114, 3, 160, 80, 0, 1093, 1094, 3, 10, 5, 0, 1094, 1095,
		5, 68, 0, 0, 1095, 1096, 3, 342, 171, 0, 1096, 1114, 1, 0, 0, 0, 1097,
		1114, 5, 18, 0, 0, 1098, 1114, 5, 19, 0, 0, 1099, 1114, 5, 20, 0, 0, 1100,
		1114, 5, 83, 0, 0, 1101, 1114, 5, 14, 0, 0, 1102, 1114, 5, 60, 0, 0, 1103,
		1114, 5, 45, 0, 0, 1104, 1114, 5, 46, 0, 0, 1105, 1114, 5, 39, 0, 0, 1106,
		1114, 5, 61, 0, 0, 1107, 1114, 5, 78, 0, 0, 1108, 1114, 5, 39, 0, 0, 1109,
		1114, 5, 30, 0, 0, 1110, 1114, 5, 81, 0, 0, 1111, 1114, 5, 13, 0, 0, 1112,
		1114, 3, 162, 81, 0, 1113, 1090, 1, 0, 0, 0, 1113, 1093, 1, 0, 0, 0, 1113,
		1097, 1, 0, 0, 0, 1113, 1098, 1, 0, 0, 0, 1113, 1099, 1, 0, 0, 0, 1113,
		1100, 1, 0, 0, 0, 1113, 1101, 1, 0, 0, 0, 1113, 1102, 1, 0, 0, 0, 1113,
		1103, 1, 0, 0, 0, 1113, 1104, 1, 0, 0, 0, 1113, 1105, 1, 0, 0, 0, 1113,
		1106, 1, 0, 0, 0, 1113, 1107, 1, 0, 0, 0, 1113, 1108, 1, 0, 0, 0, 1113,
		1109, 1, 0, 0, 0, 1113, 1110, 1, 0, 0, 0, 1113, 1111, 1, 0, 0, 0, 1113,
		1112, 1, 0, 0, 0, 1114, 159, 1, 0, 0, 0, 1115, 1120, 3, 278, 139, 0, 1116,
		1120, 3, 166, 83, 0, 1117, 1120, 3, 144, 72, 0, 1118, 1120, 3, 342, 171,
		0, 1119, 1115, 1, 0, 0, 0, 1119, 1116, 1, 0, 0, 0, 1119, 1117, 1, 0, 0,
		0, 1119, 1118, 1, 0, 0, 0, 1120, 161, 1, 0, 0, 0, 1121, 1122, 5, 26, 0,
		0, 1122, 1125, 5, 85, 0, 0, 1123, 1126, 3, 90, 45, 0, 1124, 1126, 5, 13,
		0, 0, 1125, 1123, 1, 0, 0, 0, 1125, 1124, 1, 0, 0, 0, 1126, 1127, 1, 0,
		0, 0, 1127, 1128, 5, 86, 0, 0, 1128, 163, 1, 0, 0, 0, 1129, 1144, 3, 288,
		144, 0, 1130, 1132, 3, 204, 102, 0, 1131, 1130, 1, 0, 0, 0, 1131, 1132,
		1, 0, 0, 0, 1132, 1134, 1, 0, 0, 0, 1133, 1135, 3, 10, 5, 0, 1134, 1133,
		1, 0, 0, 0, 1134, 1135, 1, 0, 0, 0, 1135, 1136, 1, 0, 0, 0, 1136, 1145,
		5, 132, 0, 0, 1137, 1145, 3, 342, 171, 0, 1138, 1140, 3, 10, 5, 0, 1139,
		1141, 5, 68, 0, 0, 1140, 1139, 1, 0, 0, 0, 1140, 1141, 1, 0, 0, 0, 1141,
		1142, 1, 0, 0, 0, 1142, 1143, 3, 342, 171, 0, 1143, 1145, 1, 0, 0, 0, 1144,
		1131, 1, 0, 0, 0, 1144, 1137, 1, 0, 0, 0, 1144, 1138, 1, 0, 0, 0, 1145,
		1152, 1, 0, 0, 0, 1146, 1148, 5, 33, 0, 0, 1147, 1149, 3, 10, 5, 0, 1148,
		1147, 1, 0, 0, 0, 1148, 1149, 1, 0, 0, 0, 1149, 1150, 1, 0, 0, 0, 1150,
		1152, 5, 132, 0, 0, 1151, 1129, 1, 0, 0, 0, 1151, 1146, 1, 0, 0, 0, 1152,
		165, 1, 0, 0, 0, 1153, 1154, 5, 132, 0, 0, 1154, 167, 1, 0, 0, 0, 1155,
		1156, 3, 170, 85, 0, 1156, 1161, 5, 89, 0, 0, 1157, 1159, 3, 178, 89, 0,
		1158, 1160, 5, 122, 0, 0, 1159, 1158, 1, 0, 0, 0, 1159, 1160, 1, 0, 0,
		0, 1160, 1162, 1, 0, 0, 0, 1161, 1157, 1, 0, 0, 0, 1161, 1162, 1, 0, 0,
		0, 1162, 1163, 1, 0, 0, 0, 1163, 1164, 5, 90, 0, 0, 1164, 169, 1, 0, 0,
		0, 1165, 1167, 3, 174, 87, 0, 1166, 1168, 3, 204, 102, 0, 1167, 1166, 1,
		0, 0, 0, 1167, 1168, 1, 0, 0, 0, 1168, 1173, 1, 0, 0, 0, 1169, 1171, 3,
		10, 5, 0, 1170, 1169, 1, 0, 0, 0, 1170, 1171, 1, 0, 0, 0, 1171, 1172, 1,
		0, 0, 0, 1172, 1174, 5, 132, 0, 0, 1173, 1170, 1, 0, 0, 0, 1173, 1174,
		1, 0, 0, 0, 1174, 1176, 1, 0, 0, 0, 1175, 1177, 3, 176, 88, 0, 1176, 1175,
		1, 0, 0, 0, 1176, 1177, 1, 0, 0, 0, 1177, 171, 1, 0, 0, 0, 1178, 1180,
		3, 174, 87, 0, 1179, 1181, 3, 204, 102, 0, 1180, 1179, 1, 0, 0, 0, 1180,
		1181, 1, 0, 0, 0, 1181, 1182, 1, 0, 0, 0, 1182, 1184, 5, 132, 0, 0, 1183,
		1185, 3, 176, 88, 0, 1184, 1183, 1, 0, 0, 0, 1184, 1185, 1, 0, 0, 0, 1185,
		1186, 1, 0, 0, 0, 1186, 1187, 5, 128, 0, 0, 1187, 173, 1, 0, 0, 0, 1188,
		1190, 5, 33, 0, 0, 1189, 1191, 7, 15, 0, 0, 1190, 1189, 1, 0, 0, 0, 1190,
		1191, 1, 0, 0, 0, 1191, 175, 1, 0, 0, 0, 1192, 1193, 5, 126, 0, 0, 1193,
		1194, 3, 150, 75, 0, 1194, 177, 1, 0, 0, 0, 1195, 1200, 3, 180, 90, 0,
		1196, 1197, 5, 122, 0, 0, 1197, 1199, 3, 180, 90, 0, 1198, 1196, 1, 0,
		0, 0, 1199, 1202, 1, 0, 0, 0, 1200, 1198, 1, 0, 0, 0, 1200, 1201, 1, 0,
		0, 0, 1201, 179, 1, 0, 0, 0, 1202, 1200, 1, 0, 0, 0, 1203, 1206, 3, 182,
		91, 0, 1204, 1205, 5, 101, 0, 0, 1205, 1207, 3, 92, 46, 0, 1206, 1204,
		1, 0, 0, 0, 1206, 1207, 1, 0, 0, 0, 1207, 181, 1, 0, 0, 0, 1208, 1209,
		5, 132, 0, 0, 1209, 183, 1, 0, 0, 0, 1210, 1213, 3, 186, 93, 0, 1211, 1213,
		3, 190, 95, 0, 1212, 1210, 1, 0, 0, 0, 1212, 1211, 1, 0, 0, 0, 1213, 185,
		1, 0, 0, 0, 1214, 1215, 5, 132, 0, 0, 1215, 187, 1, 0, 0, 0, 1216, 1218,
		5, 44, 0, 0, 1217, 1216, 1, 0, 0, 0, 1217, 1218, 1, 0, 0, 0, 1218, 1219,
		1, 0, 0, 0, 1219, 1222, 5, 48, 0, 0, 1220, 1223, 5, 132, 0, 0, 1221, 1223,
		3, 186, 93, 0, 1222, 1220, 1, 0, 0, 0, 1222, 1221, 1, 0, 0, 0, 1222, 1223,
		1, 0, 0, 0, 1223, 1224, 1, 0, 0, 0, 1224, 1226, 5, 89, 0, 0, 1225, 1227,
		3, 120, 60, 0, 1226, 1225, 1, 0, 0, 0, 1226, 1227, 1, 0, 0, 0, 1227, 1228,
		1, 0, 0, 0, 1228, 1229, 5, 90, 0, 0, 1229, 189, 1, 0, 0, 0, 1230, 1231,
		5, 132, 0, 0, 1231, 191, 1, 0, 0, 0, 1232, 1233, 5, 48, 0, 0, 1233, 1234,
		5, 132, 0, 0, 1234, 1235, 5, 101, 0, 0, 1235, 1236, 3, 194, 97, 0, 1236,
		1237, 5, 128, 0, 0, 1237, 193, 1, 0, 0, 0, 1238, 1240, 3, 10, 5, 0, 1239,
		1238, 1, 0, 0, 0, 1239, 1240, 1, 0, 0, 0, 1240, 1241, 1, 0, 0, 0, 1241,
		1242, 3, 184, 92, 0, 1242, 195, 1, 0, 0, 0, 1243, 1249, 5, 79, 0, 0, 1244,
		1246, 5, 76, 0, 0, 1245, 1244, 1, 0, 0, 0, 1245, 1246, 1, 0, 0, 0, 1246,
		1247, 1, 0, 0, 0, 1247, 1250, 3, 10, 5, 0, 1248, 1250, 5, 127, 0, 0, 1249,
		1245, 1, 0, 0, 0, 1249, 1248, 1, 0, 0, 0, 1250, 1251, 1, 0, 0, 0, 1251,
		1252, 3, 6, 3, 0, 1252, 1253, 5, 128, 0, 0, 1253, 197, 1, 0, 0, 0, 1254,
		1256, 3, 204, 102, 0, 1255, 1254, 1, 0, 0, 0, 1255, 1256, 1, 0, 0, 0, 1256,
		1257, 1, 0, 0, 0, 1257, 1258, 5, 79, 0, 0, 1258, 1260, 5, 48, 0, 0, 1259,
		1261, 3, 10, 5, 0, 1260, 1259, 1, 0, 0, 0, 1260, 1261, 1, 0, 0, 0, 1261,
		1262, 1, 0, 0, 0, 1262, 1263, 3, 184, 92, 0, 1263, 1264, 5, 128, 0, 0,
		1264, 199, 1, 0, 0, 0, 1265, 1266, 5, 12, 0, 0, 1266, 1267, 5, 85, 0, 0,
		1267, 1268, 5, 4, 0, 0, 1268, 1269, 5, 86, 0, 0, 1269, 1270, 5, 128, 0,
		0, 1270, 201, 1, 0, 0, 0, 1271, 1272, 5, 36, 0, 0, 1272, 1279, 5, 4, 0,
		0, 1273, 1275, 5, 89, 0, 0, 1274, 1276, 3, 120, 60, 0, 1275, 1274, 1, 0,
		0, 0, 1275, 1276, 1, 0, 0, 0, 1276, 1277, 1, 0, 0, 0, 1277, 1280, 5, 90,
		0, 0, 1278, 1280, 3, 122, 61, 0, 1279, 1273, 1, 0, 0, 0, 1279, 1278, 1,
		0, 0, 0, 1280, 203, 1, 0, 0, 0, 1281, 1283, 3, 206, 103, 0, 1282, 1281,
		1, 0, 0, 0, 1283, 1284, 1, 0, 0, 0, 1284, 1282, 1, 0, 0, 0, 1284, 1285,
		1, 0, 0, 0, 1285, 205, 1, 0, 0, 0, 1286, 1287, 5, 87, 0, 0, 1287, 1289,
		5, 87, 0, 0, 1288, 1290, 3, 210, 105, 0, 1289, 1288, 1, 0, 0, 0, 1289,
		1290, 1, 0, 0, 0, 1290, 1291, 1, 0, 0, 0, 1291, 1292, 5, 88, 0, 0, 1292,
		1295, 5, 88, 0, 0, 1293, 1295, 3, 208, 104, 0, 1294, 1286, 1, 0, 0, 0,
		1294, 1293, 1, 0, 0, 0, 1295, 207, 1, 0, 0, 0, 1296, 1297, 5, 10, 0, 0,
		1297, 1300, 5, 85, 0, 0, 1298, 1301, 3, 246, 123, 0, 1299, 1301, 3, 92,
		46, 0, 1300, 1298, 1, 0, 0, 0, 1300, 1299, 1, 0, 0, 0, 1301, 1303, 1, 0,
		0, 0, 1302, 1304, 5, 131, 0, 0, 1303, 1302, 1, 0, 0, 0, 1303, 1304, 1,
		0, 0, 0, 1304, 1305, 1, 0, 0, 0, 1305, 1306, 5, 86, 0, 0, 1306, 209, 1,
		0, 0, 0, 1307, 1312, 3, 212, 106, 0, 1308, 1309, 5, 122, 0, 0, 1309, 1311,
		3, 212, 106, 0, 1310, 1308, 1, 0, 0, 0, 1311, 1314, 1, 0, 0, 0, 1312, 1310,
		1, 0, 0, 0, 1312, 1313, 1, 0, 0, 0, 1313, 1316, 1, 0, 0, 0, 1314, 1312,
		1, 0, 0, 0, 1315, 1317, 5, 131, 0, 0, 1316, 1315, 1, 0, 0, 0, 1316, 1317,
		1, 0, 0, 0, 1317, 211, 1, 0, 0, 0, 1318, 1319, 3, 214, 107, 0, 1319, 1320,
		5, 127, 0, 0, 1320, 1322, 1, 0, 0, 0, 1321, 1318, 1, 0, 0, 0, 1321, 1322,
		1, 0, 0, 0, 1322, 1323, 1, 0, 0, 0, 1323, 1325, 5, 132, 0, 0, 1324, 1326,
		3, 216, 108, 0, 1325, 1324, 1, 0, 0, 0, 1325, 1326, 1, 0, 0, 0, 1326, 213,
		1, 0, 0, 0, 1327, 1328, 5, 132, 0, 0, 1328, 215, 1, 0, 0, 0, 1329, 1331,
		5, 85, 0, 0, 1330, 1332, 3, 218, 109, 0, 1331, 1330, 1, 0, 0, 0, 1331,
		1332, 1, 0, 0, 0, 1332, 1333, 1, 0, 0, 0, 1333, 1334, 5, 86, 0, 0, 1334,
		217, 1, 0, 0, 0, 1335, 1337, 3, 220, 110, 0, 1336, 1335, 1, 0, 0, 0, 1337,
		1338, 1, 0, 0, 0, 1338, 1336, 1, 0, 0, 0, 1338, 1339, 1, 0, 0, 0, 1339,
		219, 1, 0, 0, 0, 1340, 1341, 5, 85, 0, 0, 1341, 1342, 3, 218, 109, 0, 1342,
		1343, 5, 86, 0, 0, 1343, 1358, 1, 0, 0, 0, 1344, 1345, 5, 87, 0, 0, 1345,
		1346, 3, 218, 109, 0, 1346, 1347, 5, 88, 0, 0, 1347, 1358, 1, 0, 0, 0,
		1348, 1349, 5, 89, 0, 0, 1349, 1350, 3, 218, 109, 0, 1350, 1351, 5, 90,
		0, 0, 1351, 1358, 1, 0, 0, 0, 1352, 1354, 8, 16, 0, 0, 1353, 1352, 1, 0,
		0, 0, 1354, 1355, 1, 0, 0, 0, 1355, 1353, 1, 0, 0, 0, 1355, 1356, 1, 0,
		0, 0, 1356, 1358, 1, 0, 0, 0, 1357, 1340, 1, 0, 0, 0, 1357, 1344, 1, 0,
		0, 0, 1357, 1348, 1, 0, 0, 0, 1357, 1353, 1, 0, 0, 0, 1358, 221, 1, 0,
		0, 0, 1359, 1364, 3, 224, 112, 0, 1360, 1361, 5, 122, 0, 0, 1361, 1363,
		3, 224, 112, 0, 1362, 1360, 1, 0, 0, 0, 1363, 1366, 1, 0, 0, 0, 1364, 1362,
		1, 0, 0, 0, 1364, 1365, 1, 0, 0, 0, 1365, 223, 1, 0, 0, 0, 1366, 1364,
		1, 0, 0, 0, 1367, 1369, 3, 226, 113, 0, 1368, 1370, 3, 268, 134, 0, 1369,
		1368, 1, 0, 0, 0, 1369, 1370, 1, 0, 0, 0, 1370, 225, 1, 0, 0, 0, 1371,
		1377, 3, 228, 114, 0, 1372, 1373, 3, 230, 115, 0, 1373, 1374, 3, 232, 116,
		0, 1374, 1375, 3, 234, 117, 0, 1375, 1377, 1, 0, 0, 0, 1376, 1371, 1, 0,
		0, 0, 1376, 1372, 1, 0, 0, 0, 1377, 227, 1, 0, 0, 0, 1378, 1380, 3, 236,
		118, 0, 1379, 1381, 5, 22, 0, 0, 1380, 1379, 1, 0, 0, 0, 1380, 1381, 1,
		0, 0, 0, 1381, 1383, 1, 0, 0, 0, 1382, 1378, 1, 0, 0, 0, 1383, 1386, 1,
		0, 0, 0, 1384, 1382, 1, 0, 0, 0, 1384, 1385, 1, 0, 0, 0, 1385, 1387, 1,
		0, 0, 0, 1386, 1384, 1, 0, 0, 0, 1387, 1388, 3, 230, 115, 0, 1388, 229,
		1, 0, 0, 0, 1389, 1390, 6, 115, -1, 0, 1390, 1392, 3, 244, 122, 0, 1391,
		1393, 3, 204, 102, 0, 1392, 1391, 1, 0, 0, 0, 1392, 1393, 1, 0, 0, 0, 1393,
		1399, 1, 0, 0, 0, 1394, 1395, 5, 85, 0, 0, 1395, 1396, 3, 228, 114, 0,
		1396, 1397, 5, 86, 0, 0, 1397, 1399, 1, 0, 0, 0, 1398, 1389, 1, 0, 0, 0,
		1398, 1394, 1, 0, 0, 0, 1399, 1414, 1, 0, 0, 0, 1400, 1410, 10, 2, 0, 0,
		1401, 1411, 3, 232, 116, 0, 1402, 1404, 5, 87, 0, 0, 1403, 1405, 3, 92,
		46, 0, 1404, 1403, 1, 0, 0, 0, 1404, 1405, 1, 0, 0, 0, 1405, 1406, 1, 0,
		0, 0, 1406, 1408, 5, 88, 0, 0, 1407, 1409, 3, 204, 102, 0, 1408, 1407,
		1, 0, 0, 0, 1408, 1409, 1, 0, 0, 0, 1409, 1411, 1, 0, 0, 0, 1410, 1401,
		1, 0, 0, 0, 1410, 1402, 1, 0, 0, 0, 1411, 1413, 1, 0, 0, 0, 1412, 1400,
		1, 0, 0, 0, 1413, 1416, 1, 0, 0, 0, 1414, 1412, 1, 0, 0, 0, 1414, 1415,
		1, 0, 0, 0, 1415, 231, 1, 0, 0, 0, 1416, 1414, 1, 0, 0, 0, 1417, 1419,
		5, 85, 0, 0, 1418, 1420, 3, 258, 129, 0, 1419, 1418, 1, 0, 0, 0, 1419,
		1420, 1, 0, 0, 0, 1420, 1421, 1, 0, 0, 0, 1421, 1423, 5, 86, 0, 0, 1422,
		1424, 3, 238, 119, 0, 1423, 1422, 1, 0, 0, 0, 1423, 1424, 1, 0, 0, 0, 1424,
		1426, 1, 0, 0, 0, 1425, 1427, 3, 242, 121, 0, 1426, 1425, 1, 0, 0, 0, 1426,
		1427, 1, 0, 0, 0, 1427, 1429, 1, 0, 0, 0, 1428, 1430, 3, 370, 185, 0, 1429,
		1428, 1, 0, 0, 0, 1429, 1430, 1, 0, 0, 0, 1430, 1432, 1, 0, 0, 0, 1431,
		1433, 3, 204, 102, 0, 1432, 1431, 1, 0, 0, 0, 1432, 1433, 1, 0, 0, 0, 1433,
		233, 1, 0, 0, 0, 1434, 1435, 5, 124, 0, 0, 1435, 1437, 3, 152, 76, 0, 1436,
		1438, 3, 248, 124, 0, 1437, 1436, 1, 0, 0, 0, 1437, 1438, 1, 0, 0, 0, 1438,
		235, 1, 0, 0, 0, 1439, 1441, 7, 17, 0, 0, 1440, 1442, 3, 204, 102, 0, 1441,
		1440, 1, 0, 0, 0, 1441, 1442, 1, 0, 0, 0, 1442, 1454, 1, 0, 0, 0, 1443,
		1445, 3, 10, 5, 0, 1444, 1443, 1, 0, 0, 0, 1444, 1445, 1, 0, 0, 0, 1445,
		1446, 1, 0, 0, 0, 1446, 1448, 5, 93, 0, 0, 1447, 1449, 3, 204, 102, 0,
		1448, 1447, 1, 0, 0, 0, 1448, 1449, 1, 0, 0, 0, 1449, 1451, 1, 0, 0, 0,
		1450, 1452, 3, 238, 119, 0, 1451, 1450, 1, 0, 0, 0, 1451, 1452, 1, 0, 0,
		0, 1452, 1454, 1, 0, 0, 0, 1453, 1439, 1, 0, 0, 0, 1453, 1444, 1, 0, 0,
		0, 1454, 237, 1, 0, 0, 0, 1455, 1457, 3, 240, 120, 0, 1456, 1455, 1, 0,
		0, 0, 1457, 1458, 1, 0, 0, 0, 1458, 1456, 1, 0, 0, 0, 1458, 1459, 1, 0,
		0, 0, 1459, 239, 1, 0, 0, 0, 1460, 1461, 7, 18, 0, 0, 1461, 241, 1, 0,
		0, 0, 1462, 1463, 7, 17, 0, 0, 1463, 243, 1, 0, 0, 0, 1464, 1466, 5, 131,
		0, 0, 1465, 1464, 1, 0, 0, 0, 1465, 1466, 1, 0, 0, 0, 1466, 1467, 1, 0,
		0, 0, 1467, 1468, 3, 4, 2, 0, 1468, 245, 1, 0, 0, 0, 1469, 1471, 3, 150,
		75, 0, 1470, 1472, 3, 248, 124, 0, 1471, 1470, 1, 0, 0, 0, 1471, 1472,
		1, 0, 0, 0, 1472, 247, 1, 0, 0, 0, 1473, 1482, 3, 250, 125, 0, 1474, 1476,
		3, 252, 126, 0, 1475, 1474, 1, 0, 0, 0, 1475, 1476, 1, 0, 0, 0, 1476, 1477,
		1, 0, 0, 0, 1477, 1478, 3, 232, 116, 0, 1478, 1479, 3, 234, 117, 0, 1479,
		1482, 1, 0, 0, 0, 1480, 1482, 3, 254, 127, 0, 1481, 1473, 1, 0, 0, 0, 1481,
		1475, 1, 0, 0, 0, 1481, 1480, 1, 0, 0, 0, 1482, 249, 1, 0, 0, 0, 1483,
		1493, 3, 252, 126, 0, 1484, 1486, 3, 236, 118, 0, 1485, 1484, 1, 0, 0,
		0, 1486, 1487, 1, 0, 0, 0, 1487, 1485, 1, 0, 0, 0, 1487, 1488, 1, 0, 0,
		0, 1488, 1490, 1, 0, 0, 0, 1489, 1491, 3, 252, 126, 0, 1490, 1489, 1, 0,
		0, 0, 1490, 1491, 1, 0, 0, 0, 1491, 1493, 1, 0, 0, 0, 1492, 1483, 1, 0,
		0, 0, 1492, 1485, 1, 0, 0, 0, 1493, 251, 1, 0, 0, 0, 1494, 1495, 6, 126,
		-1, 0, 1495, 1509, 3, 232, 116, 0, 1496, 1498, 5, 87, 0, 0, 1497, 1499,
		3, 92, 46, 0, 1498, 1497, 1, 0, 0, 0, 1498, 1499, 1, 0, 0, 0, 1499, 1500,
		1, 0, 0, 0, 1500, 1502, 5, 88, 0, 0, 1501, 1503, 3, 204, 102, 0, 1502,
		1501, 1, 0, 0, 0, 1502, 1503, 1, 0, 0, 0, 1503, 1509, 1, 0, 0, 0, 1504,
		1505, 5, 85, 0, 0, 1505, 1506, 3, 250, 125, 0, 1506, 1507, 5, 86, 0, 0,
		1507, 1509, 1, 0, 0, 0, 1508, 1494, 1, 0, 0, 0, 1508, 1496, 1, 0, 0, 0,
		1508, 1504, 1, 0, 0, 0, 1509, 1525, 1, 0, 0, 0, 1510, 1521, 10, 4, 0, 0,
		1511, 1522, 3, 232, 116, 0, 1512, 1513, 3, 252, 126, 0, 1513, 1515, 5,
		87, 0, 0, 1514, 1516, 3, 92, 46, 0, 1515, 1514, 1, 0, 0, 0, 1515, 1516,
		1, 0, 0, 0, 1516, 1517, 1, 0, 0, 0, 1517, 1519, 5, 88, 0, 0, 1518, 1520,
		3, 204, 102, 0, 1519, 1518, 1, 0, 0, 0, 1519, 1520, 1, 0, 0, 0, 1520, 1522,
		1, 0, 0, 0, 1521, 1511, 1, 0, 0, 0, 1521, 1512, 1, 0, 0, 0, 1522, 1524,
		1, 0, 0, 0, 1523, 1510, 1, 0, 0, 0, 1524, 1527, 1, 0, 0, 0, 1525, 1523,
		1, 0, 0, 0, 1525, 1526, 1, 0, 0, 0, 1526, 253, 1, 0, 0, 0, 1527, 1525,
		1, 0, 0, 0, 1528, 1530, 3, 236, 118, 0, 1529, 1528, 1, 0, 0, 0, 1530, 1533,
		1, 0, 0, 0, 1531, 1529, 1, 0, 0, 0, 1531, 1532, 1, 0, 0, 0, 1532, 1534,
		1, 0, 0, 0, 1533, 1531, 1, 0, 0, 0, 1534, 1535, 3, 256, 128, 0, 1535, 255,
		1, 0, 0, 0, 1536, 1537, 6, 128, -1, 0, 1537, 1538, 5, 131, 0, 0, 1538,
		1553, 1, 0, 0, 0, 1539, 1549, 10, 2, 0, 0, 1540, 1550, 3, 232, 116, 0,
		1541, 1543, 5, 87, 0, 0, 1542, 1544, 3, 92, 46, 0, 1543, 1542, 1, 0, 0,
		0, 1543, 1544, 1, 0, 0, 0, 1544, 1545, 1, 0, 0, 0, 1545, 1547, 5, 88, 0,
		0, 1546, 1548, 3, 204, 102, 0, 1547, 1546, 1, 0, 0, 0, 1547, 1548, 1, 0,
		0, 0, 1548, 1550, 1, 0, 0, 0, 1549, 1540, 1, 0, 0, 0, 1549, 1541, 1, 0,
		0, 0, 1550, 1552, 1, 0, 0, 0, 1551, 1539, 1, 0, 0, 0, 1552, 1555, 1, 0,
		0, 0, 1553, 1551, 1, 0, 0, 0, 1553, 1554, 1, 0, 0, 0, 1554, 257, 1, 0,
		0, 0, 1555, 1553, 1, 0, 0, 0, 1556, 1561, 3, 260, 130, 0, 1557, 1559, 5,
		122, 0, 0, 1558, 1557, 1, 0, 0, 0, 1558, 1559, 1, 0, 0, 0, 1559, 1560,
		1, 0, 0, 0, 1560, 1562, 5, 131, 0, 0, 1561, 1558, 1, 0, 0, 0, 1561, 1562,
		1, 0, 0, 0, 1562, 259, 1, 0, 0, 0, 1563, 1568, 3, 262, 131, 0, 1564, 1565,
		5, 122, 0, 0, 1565, 1567, 3, 262, 131, 0, 1566, 1564, 1, 0, 0, 0, 1567,
		1570, 1, 0, 0, 0, 1568, 1566, 1, 0, 0, 0, 1568, 1569, 1, 0, 0, 0, 1569,
		261, 1, 0, 0, 0, 1570, 1568, 1, 0, 0, 0, 1571, 1573, 3, 204, 102, 0, 1572,
		1571, 1, 0, 0, 0, 1572, 1573, 1, 0, 0, 0, 1573, 1574, 1, 0, 0, 0, 1574,
		1579, 3, 138, 69, 0, 1575, 1580, 3, 226, 113, 0, 1576, 1578, 3, 248, 124,
		0, 1577, 1576, 1, 0, 0, 0, 1577, 1578, 1, 0, 0, 0, 1578, 1580, 1, 0, 0,
		0, 1579, 1575, 1, 0, 0, 0, 1579, 1577, 1, 0, 0, 0, 1580, 1583, 1, 0, 0,
		0, 1581, 1582, 5, 101, 0, 0, 1582, 1584, 3, 272, 136, 0, 1583, 1581, 1,
		0, 0, 0, 1583, 1584, 1, 0, 0, 0, 1584, 263, 1, 0, 0, 0, 1585, 1587, 3,
		204, 102, 0, 1586, 1585, 1, 0, 0, 0, 1586, 1587, 1, 0, 0, 0, 1587, 1589,
		1, 0, 0, 0, 1588, 1590, 3, 138, 69, 0, 1589, 1588, 1, 0, 0, 0, 1589, 1590,
		1, 0, 0, 0, 1590, 1591, 1, 0, 0, 0, 1591, 1593, 3, 226, 113, 0, 1592, 1594,
		3, 298, 149, 0, 1593, 1592, 1, 0, 0, 0, 1593, 1594, 1, 0, 0, 0, 1594, 1595,
		1, 0, 0, 0, 1595, 1596, 3, 266, 133, 0, 1596, 265, 1, 0, 0, 0, 1597, 1599,
		3, 322, 161, 0, 1598, 1597, 1, 0, 0, 0, 1598, 1599, 1, 0, 0, 0, 1599, 1600,
		1, 0, 0, 0, 1600, 1606, 3, 100, 50, 0, 1601, 1606, 3, 360, 180, 0, 1602,
		1603, 5, 101, 0, 0, 1603, 1604, 7, 19, 0, 0, 1604, 1606, 5, 128, 0, 0,
		1605, 1598, 1, 0, 0, 0, 1605, 1601, 1, 0, 0, 0, 1605, 1602, 1, 0, 0, 0,
		1606, 267, 1, 0, 0, 0, 1607, 1613, 3, 270, 135, 0, 1608, 1609, 5, 85, 0,
		0, 1609, 1610, 3, 34, 17, 0, 1610, 1611, 5, 86, 0, 0, 1611, 1613, 1, 0,
		0, 0, 1612, 1607, 1, 0, 0, 0, 1612, 1608, 1, 0, 0, 0, 1613, 269, 1, 0,
		0, 0, 1614, 1615, 5, 101, 0, 0, 1615, 1618, 3, 272, 136, 0, 1616, 1618,
		3, 276, 138, 0, 1617, 1614, 1, 0, 0, 0, 1617, 1616, 1, 0, 0, 0, 1618, 271,
		1, 0, 0, 0, 1619, 1622, 3, 86, 43, 0, 1620, 1622, 3, 276, 138, 0, 1621,
		1619, 1, 0, 0, 0, 1621, 1620, 1, 0, 0, 0, 1622, 273, 1, 0, 0, 0, 1623,
		1625, 3, 272, 136, 0, 1624, 1626, 5, 131, 0, 0, 1625, 1624, 1, 0, 0, 0,
		1625, 1626, 1, 0, 0, 0, 1626, 1634, 1, 0, 0, 0, 1627, 1628, 5, 122, 0,
		0, 1628, 1630, 3, 272, 136, 0, 1629, 1631, 5, 131, 0, 0, 1630, 1629, 1,
		0, 0, 0, 1630, 1631, 1, 0, 0, 0, 1631, 1633, 1, 0, 0, 0, 1632, 1627, 1,
		0, 0, 0, 1633, 1636, 1, 0, 0, 0, 1634, 1632, 1, 0, 0, 0, 1634, 1635, 1,
		0, 0, 0, 1635, 275, 1, 0, 0, 0, 1636, 1634, 1, 0, 0, 0, 1637, 1642, 5,
		89, 0, 0, 1638, 1640, 3, 274, 137, 0, 1639, 1641, 5, 122, 0, 0, 1640, 1639,
		1, 0, 0, 0, 1640, 1641, 1, 0, 0, 0, 1641, 1643, 1, 0, 0, 0, 1642, 1638,
		1, 0, 0, 0, 1642, 1643, 1, 0, 0, 0, 1643, 1644, 1, 0, 0, 0, 1644, 1645,
		5, 90, 0, 0, 1645, 277, 1, 0, 0, 0, 1646, 1649, 5, 132, 0, 0, 1647, 1649,
		3, 342, 171, 0, 1648, 1646, 1, 0, 0, 0, 1648, 1647, 1, 0, 0, 0, 1649, 279,
		1, 0, 0, 0, 1650, 1651, 3, 282, 141, 0, 1651, 1653, 5, 89, 0, 0, 1652,
		1654, 3, 290, 145, 0, 1653, 1652, 1, 0, 0, 0, 1653, 1654, 1, 0, 0, 0, 1654,
		1655, 1, 0, 0, 0, 1655, 1656, 5, 90, 0, 0, 1656, 281, 1, 0, 0, 0, 1657,
		1659, 3, 288, 144, 0, 1658, 1660, 3, 204, 102, 0, 1659, 1658, 1, 0, 0,
		0, 1659, 1660, 1, 0, 0, 0, 1660, 1665, 1, 0, 0, 0, 1661, 1663, 3, 284,
		142, 0, 1662, 1664, 3, 286, 143, 0, 1663, 1662, 1, 0, 0, 0, 1663, 1664,
		1, 0, 0, 0, 1664, 1666, 1, 0, 0, 0, 1665, 1661, 1, 0, 0, 0, 1665, 1666,
		1, 0, 0, 0, 1666, 1668, 1, 0, 0, 0, 1667, 1669, 3, 304, 152, 0, 1668, 1667,
		1, 0, 0, 0, 1668, 1669, 1, 0, 0, 0, 1669, 1681, 1, 0, 0, 0, 1670, 1672,
		5, 77, 0, 0, 1671, 1673, 3, 204, 102, 0, 1672, 1671, 1, 0, 0, 0, 1672,
		1673, 1, 0, 0, 0, 1673, 1678, 1, 0, 0, 0, 1674, 1676, 3, 284, 142, 0, 1675,
		1677, 3, 286, 143, 0, 1676, 1675, 1, 0, 0, 0, 1676, 1677, 1, 0, 0, 0, 1677,
		1679, 1, 0, 0, 0, 1678, 1674, 1, 0, 0, 0, 1678, 1679, 1, 0, 0, 0, 1679,
		1681, 1, 0, 0, 0, 1680, 1657, 1, 0, 0, 0, 1680, 1670, 1, 0, 0, 0, 1681,
		283, 1, 0, 0, 0, 1682, 1684, 3, 10, 5, 0, 1683, 1682, 1, 0, 0, 0, 1683,
		1684, 1, 0, 0, 0, 1684, 1685, 1, 0, 0, 0, 1685, 1686, 3, 278, 139, 0, 1686,
		285, 1, 0, 0, 0, 1687, 1688, 5, 38, 0, 0, 1688, 287, 1, 0, 0, 0, 1689,
		1690, 7, 15, 0, 0, 1690, 289, 1, 0, 0, 0, 1691, 1696, 3, 292, 146, 0, 1692,
		1693, 3, 314, 157, 0, 1693, 1694, 5, 126, 0, 0, 1694, 1696, 1, 0, 0, 0,
		1695, 1691, 1, 0, 0, 0, 1695, 1692, 1, 0, 0, 0, 1696, 1697, 1, 0, 0, 0,
		1697, 1695, 1, 0, 0, 0, 1697, 1698, 1, 0, 0, 0, 1698, 291, 1, 0, 0, 0,
		1699, 1701, 3, 204, 102, 0, 1700, 1699, 1, 0, 0, 0, 1700, 1701, 1, 0, 0,
		0, 1701, 1703, 1, 0, 0, 0, 1702, 1704, 3, 138, 69, 0, 1703, 1702, 1, 0,
		0, 0, 1703, 1704, 1, 0, 0, 0, 1704, 1706, 1, 0, 0, 0, 1705, 1707, 3, 294,
		147, 0, 1706, 1705, 1, 0, 0, 0, 1706, 1707, 1, 0, 0, 0, 1707, 1708, 1,
		0, 0, 0, 1708, 1716, 5, 128, 0, 0, 1709, 1716, 3, 264, 132, 0, 1710, 1716,
		3, 196, 98, 0, 1711, 1716, 3, 130, 65, 0, 1712, 1716, 3, 334, 167, 0, 1713,
		1716, 3, 126, 63, 0, 1714, 1716, 3, 132, 66, 0, 1715, 1700, 1, 0, 0, 0,
		1715, 1709, 1, 0, 0, 0, 1715, 1710, 1, 0, 0, 0, 1715, 1711, 1, 0, 0, 0,
		1715, 1712, 1, 0, 0, 0, 1715, 1713, 1, 0, 0, 0, 1715, 1714, 1, 0, 0, 0,
		1716, 293, 1, 0, 0, 0, 1717, 1722, 3, 296, 148, 0, 1718, 1719, 5, 122,
		0, 0, 1719, 1721, 3, 296, 148, 0, 1720, 1718, 1, 0, 0, 0, 1721, 1724, 1,
		0, 0, 0, 1722, 1720, 1, 0, 0, 0, 1722, 1723, 1, 0, 0, 0, 1723, 295, 1,
		0, 0, 0, 1724, 1722, 1, 0, 0, 0, 1725, 1734, 3, 226, 113, 0, 1726, 1735,
		3, 298, 149, 0, 1727, 1728, 4, 148, 9, 0, 1728, 1735, 3, 302, 151, 0, 1729,
		1730, 4, 148, 10, 0, 1730, 1731, 3, 298, 149, 0, 1731, 1732, 3, 302, 151,
		0, 1732, 1735, 1, 0, 0, 0, 1733, 1735, 3, 270, 135, 0, 1734, 1726, 1, 0,
		0, 0, 1734, 1727, 1, 0, 0, 0, 1734, 1729, 1, 0, 0, 0, 1734, 1733, 1, 0,
		0, 0, 1735, 1746, 1, 0, 0, 0, 1736, 1746, 3, 226, 113, 0, 1737, 1739, 5,
		132, 0, 0, 1738, 1737, 1, 0, 0, 0, 1738, 1739, 1, 0, 0, 0, 1739, 1741,
		1, 0, 0, 0, 1740, 1742, 3, 204, 102, 0, 1741, 1740, 1, 0, 0, 0, 1741, 1742,
		1, 0, 0, 0, 1742, 1743, 1, 0, 0, 0, 1743, 1744, 5, 126, 0, 0, 1744, 1746,
		3, 92, 46, 0, 1745, 1725, 1, 0, 0, 0, 1745, 1736, 1, 0, 0, 0, 1745, 1738,
		1, 0, 0, 0, 1746, 297, 1, 0, 0, 0, 1747, 1749, 3, 300, 150, 0, 1748, 1747,
		1, 0, 0, 0, 1749, 1750, 1, 0, 0, 0, 1750, 1748, 1, 0, 0, 0, 1750, 1751,
		1, 0, 0, 0, 1751, 299, 1, 0, 0, 0, 1752, 1753, 7, 20, 0, 0, 1753, 301,
		1, 0, 0, 0, 1754, 1755, 5, 101, 0, 0, 1755, 1756, 5, 1, 0, 0, 1756, 303,
		1, 0, 0, 0, 1757, 1758, 5, 126, 0, 0, 1758, 1759, 3, 306, 153, 0, 1759,
		305, 1, 0, 0, 0, 1760, 1762, 3, 308, 154, 0, 1761, 1763, 5, 131, 0, 0,
		1762, 1761, 1, 0, 0, 0, 1762, 1763, 1, 0, 0, 0, 1763, 1771, 1, 0, 0, 0,
		1764, 1765, 5, 122, 0, 0, 1765, 1767, 3, 308, 154, 0, 1766, 1768, 5, 131,
		0, 0, 1767, 1766, 1, 0, 0, 0, 1767, 1768, 1, 0, 0, 0, 1768, 1770, 1, 0,
		0, 0, 1769, 1764, 1, 0, 0, 0, 1770, 1773, 1, 0, 0, 0, 1771, 1769, 1, 0,
		0, 0, 1771, 1772, 1, 0, 0, 0, 1772, 307, 1, 0, 0, 0, 1773, 1771, 1, 0,
		0, 0, 1774, 1776, 3, 204, 102, 0, 1775, 1774, 1, 0, 0, 0, 1775, 1776, 1,
		0, 0, 0, 1776, 1789, 1, 0, 0, 0, 1777, 1790, 3, 312, 156, 0, 1778, 1780,
		5, 80, 0, 0, 1779, 1781, 3, 314, 157, 0, 1780, 1779, 1, 0, 0, 0, 1780,
		1781, 1, 0, 0, 0, 1781, 1782, 1, 0, 0, 0, 1782, 1790, 3, 312, 156, 0, 1783,
		1785, 3, 314, 157, 0, 1784, 1786, 5, 80, 0, 0, 1785, 1784, 1, 0, 0, 0,
		1785, 1786, 1, 0, 0, 0, 1786, 1787, 1, 0, 0, 0, 1787, 1788, 3, 312, 156,
		0, 1788, 1790, 1, 0, 0, 0, 1789, 1777, 1, 0, 0, 0, 1789, 1778, 1, 0, 0,
		0, 1789, 1783, 1, 0, 0, 0, 1790, 309, 1, 0, 0, 0, 1791, 1793, 3, 10, 5,
		0, 1792, 1791, 1, 0, 0, 0, 1792, 1793, 1, 0, 0, 0, 1793, 1794, 1, 0, 0,
		0, 1794, 1797, 3, 278, 139, 0, 1795, 1797, 3, 162, 81, 0, 1796, 1792, 1,
		0, 0, 0, 1796, 1795, 1, 0, 0, 0, 1797, 311, 1, 0, 0, 0, 1798, 1799, 3,
		310, 155, 0, 1799, 313, 1, 0, 0, 0, 1800, 1801, 7, 21, 0, 0, 1801, 315,
		1, 0, 0, 0, 1802, 1803, 5, 52, 0, 0, 1803, 1804, 3, 318, 159, 0, 1804,
		317, 1, 0, 0, 0, 1805, 1807, 3, 150, 75, 0, 1806, 1808, 3, 320, 160, 0,
		1807, 1806, 1, 0, 0, 0, 1807, 1808, 1, 0, 0, 0, 1808, 319, 1, 0, 0, 0,
		1809, 1811, 3, 236, 118, 0, 1810, 1812, 3, 320, 160, 0, 1811, 1810, 1,
		0, 0, 0, 1811, 1812, 1, 0, 0, 0, 1812, 321, 1, 0, 0, 0, 1813, 1814, 5,
		126, 0, 0, 1814, 1815, 3, 324, 162, 0, 1815, 323, 1, 0, 0, 0, 1816, 1818,
		3, 326, 163, 0, 1817, 1819, 5, 131, 0, 0, 1818, 1817, 1, 0, 0, 0, 1818,
		1819, 1, 0, 0, 0, 1819, 1827, 1, 0, 0, 0, 1820, 1821, 5, 122, 0, 0, 1821,
		1823, 3, 326, 163, 0, 1822, 1824, 5, 131, 0, 0, 1823, 1822, 1, 0, 0, 0,
		1823, 1824, 1, 0, 0, 0, 1824, 1826, 1, 0, 0, 0, 1825, 1820, 1, 0, 0, 0,
		1826, 1829, 1, 0, 0, 0, 1827, 1825, 1, 0, 0, 0, 1827, 1828, 1, 0, 0, 0,
		1828, 325, 1, 0, 0, 0, 1829, 1827, 1, 0, 0, 0, 1830, 1837, 3, 328, 164,
		0, 1831, 1833, 5, 85, 0, 0, 1832, 1834, 3, 34, 17, 0, 1833, 1832, 1, 0,
		0, 0, 1833, 1834, 1, 0, 0, 0, 1834, 1835, 1, 0, 0, 0, 1835, 1838, 5, 86,
		0, 0, 1836, 1838, 3, 276, 138, 0, 1837, 1831, 1, 0, 0, 0, 1837, 1836, 1,
		0, 0, 0, 1838, 327, 1, 0, 0, 0, 1839, 1842, 3, 310, 155, 0, 1840, 1842,
		5, 132, 0, 0, 1841, 1839, 1, 0, 0, 0, 1841, 1840, 1, 0, 0, 0, 1842, 329,
		1, 0, 0, 0, 1843, 1844, 5, 52, 0, 0, 1844, 1845, 3, 378, 189, 0, 1845,
		331, 1, 0, 0, 0, 1846, 1850, 5, 52, 0, 0, 1847, 1848, 5, 4, 0, 0, 1848,
		1851, 5, 132, 0, 0, 1849, 1851, 5, 140, 0, 0, 1850, 1847, 1, 0, 0, 0, 1850,
		1849, 1, 0, 0, 0, 1851, 333, 1, 0, 0, 0, 1852, 1853, 5, 68, 0, 0, 1853,
		1854, 5, 102, 0, 0, 1854, 1855, 3, 336, 168, 0, 1855, 1856, 5, 103, 0,
		0, 1856, 1857, 3, 122, 61, 0, 1857, 335, 1, 0, 0, 0, 1858, 1863, 3, 338,
		169, 0, 1859, 1860, 5, 122, 0, 0, 1860, 1862, 3, 338, 169, 0, 1861, 1859,
		1, 0, 0, 0, 1862, 1865, 1, 0, 0, 0, 1863, 1861, 1, 0, 0, 0, 1863, 1864,
		1, 0, 0, 0, 1864, 337, 1, 0, 0, 0, 1865, 1863, 1, 0, 0, 0, 1866, 1869,
		3, 340, 170, 0, 1867, 1869, 3, 262, 131, 0, 1868, 1866, 1, 0, 0, 0, 1868,
		1867, 1, 0, 0, 0, 1869, 339, 1, 0, 0, 0, 1870, 1871, 5, 68, 0, 0, 1871,
		1872, 5, 102, 0, 0, 1872, 1873, 3, 336, 168, 0, 1873, 1874, 5, 103, 0,
		0, 1874, 1876, 1, 0, 0, 0, 1875, 1870, 1, 0, 0, 0, 1875, 1876, 1, 0, 0,
		0, 1876, 1877, 1, 0, 0, 0, 1877, 1880, 5, 21, 0, 0, 1878, 1880, 5, 76,
		0, 0, 1879, 1875, 1, 0, 0, 0, 1879, 1878, 1, 0, 0, 0, 1880, 1892, 1, 0,
		0, 0, 1881, 1883, 5, 131, 0, 0, 1882, 1881, 1, 0, 0, 0, 1882, 1883, 1,
		0, 0, 0, 1883, 1885, 1, 0, 0, 0, 1884, 1886, 5, 132, 0, 0, 1885, 1884,
		1, 0, 0, 0, 1885, 1886, 1, 0, 0, 0, 1886, 1893, 1, 0, 0, 0, 1887, 1889,
		5, 132, 0, 0, 1888, 1887, 1, 0, 0, 0, 1888, 1889, 1, 0, 0, 0, 1889, 1890,
		1, 0, 0, 0, 1890, 1891, 5, 101, 0, 0, 1891, 1893, 3, 246, 123, 0, 1892,
		1882, 1, 0, 0, 0, 1892, 1888, 1, 0, 0, 0, 1893, 341, 1, 0, 0, 0, 1894,
		1895, 3, 346, 173, 0, 1895, 1897, 5, 102, 0, 0, 1896, 1898, 3, 348, 174,
		0, 1897, 1896, 1, 0, 0, 0, 1897, 1898, 1, 0, 0, 0, 1898, 1899, 1, 0, 0,
		0, 1899, 1900, 5, 103, 0, 0, 1900, 343, 1, 0, 0, 0, 1901, 1913, 3, 342,
		171, 0, 1902, 1905, 3, 330, 165, 0, 1903, 1905, 3, 332, 166, 0, 1904, 1902,
		1, 0, 0, 0, 1904, 1903, 1, 0, 0, 0, 1905, 1906, 1, 0, 0, 0, 1906, 1908,
		5, 102, 0, 0, 1907, 1909, 3, 348, 174, 0, 1908, 1907, 1, 0, 0, 0, 1908,
		1909, 1, 0, 0, 0, 1909, 1910, 1, 0, 0, 0, 1910, 1911, 5, 103, 0, 0, 1911,
		1913, 1, 0, 0, 0, 1912, 1901, 1, 0, 0, 0, 1912, 1904, 1, 0, 0, 0, 1913,
		345, 1, 0, 0, 0, 1914, 1915, 5, 132, 0, 0, 1915, 347, 1, 0, 0, 0, 1916,
		1918, 3, 350, 175, 0, 1917, 1919, 5, 131, 0, 0, 1918, 1917, 1, 0, 0, 0,
		1918, 1919, 1, 0, 0, 0, 1919, 1927, 1, 0, 0, 0, 1920, 1921, 5, 122, 0,
		0, 1921, 1923, 3, 350, 175, 0, 1922, 1924, 5, 131, 0, 0, 1923, 1922, 1,
		0, 0, 0, 1923, 1924, 1, 0, 0, 0, 1924, 1926, 1, 0, 0, 0, 1925, 1920, 1,
		0, 0, 0, 1926, 1929, 1, 0, 0, 0, 1927, 1925, 1, 0, 0, 0, 1927, 1928, 1,
		0, 0, 0, 1928, 349, 1, 0, 0, 0, 1929, 1927, 1, 0, 0, 0, 1930, 1934, 3,
		246, 123, 0, 1931, 1934, 3, 92, 46, 0, 1932, 1934, 3, 4, 2, 0, 1933, 1930,
		1, 0, 0, 0, 1933, 1931, 1, 0, 0, 0, 1933, 1932, 1, 0, 0, 0, 1934, 351,
		1, 0, 0, 0, 1935, 1936, 5, 76, 0, 0, 1936, 1942, 3, 10, 5, 0, 1937, 1943,
		5, 132, 0, 0, 1938, 1940, 5, 68, 0, 0, 1939, 1938, 1, 0, 0, 0, 1939, 1940,
		1, 0, 0, 0, 1940, 1941, 1, 0, 0, 0, 1941, 1943, 3, 342, 171, 0, 1942, 1937,
		1, 0, 0, 0, 1942, 1939, 1, 0, 0, 0, 1943, 353, 1, 0, 0, 0, 1944, 1946,
		5, 36, 0, 0, 1945, 1944, 1, 0, 0, 0, 1945, 1946, 1, 0, 0, 0, 1946, 1947,
		1, 0, 0, 0, 1947, 1948, 5, 68, 0, 0, 1948, 1949, 3, 122, 61, 0, 1949, 355,
		1, 0, 0, 0, 1950, 1951, 5, 68, 0, 0, 1951, 1952, 5, 102, 0, 0, 1952, 1953,
		5, 103, 0, 0, 1953, 1954, 3, 122, 61, 0, 1954, 357, 1, 0, 0, 0, 1955, 1956,
		5, 73, 0, 0, 1956, 1957, 3, 100, 50, 0, 1957, 1958, 3, 362, 181, 0, 1958,
		359, 1, 0, 0, 0, 1959, 1961, 5, 73, 0, 0, 1960, 1962, 3, 322, 161, 0, 1961,
		1960, 1, 0, 0, 0, 1961, 1962, 1, 0, 0, 0, 1962, 1963, 1, 0, 0, 0, 1963,
		1964, 3, 100, 50, 0, 1964, 1965, 3, 362, 181, 0, 1965, 361, 1, 0, 0, 0,
		1966, 1968, 3, 364, 182, 0, 1967, 1966, 1, 0, 0, 0, 1968, 1969, 1, 0, 0,
		0, 1969, 1967, 1, 0, 0, 0, 1969, 1970, 1, 0, 0, 0, 1970, 363, 1, 0, 0,
		0, 1971, 1972, 5, 17, 0, 0, 1972, 1973, 5, 85, 0, 0, 1973, 1974, 3, 366,
		183, 0, 1974, 1975, 5, 86, 0, 0, 1975, 1976, 3, 100, 50, 0, 1976, 365,
		1, 0, 0, 0, 1977, 1979, 3, 204, 102, 0, 1978, 1977, 1, 0, 0, 0, 1978, 1979,
		1, 0, 0, 0, 1979, 1980, 1, 0, 0, 0, 1980, 1983, 3, 150, 75, 0, 1981, 1984,
		3, 226, 113, 0, 1982, 1984, 3, 248, 124, 0, 1983, 1981, 1, 0, 0, 0, 1983,
		1982, 1, 0, 0, 0, 1983, 1984, 1, 0, 0, 0, 1984, 1987, 1, 0, 0, 0, 1985,
		1987, 5, 131, 0, 0, 1986, 1978, 1, 0, 0, 0, 1986, 1985, 1, 0, 0, 0, 1987,
		367, 1, 0, 0, 0, 1988, 1990, 5, 71, 0, 0, 1989, 1991, 3, 86, 43, 0, 1990,
		1989, 1, 0, 0, 0, 1990, 1991, 1, 0, 0, 0, 1991, 369, 1, 0, 0, 0, 1992,
		1995, 3, 372, 186, 0, 1993, 1995, 3, 376, 188, 0, 1994, 1992, 1, 0, 0,
		0, 1994, 1993, 1, 0, 0, 0, 1995, 371, 1, 0, 0, 0, 1996, 1997, 5, 71, 0,
		0, 1997, 1999, 5, 85, 0, 0, 1998, 2000, 3, 374, 187, 0, 1999, 1998, 1,
		0, 0, 0, 1999, 2000, 1, 0, 0, 0, 2000, 2001, 1, 0, 0, 0, 2001, 2002, 5,
		86, 0, 0, 2002, 373, 1, 0, 0, 0, 2003, 2005, 3, 246, 123, 0, 2004, 2006,
		5, 131, 0, 0, 2005, 2004, 1, 0, 0, 0, 2005, 2006, 1, 0, 0, 0, 2006, 2014,
		1, 0, 0, 0, 2007, 2008, 5, 122, 0, 0, 2008, 2010, 3, 246, 123, 0, 2009,
		2011, 5, 131, 0, 0, 2010, 2009, 1, 0, 0, 0, 2010, 2011, 1, 0, 0, 0, 2011,
		2013, 1, 0, 0, 0, 2012, 2007, 1, 0, 0, 0, 2013, 2016, 1, 0, 0, 0, 2014,
		2012, 1, 0, 0, 0, 2014, 2015, 1, 0, 0, 0, 2015, 375, 1, 0, 0, 0, 2016,
		2014, 1, 0, 0, 0, 2017, 2018, 5, 50, 0, 0, 2018, 2019, 5, 85, 0, 0, 2019,
		2020, 3, 92, 46, 0, 2020, 2021, 5, 86, 0, 0, 2021, 2024, 1, 0, 0, 0, 2022,
		2024, 5, 50, 0, 0, 2023, 2017, 1, 0, 0, 0, 2023, 2022, 1, 0, 0, 0, 2024,
		377, 1, 0, 0, 0, 2025, 2028, 5, 49, 0, 0, 2026, 2027, 5, 87, 0, 0, 2027,
		2029, 5, 88, 0, 0, 2028, 2026, 1, 0, 0, 0, 2028, 2029, 1, 0, 0, 0, 2029,
		2077, 1, 0, 0, 0, 2030, 2033, 5, 28, 0, 0, 2031, 2032, 5, 87, 0, 0, 2032,
		2034, 5, 88, 0, 0, 2033, 2031, 1, 0, 0, 0, 2033, 2034, 1, 0, 0, 0, 2034,
		2077, 1, 0, 0, 0, 2035, 2077, 5, 91, 0, 0, 2036, 2077, 5, 92, 0, 0, 2037,
		2077, 5, 93, 0, 0, 2038, 2077, 5, 94, 0, 0, 2039, 2077, 5, 95, 0, 0, 2040,
		2077, 5, 96, 0, 0, 2041, 2077, 5, 97, 0, 0, 2042, 2077, 5, 98, 0, 0, 2043,
		2077, 5, 99, 0, 0, 2044, 2077, 5, 100, 0, 0, 2045, 2077, 5, 101, 0, 0,
		2046, 2077, 5, 103, 0, 0, 2047, 2077, 5, 102, 0, 0, 2048, 2077, 5, 117,
		0, 0, 2049, 2077, 5, 104, 0, 0, 2050, 2077, 5, 105, 0, 0, 2051, 2077, 5,
		106, 0, 0, 2052, 2077, 5, 108, 0, 0, 2053, 2077, 5, 109, 0, 0, 2054, 2077,
		5, 110, 0, 0, 2055, 2077, 5, 111, 0, 0, 2056, 2057, 5, 102, 0, 0, 2057,
		2077, 5, 102, 0, 0, 2058, 2059, 5, 103, 0, 0, 2059, 2077, 5, 103, 0, 0,
		2060, 2077, 5, 113, 0, 0, 2061, 2077, 5, 112, 0, 0, 2062, 2077, 5, 114,
		0, 0, 2063, 2077, 5, 115, 0, 0, 2064, 2077, 5, 116, 0, 0, 2065, 2077, 5,
		118, 0, 0, 2066, 2077, 5, 119, 0, 0, 2067, 2077, 5, 120, 0, 0, 2068, 2077,
		5, 121, 0, 0, 2069, 2077, 5, 122, 0, 0, 2070, 2077, 5, 123, 0, 0, 2071,
		2077, 5, 124, 0, 0, 2072, 2073, 5, 85, 0, 0, 2073, 2077, 5, 86, 0, 0, 2074,
		2075, 5, 87, 0, 0, 2075, 2077, 5, 88, 0, 0, 2076, 2025, 1, 0, 0, 0, 2076,
		2030, 1, 0, 0, 0, 2076, 2035, 1, 0, 0, 0, 2076, 2036, 1, 0, 0, 0, 2076,
		2037, 1, 0, 0, 0, 2076, 2038, 1, 0, 0, 0, 2076, 2039, 1, 0, 0, 0, 2076,
		2040, 1, 0, 0, 0, 2076, 2041, 1, 0, 0, 0, 2076, 2042, 1, 0, 0, 0, 2076,
		2043, 1, 0, 0, 0, 2076, 2044, 1, 0, 0, 0, 2076, 2045, 1, 0, 0, 0, 2076,
		2046, 1, 0, 0, 0, 2076, 2047, 1, 0, 0, 0, 2076, 2048, 1, 0, 0, 0, 2076,
		2049, 1, 0, 0, 0, 2076, 2050, 1, 0, 0, 0, 2076, 2051, 1, 0, 0, 0, 2076,
		2052, 1, 0, 0, 0, 2076, 2053, 1, 0, 0, 0, 2076, 2054, 1, 0, 0, 0, 2076,
		2055, 1, 0, 0, 0, 2076, 2056, 1, 0, 0, 0, 2076, 2058, 1, 0, 0, 0, 2076,
		2060, 1, 0, 0, 0, 2076, 2061, 1, 0, 0, 0, 2076, 2062, 1, 0, 0, 0, 2076,
		2063, 1, 0, 0, 0, 2076, 2064, 1, 0, 0, 0, 2076, 2065, 1, 0, 0, 0, 2076,
		2066, 1, 0, 0, 0, 2076, 2067, 1, 0, 0, 0, 2076, 2068, 1, 0, 0, 0, 2076,
		2069, 1, 0, 0, 0, 2076, 2070, 1, 0, 0, 0, 2076, 2071, 1, 0, 0, 0, 2076,
		2072, 1, 0, 0, 0, 2076, 2074, 1, 0, 0, 0, 2077, 379, 1, 0, 0, 0, 2078,
		2079, 7, 22, 0, 0, 2079, 381, 1, 0, 0, 0, 294, 383, 390, 399, 403, 412,
		415, 419, 427, 434, 437, 442, 447, 453, 461, 463, 472, 476, 480, 483, 487,
		490, 497, 501, 504, 507, 510, 516, 520, 524, 538, 542, 548, 555, 561, 565,
		569, 571, 579, 584, 597, 604, 616, 626, 631, 635, 642, 645, 653, 657, 660,
		667, 674, 678, 683, 687, 690, 695, 710, 717, 725, 733, 742, 749, 756, 764,
		772, 780, 788, 796, 804, 813, 821, 830, 838, 846, 848, 851, 857, 863, 869,
		876, 885, 893, 897, 904, 906, 926, 930, 936, 941, 945, 948, 955, 962, 966,
		975, 986, 996, 1001, 1008, 1011, 1016, 1021, 1042, 1047, 1050, 1061, 1067,
		1072, 1075, 1080, 1083, 1090, 1113, 1119, 1125, 1131, 1134, 1140, 1144,
		1148, 1151, 1159, 1161, 1167, 1170, 1173, 1176, 1180, 1184, 1190, 1200,
		1206, 1212, 1217, 1222, 1226, 1239, 1245, 1249, 1255, 1260, 1275, 1279,
		1284, 1289, 1294, 1300, 1303, 1312, 1316, 1321, 1325, 1331, 1338, 1355,
		1357, 1364, 1369, 1376, 1380, 1384, 1392, 1398, 1404, 1408, 1410, 1414,
		1419, 1423, 1426, 1429, 1432, 1437, 1441, 1444, 1448, 1451, 1453, 1458,
		1465, 1471, 1475, 1481, 1487, 1490, 1492, 1498, 1502, 1508, 1515, 1519,
		1521, 1525, 1531, 1543, 1547, 1549, 1553, 1558, 1561, 1568, 1572, 1577,
		1579, 1583, 1586, 1589, 1593, 1598, 1605, 1612, 1617, 1621, 1625, 1630,
		1634, 1640, 1642, 1648, 1653, 1659, 1663, 1665, 1668, 1672, 1676, 1678,
		1680, 1683, 1695, 1697, 1700, 1703, 1706, 1715, 1722, 1734, 1738, 1741,
		1745, 1750, 1762, 1767, 1771, 1775, 1780, 1785, 1789, 1792, 1796, 1807,
		1811, 1818, 1823, 1827, 1833, 1837, 1841, 1850, 1863, 1868, 1875, 1879,
		1882, 1885, 1888, 1892, 1897, 1904, 1908, 1912, 1918, 1923, 1927, 1933,
		1939, 1942, 1945, 1961, 1969, 1978, 1983, 1986, 1990, 1994, 1999, 2005,
		2010, 2014, 2023, 2028, 2033, 2076,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// CPP14ParserInit initializes any static state used to implement CPP14Parser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewCPP14Parser(). You can call this function if you wish to initialize the static state ahead
// of time.
func CPP14ParserInit() {
	staticData := &CPP14ParserParserStaticData
	staticData.once.Do(cpp14parserParserInit)
}

// NewCPP14Parser produces a new parser instance for the optional input antlr.TokenStream.
func NewCPP14Parser(input antlr.TokenStream) *CPP14Parser {
	CPP14ParserInit()
	this := new(CPP14Parser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &CPP14ParserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "CPP14Parser.g4"

	return this
}

// CPP14Parser tokens.
const (
	CPP14ParserEOF                         = antlr.TokenEOF
	CPP14ParserIntegerLiteral              = 1
	CPP14ParserCharacterLiteral            = 2
	CPP14ParserFloatingLiteral             = 3
	CPP14ParserStringLiteral               = 4
	CPP14ParserBooleanLiteral              = 5
	CPP14ParserPointerLiteral              = 6
	CPP14ParserUserDefinedLiteral          = 7
	CPP14ParserMultiLineMacro              = 8
	CPP14ParserDirective                   = 9
	CPP14ParserAlignas                     = 10
	CPP14ParserAlignof                     = 11
	CPP14ParserAsm                         = 12
	CPP14ParserAuto                        = 13
	CPP14ParserBool                        = 14
	CPP14ParserBreak                       = 15
	CPP14ParserCase                        = 16
	CPP14ParserCatch                       = 17
	CPP14ParserChar                        = 18
	CPP14ParserChar16                      = 19
	CPP14ParserChar32                      = 20
	CPP14ParserClass                       = 21
	CPP14ParserConst                       = 22
	CPP14ParserConstexpr                   = 23
	CPP14ParserConst_cast                  = 24
	CPP14ParserContinue                    = 25
	CPP14ParserDecltype                    = 26
	CPP14ParserDefault                     = 27
	CPP14ParserDelete                      = 28
	CPP14ParserDo                          = 29
	CPP14ParserDouble                      = 30
	CPP14ParserDynamic_cast                = 31
	CPP14ParserElse                        = 32
	CPP14ParserEnum                        = 33
	CPP14ParserExplicit                    = 34
	CPP14ParserExport                      = 35
	CPP14ParserExtern                      = 36
	CPP14ParserFalse_                      = 37
	CPP14ParserFinal                       = 38
	CPP14ParserFloat                       = 39
	CPP14ParserFor                         = 40
	CPP14ParserFriend                      = 41
	CPP14ParserGoto                        = 42
	CPP14ParserIf                          = 43
	CPP14ParserInline                      = 44
	CPP14ParserInt                         = 45
	CPP14ParserLong                        = 46
	CPP14ParserMutable                     = 47
	CPP14ParserNamespace                   = 48
	CPP14ParserNew                         = 49
	CPP14ParserNoexcept                    = 50
	CPP14ParserNullptr                     = 51
	CPP14ParserOperator                    = 52
	CPP14ParserOverride                    = 53
	CPP14ParserPrivate                     = 54
	CPP14ParserProtected                   = 55
	CPP14ParserPublic                      = 56
	CPP14ParserRegister                    = 57
	CPP14ParserReinterpret_cast            = 58
	CPP14ParserReturn                      = 59
	CPP14ParserShort                       = 60
	CPP14ParserSigned                      = 61
	CPP14ParserSizeof                      = 62
	CPP14ParserStatic                      = 63
	CPP14ParserStatic_assert               = 64
	CPP14ParserStatic_cast                 = 65
	CPP14ParserStruct                      = 66
	CPP14ParserSwitch                      = 67
	CPP14ParserTemplate                    = 68
	CPP14ParserThis                        = 69
	CPP14ParserThread_local                = 70
	CPP14ParserThrow                       = 71
	CPP14ParserTrue_                       = 72
	CPP14ParserTry                         = 73
	CPP14ParserTypedef                     = 74
	CPP14ParserTypeid_                     = 75
	CPP14ParserTypename_                   = 76
	CPP14ParserUnion                       = 77
	CPP14ParserUnsigned                    = 78
	CPP14ParserUsing                       = 79
	CPP14ParserVirtual                     = 80
	CPP14ParserVoid                        = 81
	CPP14ParserVolatile                    = 82
	CPP14ParserWchar                       = 83
	CPP14ParserWhile                       = 84
	CPP14ParserLeftParen                   = 85
	CPP14ParserRightParen                  = 86
	CPP14ParserLeftBracket                 = 87
	CPP14ParserRightBracket                = 88
	CPP14ParserLeftBrace                   = 89
	CPP14ParserRightBrace                  = 90
	CPP14ParserPlus                        = 91
	CPP14ParserMinus                       = 92
	CPP14ParserStar                        = 93
	CPP14ParserDiv                         = 94
	CPP14ParserMod                         = 95
	CPP14ParserCaret                       = 96
	CPP14ParserAnd                         = 97
	CPP14ParserOr                          = 98
	CPP14ParserTilde                       = 99
	CPP14ParserNot                         = 100
	CPP14ParserAssign                      = 101
	CPP14ParserLess                        = 102
	CPP14ParserGreater                     = 103
	CPP14ParserPlusAssign                  = 104
	CPP14ParserMinusAssign                 = 105
	CPP14ParserStarAssign                  = 106
	CPP14ParserDivAssign                   = 107
	CPP14ParserModAssign                   = 108
	CPP14ParserXorAssign                   = 109
	CPP14ParserAndAssign                   = 110
	CPP14ParserOrAssign                    = 111
	CPP14ParserLeftShiftAssign             = 112
	CPP14ParserRightShiftAssign            = 113
	CPP14ParserEqual                       = 114
	CPP14ParserNotEqual                    = 115
	CPP14ParserLessEqual                   = 116
	CPP14ParserGreaterEqual                = 117
	CPP14ParserAndAnd                      = 118
	CPP14ParserOrOr                        = 119
	CPP14ParserPlusPlus                    = 120
	CPP14ParserMinusMinus                  = 121
	CPP14ParserComma                       = 122
	CPP14ParserArrowStar                   = 123
	CPP14ParserArrow                       = 124
	CPP14ParserQuestion                    = 125
	CPP14ParserColon                       = 126
	CPP14ParserDoublecolon                 = 127
	CPP14ParserSemi                        = 128
	CPP14ParserDot                         = 129
	CPP14ParserDotStar                     = 130
	CPP14ParserEllipsis                    = 131
	CPP14ParserIdentifier                  = 132
	CPP14ParserDecimalLiteral              = 133
	CPP14ParserOctalLiteral                = 134
	CPP14ParserHexadecimalLiteral          = 135
	CPP14ParserBinaryLiteral               = 136
	CPP14ParserIntegersuffix               = 137
	CPP14ParserUserDefinedIntegerLiteral   = 138
	CPP14ParserUserDefinedFloatingLiteral  = 139
	CPP14ParserUserDefinedStringLiteral    = 140
	CPP14ParserUserDefinedCharacterLiteral = 141
	CPP14ParserWhitespace                  = 142
	CPP14ParserNewline                     = 143
	CPP14ParserBlockComment                = 144
	CPP14ParserLineComment                 = 145
)

// CPP14Parser rules.
const (
	CPP14ParserRULE_translationUnit                 = 0
	CPP14ParserRULE_primaryExpression               = 1
	CPP14ParserRULE_idExpression                    = 2
	CPP14ParserRULE_unqualifiedId                   = 3
	CPP14ParserRULE_qualifiedId                     = 4
	CPP14ParserRULE_nestedNameSpecifier             = 5
	CPP14ParserRULE_lambdaExpression                = 6
	CPP14ParserRULE_lambdaIntroducer                = 7
	CPP14ParserRULE_lambdaCapture                   = 8
	CPP14ParserRULE_captureDefault                  = 9
	CPP14ParserRULE_captureList                     = 10
	CPP14ParserRULE_capture                         = 11
	CPP14ParserRULE_simpleCapture                   = 12
	CPP14ParserRULE_initcapture                     = 13
	CPP14ParserRULE_lambdaDeclarator                = 14
	CPP14ParserRULE_postfixExpression               = 15
	CPP14ParserRULE_typeIdOfTheTypeId               = 16
	CPP14ParserRULE_expressionList                  = 17
	CPP14ParserRULE_pseudoDestructorName            = 18
	CPP14ParserRULE_unaryExpression                 = 19
	CPP14ParserRULE_unaryOperator                   = 20
	CPP14ParserRULE_newExpression_                  = 21
	CPP14ParserRULE_newPlacement                    = 22
	CPP14ParserRULE_newTypeId                       = 23
	CPP14ParserRULE_newDeclarator_                  = 24
	CPP14ParserRULE_noPointerNewDeclarator          = 25
	CPP14ParserRULE_newInitializer_                 = 26
	CPP14ParserRULE_deleteExpression                = 27
	CPP14ParserRULE_noExceptExpression              = 28
	CPP14ParserRULE_castExpression                  = 29
	CPP14ParserRULE_pointerMemberExpression         = 30
	CPP14ParserRULE_multiplicativeExpression        = 31
	CPP14ParserRULE_additiveExpression              = 32
	CPP14ParserRULE_shiftExpression                 = 33
	CPP14ParserRULE_shiftOperator                   = 34
	CPP14ParserRULE_relationalExpression            = 35
	CPP14ParserRULE_equalityExpression              = 36
	CPP14ParserRULE_andExpression                   = 37
	CPP14ParserRULE_exclusiveOrExpression           = 38
	CPP14ParserRULE_inclusiveOrExpression           = 39
	CPP14ParserRULE_logicalAndExpression            = 40
	CPP14ParserRULE_logicalOrExpression             = 41
	CPP14ParserRULE_conditionalExpression           = 42
	CPP14ParserRULE_assignmentExpression            = 43
	CPP14ParserRULE_assignmentOperator              = 44
	CPP14ParserRULE_expression                      = 45
	CPP14ParserRULE_constantExpression              = 46
	CPP14ParserRULE_statement                       = 47
	CPP14ParserRULE_labeledStatement                = 48
	CPP14ParserRULE_expressionStatement             = 49
	CPP14ParserRULE_compoundStatement               = 50
	CPP14ParserRULE_statementSeq                    = 51
	CPP14ParserRULE_selectionStatement              = 52
	CPP14ParserRULE_condition                       = 53
	CPP14ParserRULE_iterationStatement              = 54
	CPP14ParserRULE_forInitStatement                = 55
	CPP14ParserRULE_forRangeDeclaration             = 56
	CPP14ParserRULE_forRangeInitializer             = 57
	CPP14ParserRULE_jumpStatement                   = 58
	CPP14ParserRULE_declarationStatement            = 59
	CPP14ParserRULE_declarationseq                  = 60
	CPP14ParserRULE_declaration                     = 61
	CPP14ParserRULE_blockDeclaration                = 62
	CPP14ParserRULE_aliasDeclaration                = 63
	CPP14ParserRULE_simpleDeclaration               = 64
	CPP14ParserRULE_staticAssertDeclaration         = 65
	CPP14ParserRULE_emptyDeclaration_               = 66
	CPP14ParserRULE_attributeDeclaration            = 67
	CPP14ParserRULE_declSpecifier                   = 68
	CPP14ParserRULE_declSpecifierSeq                = 69
	CPP14ParserRULE_storageClassSpecifier           = 70
	CPP14ParserRULE_functionSpecifier               = 71
	CPP14ParserRULE_typedefName                     = 72
	CPP14ParserRULE_typeSpecifier                   = 73
	CPP14ParserRULE_trailingTypeSpecifier           = 74
	CPP14ParserRULE_typeSpecifierSeq                = 75
	CPP14ParserRULE_trailingTypeSpecifierSeq        = 76
	CPP14ParserRULE_simpleTypeLengthModifier        = 77
	CPP14ParserRULE_simpleTypeSignednessModifier    = 78
	CPP14ParserRULE_simpleTypeSpecifier             = 79
	CPP14ParserRULE_theTypeName                     = 80
	CPP14ParserRULE_decltypeSpecifier               = 81
	CPP14ParserRULE_elaboratedTypeSpecifier         = 82
	CPP14ParserRULE_enumName                        = 83
	CPP14ParserRULE_enumSpecifier                   = 84
	CPP14ParserRULE_enumHead                        = 85
	CPP14ParserRULE_opaqueEnumDeclaration           = 86
	CPP14ParserRULE_enumkey                         = 87
	CPP14ParserRULE_enumbase                        = 88
	CPP14ParserRULE_enumeratorList                  = 89
	CPP14ParserRULE_enumeratorDefinition            = 90
	CPP14ParserRULE_enumerator                      = 91
	CPP14ParserRULE_namespaceName                   = 92
	CPP14ParserRULE_originalNamespaceName           = 93
	CPP14ParserRULE_namespaceDefinition             = 94
	CPP14ParserRULE_namespaceAlias                  = 95
	CPP14ParserRULE_namespaceAliasDefinition        = 96
	CPP14ParserRULE_qualifiednamespacespecifier     = 97
	CPP14ParserRULE_usingDeclaration                = 98
	CPP14ParserRULE_usingDirective                  = 99
	CPP14ParserRULE_asmDefinition                   = 100
	CPP14ParserRULE_linkageSpecification            = 101
	CPP14ParserRULE_attributeSpecifierSeq           = 102
	CPP14ParserRULE_attributeSpecifier              = 103
	CPP14ParserRULE_alignmentspecifier              = 104
	CPP14ParserRULE_attributeList                   = 105
	CPP14ParserRULE_attribute                       = 106
	CPP14ParserRULE_attributeNamespace              = 107
	CPP14ParserRULE_attributeArgumentClause         = 108
	CPP14ParserRULE_balancedTokenSeq                = 109
	CPP14ParserRULE_balancedtoken                   = 110
	CPP14ParserRULE_initDeclaratorList              = 111
	CPP14ParserRULE_initDeclarator                  = 112
	CPP14ParserRULE_declarator                      = 113
	CPP14ParserRULE_pointerDeclarator               = 114
	CPP14ParserRULE_noPointerDeclarator             = 115
	CPP14ParserRULE_parametersAndQualifiers         = 116
	CPP14ParserRULE_trailingReturnType              = 117
	CPP14ParserRULE_pointerOperator                 = 118
	CPP14ParserRULE_cvqualifierseq                  = 119
	CPP14ParserRULE_cvQualifier                     = 120
	CPP14ParserRULE_refqualifier                    = 121
	CPP14ParserRULE_declaratorid                    = 122
	CPP14ParserRULE_theTypeId                       = 123
	CPP14ParserRULE_abstractDeclarator              = 124
	CPP14ParserRULE_pointerAbstractDeclarator       = 125
	CPP14ParserRULE_noPointerAbstractDeclarator     = 126
	CPP14ParserRULE_abstractPackDeclarator          = 127
	CPP14ParserRULE_noPointerAbstractPackDeclarator = 128
	CPP14ParserRULE_parameterDeclarationClause      = 129
	CPP14ParserRULE_parameterDeclarationList        = 130
	CPP14ParserRULE_parameterDeclaration            = 131
	CPP14ParserRULE_functionDefinition              = 132
	CPP14ParserRULE_functionBody                    = 133
	CPP14ParserRULE_initializer                     = 134
	CPP14ParserRULE_braceOrEqualInitializer         = 135
	CPP14ParserRULE_initializerClause               = 136
	CPP14ParserRULE_initializerList                 = 137
	CPP14ParserRULE_bracedInitList                  = 138
	CPP14ParserRULE_className                       = 139
	CPP14ParserRULE_classSpecifier                  = 140
	CPP14ParserRULE_classHead                       = 141
	CPP14ParserRULE_classHeadName                   = 142
	CPP14ParserRULE_classVirtSpecifier              = 143
	CPP14ParserRULE_classKey                        = 144
	CPP14ParserRULE_memberSpecification             = 145
	CPP14ParserRULE_memberdeclaration               = 146
	CPP14ParserRULE_memberDeclaratorList            = 147
	CPP14ParserRULE_memberDeclarator                = 148
	CPP14ParserRULE_virtualSpecifierSeq             = 149
	CPP14ParserRULE_virtualSpecifier                = 150
	CPP14ParserRULE_pureSpecifier                   = 151
	CPP14ParserRULE_baseClause                      = 152
	CPP14ParserRULE_baseSpecifierList               = 153
	CPP14ParserRULE_baseSpecifier                   = 154
	CPP14ParserRULE_classOrDeclType                 = 155
	CPP14ParserRULE_baseTypeSpecifier               = 156
	CPP14ParserRULE_accessSpecifier                 = 157
	CPP14ParserRULE_conversionFunctionId            = 158
	CPP14ParserRULE_conversionTypeId                = 159
	CPP14ParserRULE_conversionDeclarator            = 160
	CPP14ParserRULE_constructorInitializer          = 161
	CPP14ParserRULE_memInitializerList              = 162
	CPP14ParserRULE_memInitializer                  = 163
	CPP14ParserRULE_meminitializerid                = 164
	CPP14ParserRULE_operatorFunctionId              = 165
	CPP14ParserRULE_literalOperatorId               = 166
	CPP14ParserRULE_templateDeclaration             = 167
	CPP14ParserRULE_templateparameterList           = 168
	CPP14ParserRULE_templateParameter               = 169
	CPP14ParserRULE_typeParameter                   = 170
	CPP14ParserRULE_simpleTemplateId                = 171
	CPP14ParserRULE_templateId                      = 172
	CPP14ParserRULE_templateName                    = 173
	CPP14ParserRULE_templateArgumentList            = 174
	CPP14ParserRULE_templateArgument                = 175
	CPP14ParserRULE_typeNameSpecifier               = 176
	CPP14ParserRULE_explicitInstantiation           = 177
	CPP14ParserRULE_explicitSpecialization          = 178
	CPP14ParserRULE_tryBlock                        = 179
	CPP14ParserRULE_functionTryBlock                = 180
	CPP14ParserRULE_handlerSeq                      = 181
	CPP14ParserRULE_handler                         = 182
	CPP14ParserRULE_exceptionDeclaration            = 183
	CPP14ParserRULE_throwExpression                 = 184
	CPP14ParserRULE_exceptionSpecification          = 185
	CPP14ParserRULE_dynamicExceptionSpecification   = 186
	CPP14ParserRULE_typeIdList                      = 187
	CPP14ParserRULE_noeExceptSpecification          = 188
	CPP14ParserRULE_theOperator                     = 189
	CPP14ParserRULE_literal                         = 190
)

// ITranslationUnitContext is an interface to support dynamic dispatch.
type ITranslationUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	Declarationseq() IDeclarationseqContext

	// IsTranslationUnitContext differentiates from other interfaces.
	IsTranslationUnitContext()
}

type TranslationUnitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTranslationUnitContext() *TranslationUnitContext {
	var p = new(TranslationUnitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_translationUnit
	return p
}

func InitEmptyTranslationUnitContext(p *TranslationUnitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_translationUnit
}

func (*TranslationUnitContext) IsTranslationUnitContext() {}

func NewTranslationUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TranslationUnitContext {
	var p = new(TranslationUnitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_translationUnit

	return p
}

func (s *TranslationUnitContext) GetParser() antlr.Parser { return s.parser }

func (s *TranslationUnitContext) EOF() antlr.TerminalNode {
	return s.GetToken(CPP14ParserEOF, 0)
}

func (s *TranslationUnitContext) Declarationseq() IDeclarationseqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationseqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationseqContext)
}

func (s *TranslationUnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TranslationUnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TranslationUnitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterTranslationUnit(s)
	}
}

func (s *TranslationUnitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitTranslationUnit(s)
	}
}

func (s *TranslationUnitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitTranslationUnit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) TranslationUnit() (localctx ITranslationUnitContext) {
	localctx = NewTranslationUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, CPP14ParserRULE_translationUnit)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(383)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64((_la-10)) & ^0x3f) == 0 && ((int64(1)<<(_la-10))&1543754443169808157) != 0) || ((int64((_la-74)) & ^0x3f) == 0 && ((int64(1)<<(_la-74))&459384754220313597) != 0) {
		{
			p.SetState(382)
			p.Declarationseq()
		}

	}
	{
		p.SetState(385)
		p.Match(CPP14ParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimaryExpressionContext is an interface to support dynamic dispatch.
type IPrimaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLiteral() []ILiteralContext
	Literal(i int) ILiteralContext
	This() antlr.TerminalNode
	LeftParen() antlr.TerminalNode
	Expression() IExpressionContext
	RightParen() antlr.TerminalNode
	IdExpression() IIdExpressionContext
	LambdaExpression() ILambdaExpressionContext

	// IsPrimaryExpressionContext differentiates from other interfaces.
	IsPrimaryExpressionContext()
}

type PrimaryExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryExpressionContext() *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_primaryExpression
	return p
}

func InitEmptyPrimaryExpressionContext(p *PrimaryExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_primaryExpression
}

func (*PrimaryExpressionContext) IsPrimaryExpressionContext() {}

func NewPrimaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_primaryExpression

	return p
}

func (s *PrimaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryExpressionContext) AllLiteral() []ILiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILiteralContext); ok {
			len++
		}
	}

	tst := make([]ILiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILiteralContext); ok {
			tst[i] = t.(ILiteralContext)
			i++
		}
	}

	return tst
}

func (s *PrimaryExpressionContext) Literal(i int) ILiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *PrimaryExpressionContext) This() antlr.TerminalNode {
	return s.GetToken(CPP14ParserThis, 0)
}

func (s *PrimaryExpressionContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CPP14ParserLeftParen, 0)
}

func (s *PrimaryExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PrimaryExpressionContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CPP14ParserRightParen, 0)
}

func (s *PrimaryExpressionContext) IdExpression() IIdExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdExpressionContext)
}

func (s *PrimaryExpressionContext) LambdaExpression() ILambdaExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaExpressionContext)
}

func (s *PrimaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterPrimaryExpression(s)
	}
}

func (s *PrimaryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitPrimaryExpression(s)
	}
}

func (s *PrimaryExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitPrimaryExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) PrimaryExpression() (localctx IPrimaryExpressionContext) {
	localctx = NewPrimaryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, CPP14ParserRULE_primaryExpression)
	var _alt int

	p.SetState(399)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CPP14ParserIntegerLiteral, CPP14ParserCharacterLiteral, CPP14ParserFloatingLiteral, CPP14ParserStringLiteral, CPP14ParserBooleanLiteral, CPP14ParserPointerLiteral, CPP14ParserUserDefinedLiteral:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(388)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(387)
					p.Literal()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(390)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 1, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case CPP14ParserThis:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(392)
			p.Match(CPP14ParserThis)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case CPP14ParserLeftParen:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(393)
			p.Match(CPP14ParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(394)
			p.Expression()
		}
		{
			p.SetState(395)
			p.Match(CPP14ParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case CPP14ParserDecltype, CPP14ParserOperator, CPP14ParserTilde, CPP14ParserDoublecolon, CPP14ParserIdentifier:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(397)
			p.IdExpression()
		}

	case CPP14ParserLeftBracket:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(398)
			p.LambdaExpression()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdExpressionContext is an interface to support dynamic dispatch.
type IIdExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnqualifiedId() IUnqualifiedIdContext
	QualifiedId() IQualifiedIdContext

	// IsIdExpressionContext differentiates from other interfaces.
	IsIdExpressionContext()
}

type IdExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdExpressionContext() *IdExpressionContext {
	var p = new(IdExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_idExpression
	return p
}

func InitEmptyIdExpressionContext(p *IdExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_idExpression
}

func (*IdExpressionContext) IsIdExpressionContext() {}

func NewIdExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdExpressionContext {
	var p = new(IdExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_idExpression

	return p
}

func (s *IdExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *IdExpressionContext) UnqualifiedId() IUnqualifiedIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnqualifiedIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnqualifiedIdContext)
}

func (s *IdExpressionContext) QualifiedId() IQualifiedIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedIdContext)
}

func (s *IdExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterIdExpression(s)
	}
}

func (s *IdExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitIdExpression(s)
	}
}

func (s *IdExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitIdExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) IdExpression() (localctx IIdExpressionContext) {
	localctx = NewIdExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, CPP14ParserRULE_idExpression)
	p.SetState(403)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 3, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(401)
			p.UnqualifiedId()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(402)
			p.QualifiedId()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnqualifiedIdContext is an interface to support dynamic dispatch.
type IUnqualifiedIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	OperatorFunctionId() IOperatorFunctionIdContext
	ConversionFunctionId() IConversionFunctionIdContext
	LiteralOperatorId() ILiteralOperatorIdContext
	Tilde() antlr.TerminalNode
	ClassName() IClassNameContext
	DecltypeSpecifier() IDecltypeSpecifierContext
	TemplateId() ITemplateIdContext

	// IsUnqualifiedIdContext differentiates from other interfaces.
	IsUnqualifiedIdContext()
}

type UnqualifiedIdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnqualifiedIdContext() *UnqualifiedIdContext {
	var p = new(UnqualifiedIdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_unqualifiedId
	return p
}

func InitEmptyUnqualifiedIdContext(p *UnqualifiedIdContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_unqualifiedId
}

func (*UnqualifiedIdContext) IsUnqualifiedIdContext() {}

func NewUnqualifiedIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnqualifiedIdContext {
	var p = new(UnqualifiedIdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_unqualifiedId

	return p
}

func (s *UnqualifiedIdContext) GetParser() antlr.Parser { return s.parser }

func (s *UnqualifiedIdContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CPP14ParserIdentifier, 0)
}

func (s *UnqualifiedIdContext) OperatorFunctionId() IOperatorFunctionIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOperatorFunctionIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOperatorFunctionIdContext)
}

func (s *UnqualifiedIdContext) ConversionFunctionId() IConversionFunctionIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConversionFunctionIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConversionFunctionIdContext)
}

func (s *UnqualifiedIdContext) LiteralOperatorId() ILiteralOperatorIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralOperatorIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralOperatorIdContext)
}

func (s *UnqualifiedIdContext) Tilde() antlr.TerminalNode {
	return s.GetToken(CPP14ParserTilde, 0)
}

func (s *UnqualifiedIdContext) ClassName() IClassNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassNameContext)
}

func (s *UnqualifiedIdContext) DecltypeSpecifier() IDecltypeSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecltypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecltypeSpecifierContext)
}

func (s *UnqualifiedIdContext) TemplateId() ITemplateIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITemplateIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITemplateIdContext)
}

func (s *UnqualifiedIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnqualifiedIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnqualifiedIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterUnqualifiedId(s)
	}
}

func (s *UnqualifiedIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitUnqualifiedId(s)
	}
}

func (s *UnqualifiedIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitUnqualifiedId(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) UnqualifiedId() (localctx IUnqualifiedIdContext) {
	localctx = NewUnqualifiedIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, CPP14ParserRULE_unqualifiedId)
	p.SetState(415)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(405)
			p.Match(CPP14ParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(406)
			p.OperatorFunctionId()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(407)
			p.ConversionFunctionId()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(408)
			p.LiteralOperatorId()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(409)
			p.Match(CPP14ParserTilde)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(412)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case CPP14ParserIdentifier:
			{
				p.SetState(410)
				p.ClassName()
			}

		case CPP14ParserDecltype:
			{
				p.SetState(411)
				p.DecltypeSpecifier()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(414)
			p.TemplateId()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQualifiedIdContext is an interface to support dynamic dispatch.
type IQualifiedIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NestedNameSpecifier() INestedNameSpecifierContext
	UnqualifiedId() IUnqualifiedIdContext
	Template() antlr.TerminalNode

	// IsQualifiedIdContext differentiates from other interfaces.
	IsQualifiedIdContext()
}

type QualifiedIdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedIdContext() *QualifiedIdContext {
	var p = new(QualifiedIdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_qualifiedId
	return p
}

func InitEmptyQualifiedIdContext(p *QualifiedIdContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_qualifiedId
}

func (*QualifiedIdContext) IsQualifiedIdContext() {}

func NewQualifiedIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedIdContext {
	var p = new(QualifiedIdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_qualifiedId

	return p
}

func (s *QualifiedIdContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedIdContext) NestedNameSpecifier() INestedNameSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedNameSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedNameSpecifierContext)
}

func (s *QualifiedIdContext) UnqualifiedId() IUnqualifiedIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnqualifiedIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnqualifiedIdContext)
}

func (s *QualifiedIdContext) Template() antlr.TerminalNode {
	return s.GetToken(CPP14ParserTemplate, 0)
}

func (s *QualifiedIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterQualifiedId(s)
	}
}

func (s *QualifiedIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitQualifiedId(s)
	}
}

func (s *QualifiedIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitQualifiedId(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) QualifiedId() (localctx IQualifiedIdContext) {
	localctx = NewQualifiedIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, CPP14ParserRULE_qualifiedId)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(417)
		p.nestedNameSpecifier(0)
	}
	p.SetState(419)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CPP14ParserTemplate {
		{
			p.SetState(418)
			p.Match(CPP14ParserTemplate)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(421)
		p.UnqualifiedId()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INestedNameSpecifierContext is an interface to support dynamic dispatch.
type INestedNameSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Doublecolon() antlr.TerminalNode
	TheTypeName() ITheTypeNameContext
	NamespaceName() INamespaceNameContext
	DecltypeSpecifier() IDecltypeSpecifierContext
	NestedNameSpecifier() INestedNameSpecifierContext
	Identifier() antlr.TerminalNode
	SimpleTemplateId() ISimpleTemplateIdContext
	Template() antlr.TerminalNode

	// IsNestedNameSpecifierContext differentiates from other interfaces.
	IsNestedNameSpecifierContext()
}

type NestedNameSpecifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNestedNameSpecifierContext() *NestedNameSpecifierContext {
	var p = new(NestedNameSpecifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_nestedNameSpecifier
	return p
}

func InitEmptyNestedNameSpecifierContext(p *NestedNameSpecifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_nestedNameSpecifier
}

func (*NestedNameSpecifierContext) IsNestedNameSpecifierContext() {}

func NewNestedNameSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NestedNameSpecifierContext {
	var p = new(NestedNameSpecifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_nestedNameSpecifier

	return p
}

func (s *NestedNameSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *NestedNameSpecifierContext) Doublecolon() antlr.TerminalNode {
	return s.GetToken(CPP14ParserDoublecolon, 0)
}

func (s *NestedNameSpecifierContext) TheTypeName() ITheTypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITheTypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITheTypeNameContext)
}

func (s *NestedNameSpecifierContext) NamespaceName() INamespaceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceNameContext)
}

func (s *NestedNameSpecifierContext) DecltypeSpecifier() IDecltypeSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecltypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecltypeSpecifierContext)
}

func (s *NestedNameSpecifierContext) NestedNameSpecifier() INestedNameSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedNameSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedNameSpecifierContext)
}

func (s *NestedNameSpecifierContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CPP14ParserIdentifier, 0)
}

func (s *NestedNameSpecifierContext) SimpleTemplateId() ISimpleTemplateIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleTemplateIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleTemplateIdContext)
}

func (s *NestedNameSpecifierContext) Template() antlr.TerminalNode {
	return s.GetToken(CPP14ParserTemplate, 0)
}

func (s *NestedNameSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NestedNameSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NestedNameSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterNestedNameSpecifier(s)
	}
}

func (s *NestedNameSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitNestedNameSpecifier(s)
	}
}

func (s *NestedNameSpecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitNestedNameSpecifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) NestedNameSpecifier() (localctx INestedNameSpecifierContext) {
	return p.nestedNameSpecifier(0)
}

func (p *CPP14Parser) nestedNameSpecifier(_p int) (localctx INestedNameSpecifierContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewNestedNameSpecifierContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx INestedNameSpecifierContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 10
	p.EnterRecursionRule(localctx, 10, CPP14ParserRULE_nestedNameSpecifier, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(427)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 7, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(424)
			p.TheTypeName()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 7, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(425)
			p.NamespaceName()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 7, p.GetParserRuleContext()) == 3 {
		{
			p.SetState(426)
			p.DecltypeSpecifier()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(429)
		p.Match(CPP14ParserDoublecolon)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(442)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 10, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewNestedNameSpecifierContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, CPP14ParserRULE_nestedNameSpecifier)
			p.SetState(431)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			p.SetState(437)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 9, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(432)
					p.Match(CPP14ParserIdentifier)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 2:
				p.SetState(434)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == CPP14ParserTemplate {
					{
						p.SetState(433)
						p.Match(CPP14ParserTemplate)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(436)
					p.SimpleTemplateId()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}
			{
				p.SetState(439)
				p.Match(CPP14ParserDoublecolon)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(444)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 10, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILambdaExpressionContext is an interface to support dynamic dispatch.
type ILambdaExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LambdaIntroducer() ILambdaIntroducerContext
	CompoundStatement() ICompoundStatementContext
	LambdaDeclarator() ILambdaDeclaratorContext

	// IsLambdaExpressionContext differentiates from other interfaces.
	IsLambdaExpressionContext()
}

type LambdaExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaExpressionContext() *LambdaExpressionContext {
	var p = new(LambdaExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_lambdaExpression
	return p
}

func InitEmptyLambdaExpressionContext(p *LambdaExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_lambdaExpression
}

func (*LambdaExpressionContext) IsLambdaExpressionContext() {}

func NewLambdaExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaExpressionContext {
	var p = new(LambdaExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_lambdaExpression

	return p
}

func (s *LambdaExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaExpressionContext) LambdaIntroducer() ILambdaIntroducerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaIntroducerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaIntroducerContext)
}

func (s *LambdaExpressionContext) CompoundStatement() ICompoundStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementContext)
}

func (s *LambdaExpressionContext) LambdaDeclarator() ILambdaDeclaratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaDeclaratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaDeclaratorContext)
}

func (s *LambdaExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterLambdaExpression(s)
	}
}

func (s *LambdaExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitLambdaExpression(s)
	}
}

func (s *LambdaExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitLambdaExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) LambdaExpression() (localctx ILambdaExpressionContext) {
	localctx = NewLambdaExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, CPP14ParserRULE_lambdaExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(445)
		p.LambdaIntroducer()
	}
	p.SetState(447)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CPP14ParserLeftParen {
		{
			p.SetState(446)
			p.LambdaDeclarator()
		}

	}
	{
		p.SetState(449)
		p.CompoundStatement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILambdaIntroducerContext is an interface to support dynamic dispatch.
type ILambdaIntroducerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LeftBracket() antlr.TerminalNode
	RightBracket() antlr.TerminalNode
	LambdaCapture() ILambdaCaptureContext

	// IsLambdaIntroducerContext differentiates from other interfaces.
	IsLambdaIntroducerContext()
}

type LambdaIntroducerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaIntroducerContext() *LambdaIntroducerContext {
	var p = new(LambdaIntroducerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_lambdaIntroducer
	return p
}

func InitEmptyLambdaIntroducerContext(p *LambdaIntroducerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_lambdaIntroducer
}

func (*LambdaIntroducerContext) IsLambdaIntroducerContext() {}

func NewLambdaIntroducerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaIntroducerContext {
	var p = new(LambdaIntroducerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_lambdaIntroducer

	return p
}

func (s *LambdaIntroducerContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaIntroducerContext) LeftBracket() antlr.TerminalNode {
	return s.GetToken(CPP14ParserLeftBracket, 0)
}

func (s *LambdaIntroducerContext) RightBracket() antlr.TerminalNode {
	return s.GetToken(CPP14ParserRightBracket, 0)
}

func (s *LambdaIntroducerContext) LambdaCapture() ILambdaCaptureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILambdaCaptureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILambdaCaptureContext)
}

func (s *LambdaIntroducerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaIntroducerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaIntroducerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterLambdaIntroducer(s)
	}
}

func (s *LambdaIntroducerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitLambdaIntroducer(s)
	}
}

func (s *LambdaIntroducerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitLambdaIntroducer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) LambdaIntroducer() (localctx ILambdaIntroducerContext) {
	localctx = NewLambdaIntroducerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, CPP14ParserRULE_lambdaIntroducer)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(451)
		p.Match(CPP14ParserLeftBracket)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(453)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-69)) & ^0x3f) == 0 && ((int64(1)<<(_la-69))&-9223372032291373055) != 0 {
		{
			p.SetState(452)
			p.LambdaCapture()
		}

	}
	{
		p.SetState(455)
		p.Match(CPP14ParserRightBracket)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILambdaCaptureContext is an interface to support dynamic dispatch.
type ILambdaCaptureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CaptureList() ICaptureListContext
	CaptureDefault() ICaptureDefaultContext
	Comma() antlr.TerminalNode

	// IsLambdaCaptureContext differentiates from other interfaces.
	IsLambdaCaptureContext()
}

type LambdaCaptureContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaCaptureContext() *LambdaCaptureContext {
	var p = new(LambdaCaptureContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_lambdaCapture
	return p
}

func InitEmptyLambdaCaptureContext(p *LambdaCaptureContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_lambdaCapture
}

func (*LambdaCaptureContext) IsLambdaCaptureContext() {}

func NewLambdaCaptureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaCaptureContext {
	var p = new(LambdaCaptureContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_lambdaCapture

	return p
}

func (s *LambdaCaptureContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaCaptureContext) CaptureList() ICaptureListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaptureListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaptureListContext)
}

func (s *LambdaCaptureContext) CaptureDefault() ICaptureDefaultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaptureDefaultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaptureDefaultContext)
}

func (s *LambdaCaptureContext) Comma() antlr.TerminalNode {
	return s.GetToken(CPP14ParserComma, 0)
}

func (s *LambdaCaptureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaCaptureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaCaptureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterLambdaCapture(s)
	}
}

func (s *LambdaCaptureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitLambdaCapture(s)
	}
}

func (s *LambdaCaptureContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitLambdaCapture(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) LambdaCapture() (localctx ILambdaCaptureContext) {
	localctx = NewLambdaCaptureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, CPP14ParserRULE_lambdaCapture)
	var _la int

	p.SetState(463)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 14, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(457)
			p.CaptureList()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(458)
			p.CaptureDefault()
		}
		p.SetState(461)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CPP14ParserComma {
			{
				p.SetState(459)
				p.Match(CPP14ParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(460)
				p.CaptureList()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaptureDefaultContext is an interface to support dynamic dispatch.
type ICaptureDefaultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	And() antlr.TerminalNode
	Assign() antlr.TerminalNode

	// IsCaptureDefaultContext differentiates from other interfaces.
	IsCaptureDefaultContext()
}

type CaptureDefaultContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaptureDefaultContext() *CaptureDefaultContext {
	var p = new(CaptureDefaultContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_captureDefault
	return p
}

func InitEmptyCaptureDefaultContext(p *CaptureDefaultContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_captureDefault
}

func (*CaptureDefaultContext) IsCaptureDefaultContext() {}

func NewCaptureDefaultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaptureDefaultContext {
	var p = new(CaptureDefaultContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_captureDefault

	return p
}

func (s *CaptureDefaultContext) GetParser() antlr.Parser { return s.parser }

func (s *CaptureDefaultContext) And() antlr.TerminalNode {
	return s.GetToken(CPP14ParserAnd, 0)
}

func (s *CaptureDefaultContext) Assign() antlr.TerminalNode {
	return s.GetToken(CPP14ParserAssign, 0)
}

func (s *CaptureDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaptureDefaultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaptureDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterCaptureDefault(s)
	}
}

func (s *CaptureDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitCaptureDefault(s)
	}
}

func (s *CaptureDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitCaptureDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) CaptureDefault() (localctx ICaptureDefaultContext) {
	localctx = NewCaptureDefaultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, CPP14ParserRULE_captureDefault)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(465)
		_la = p.GetTokenStream().LA(1)

		if !(_la == CPP14ParserAnd || _la == CPP14ParserAssign) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaptureListContext is an interface to support dynamic dispatch.
type ICaptureListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCapture() []ICaptureContext
	Capture(i int) ICaptureContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode
	Ellipsis() antlr.TerminalNode

	// IsCaptureListContext differentiates from other interfaces.
	IsCaptureListContext()
}

type CaptureListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaptureListContext() *CaptureListContext {
	var p = new(CaptureListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_captureList
	return p
}

func InitEmptyCaptureListContext(p *CaptureListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_captureList
}

func (*CaptureListContext) IsCaptureListContext() {}

func NewCaptureListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaptureListContext {
	var p = new(CaptureListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_captureList

	return p
}

func (s *CaptureListContext) GetParser() antlr.Parser { return s.parser }

func (s *CaptureListContext) AllCapture() []ICaptureContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICaptureContext); ok {
			len++
		}
	}

	tst := make([]ICaptureContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICaptureContext); ok {
			tst[i] = t.(ICaptureContext)
			i++
		}
	}

	return tst
}

func (s *CaptureListContext) Capture(i int) ICaptureContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaptureContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaptureContext)
}

func (s *CaptureListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(CPP14ParserComma)
}

func (s *CaptureListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(CPP14ParserComma, i)
}

func (s *CaptureListContext) Ellipsis() antlr.TerminalNode {
	return s.GetToken(CPP14ParserEllipsis, 0)
}

func (s *CaptureListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaptureListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaptureListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterCaptureList(s)
	}
}

func (s *CaptureListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitCaptureList(s)
	}
}

func (s *CaptureListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitCaptureList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) CaptureList() (localctx ICaptureListContext) {
	localctx = NewCaptureListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, CPP14ParserRULE_captureList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(467)
		p.Capture()
	}
	p.SetState(472)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CPP14ParserComma {
		{
			p.SetState(468)
			p.Match(CPP14ParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(469)
			p.Capture()
		}

		p.SetState(474)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(476)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CPP14ParserEllipsis {
		{
			p.SetState(475)
			p.Match(CPP14ParserEllipsis)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICaptureContext is an interface to support dynamic dispatch.
type ICaptureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleCapture() ISimpleCaptureContext
	Initcapture() IInitcaptureContext

	// IsCaptureContext differentiates from other interfaces.
	IsCaptureContext()
}

type CaptureContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaptureContext() *CaptureContext {
	var p = new(CaptureContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_capture
	return p
}

func InitEmptyCaptureContext(p *CaptureContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_capture
}

func (*CaptureContext) IsCaptureContext() {}

func NewCaptureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaptureContext {
	var p = new(CaptureContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_capture

	return p
}

func (s *CaptureContext) GetParser() antlr.Parser { return s.parser }

func (s *CaptureContext) SimpleCapture() ISimpleCaptureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleCaptureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleCaptureContext)
}

func (s *CaptureContext) Initcapture() IInitcaptureContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitcaptureContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitcaptureContext)
}

func (s *CaptureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaptureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CaptureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterCapture(s)
	}
}

func (s *CaptureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitCapture(s)
	}
}

func (s *CaptureContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitCapture(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) Capture() (localctx ICaptureContext) {
	localctx = NewCaptureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, CPP14ParserRULE_capture)
	p.SetState(480)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 17, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(478)
			p.SimpleCapture()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(479)
			p.Initcapture()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleCaptureContext is an interface to support dynamic dispatch.
type ISimpleCaptureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	And() antlr.TerminalNode
	This() antlr.TerminalNode

	// IsSimpleCaptureContext differentiates from other interfaces.
	IsSimpleCaptureContext()
}

type SimpleCaptureContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleCaptureContext() *SimpleCaptureContext {
	var p = new(SimpleCaptureContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_simpleCapture
	return p
}

func InitEmptySimpleCaptureContext(p *SimpleCaptureContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_simpleCapture
}

func (*SimpleCaptureContext) IsSimpleCaptureContext() {}

func NewSimpleCaptureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleCaptureContext {
	var p = new(SimpleCaptureContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_simpleCapture

	return p
}

func (s *SimpleCaptureContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleCaptureContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CPP14ParserIdentifier, 0)
}

func (s *SimpleCaptureContext) And() antlr.TerminalNode {
	return s.GetToken(CPP14ParserAnd, 0)
}

func (s *SimpleCaptureContext) This() antlr.TerminalNode {
	return s.GetToken(CPP14ParserThis, 0)
}

func (s *SimpleCaptureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleCaptureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleCaptureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterSimpleCapture(s)
	}
}

func (s *SimpleCaptureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitSimpleCapture(s)
	}
}

func (s *SimpleCaptureContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitSimpleCapture(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) SimpleCapture() (localctx ISimpleCaptureContext) {
	localctx = NewSimpleCaptureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, CPP14ParserRULE_simpleCapture)
	var _la int

	p.SetState(487)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CPP14ParserAnd, CPP14ParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(483)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CPP14ParserAnd {
			{
				p.SetState(482)
				p.Match(CPP14ParserAnd)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(485)
			p.Match(CPP14ParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case CPP14ParserThis:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(486)
			p.Match(CPP14ParserThis)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInitcaptureContext is an interface to support dynamic dispatch.
type IInitcaptureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	Initializer() IInitializerContext
	And() antlr.TerminalNode

	// IsInitcaptureContext differentiates from other interfaces.
	IsInitcaptureContext()
}

type InitcaptureContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitcaptureContext() *InitcaptureContext {
	var p = new(InitcaptureContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_initcapture
	return p
}

func InitEmptyInitcaptureContext(p *InitcaptureContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_initcapture
}

func (*InitcaptureContext) IsInitcaptureContext() {}

func NewInitcaptureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitcaptureContext {
	var p = new(InitcaptureContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_initcapture

	return p
}

func (s *InitcaptureContext) GetParser() antlr.Parser { return s.parser }

func (s *InitcaptureContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CPP14ParserIdentifier, 0)
}

func (s *InitcaptureContext) Initializer() IInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitializerContext)
}

func (s *InitcaptureContext) And() antlr.TerminalNode {
	return s.GetToken(CPP14ParserAnd, 0)
}

func (s *InitcaptureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitcaptureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitcaptureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterInitcapture(s)
	}
}

func (s *InitcaptureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitInitcapture(s)
	}
}

func (s *InitcaptureContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitInitcapture(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) Initcapture() (localctx IInitcaptureContext) {
	localctx = NewInitcaptureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, CPP14ParserRULE_initcapture)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(490)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CPP14ParserAnd {
		{
			p.SetState(489)
			p.Match(CPP14ParserAnd)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(492)
		p.Match(CPP14ParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(493)
		p.Initializer()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILambdaDeclaratorContext is an interface to support dynamic dispatch.
type ILambdaDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LeftParen() antlr.TerminalNode
	RightParen() antlr.TerminalNode
	ParameterDeclarationClause() IParameterDeclarationClauseContext
	Mutable() antlr.TerminalNode
	ExceptionSpecification() IExceptionSpecificationContext
	AttributeSpecifierSeq() IAttributeSpecifierSeqContext
	TrailingReturnType() ITrailingReturnTypeContext

	// IsLambdaDeclaratorContext differentiates from other interfaces.
	IsLambdaDeclaratorContext()
}

type LambdaDeclaratorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLambdaDeclaratorContext() *LambdaDeclaratorContext {
	var p = new(LambdaDeclaratorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_lambdaDeclarator
	return p
}

func InitEmptyLambdaDeclaratorContext(p *LambdaDeclaratorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_lambdaDeclarator
}

func (*LambdaDeclaratorContext) IsLambdaDeclaratorContext() {}

func NewLambdaDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LambdaDeclaratorContext {
	var p = new(LambdaDeclaratorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_lambdaDeclarator

	return p
}

func (s *LambdaDeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *LambdaDeclaratorContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CPP14ParserLeftParen, 0)
}

func (s *LambdaDeclaratorContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CPP14ParserRightParen, 0)
}

func (s *LambdaDeclaratorContext) ParameterDeclarationClause() IParameterDeclarationClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterDeclarationClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterDeclarationClauseContext)
}

func (s *LambdaDeclaratorContext) Mutable() antlr.TerminalNode {
	return s.GetToken(CPP14ParserMutable, 0)
}

func (s *LambdaDeclaratorContext) ExceptionSpecification() IExceptionSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExceptionSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExceptionSpecificationContext)
}

func (s *LambdaDeclaratorContext) AttributeSpecifierSeq() IAttributeSpecifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSpecifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSpecifierSeqContext)
}

func (s *LambdaDeclaratorContext) TrailingReturnType() ITrailingReturnTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITrailingReturnTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITrailingReturnTypeContext)
}

func (s *LambdaDeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaDeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LambdaDeclaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterLambdaDeclarator(s)
	}
}

func (s *LambdaDeclaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitLambdaDeclarator(s)
	}
}

func (s *LambdaDeclaratorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitLambdaDeclarator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) LambdaDeclarator() (localctx ILambdaDeclaratorContext) {
	localctx = NewLambdaDeclaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, CPP14ParserRULE_lambdaDeclarator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(495)
		p.Match(CPP14ParserLeftParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(497)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64((_la-10)) & ^0x3f) == 0 && ((int64(1)<<(_la-10))&1237504995584196377) != 0) || ((int64((_la-74)) & ^0x3f) == 0 && ((int64(1)<<(_la-74))&297237575406461917) != 0) {
		{
			p.SetState(496)
			p.ParameterDeclarationClause()
		}

	}
	{
		p.SetState(499)
		p.Match(CPP14ParserRightParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(501)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CPP14ParserMutable {
		{
			p.SetState(500)
			p.Match(CPP14ParserMutable)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(504)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CPP14ParserNoexcept || _la == CPP14ParserThrow {
		{
			p.SetState(503)
			p.ExceptionSpecification()
		}

	}
	p.SetState(507)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CPP14ParserAlignas || _la == CPP14ParserLeftBracket {
		{
			p.SetState(506)
			p.AttributeSpecifierSeq()
		}

	}
	p.SetState(510)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CPP14ParserArrow {
		{
			p.SetState(509)
			p.TrailingReturnType()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPostfixExpressionContext is an interface to support dynamic dispatch.
type IPostfixExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PrimaryExpression() IPrimaryExpressionContext
	SimpleTypeSpecifier() ISimpleTypeSpecifierContext
	TypeNameSpecifier() ITypeNameSpecifierContext
	LeftParen() antlr.TerminalNode
	RightParen() antlr.TerminalNode
	BracedInitList() IBracedInitListContext
	ExpressionList() IExpressionListContext
	Less() antlr.TerminalNode
	TheTypeId() ITheTypeIdContext
	Greater() antlr.TerminalNode
	Expression() IExpressionContext
	Dynamic_cast() antlr.TerminalNode
	Static_cast() antlr.TerminalNode
	Reinterpret_cast() antlr.TerminalNode
	Const_cast() antlr.TerminalNode
	TypeIdOfTheTypeId() ITypeIdOfTheTypeIdContext
	PostfixExpression() IPostfixExpressionContext
	LeftBracket() antlr.TerminalNode
	RightBracket() antlr.TerminalNode
	Dot() antlr.TerminalNode
	Arrow() antlr.TerminalNode
	IdExpression() IIdExpressionContext
	PseudoDestructorName() IPseudoDestructorNameContext
	Template() antlr.TerminalNode
	PlusPlus() antlr.TerminalNode
	MinusMinus() antlr.TerminalNode

	// IsPostfixExpressionContext differentiates from other interfaces.
	IsPostfixExpressionContext()
}

type PostfixExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostfixExpressionContext() *PostfixExpressionContext {
	var p = new(PostfixExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_postfixExpression
	return p
}

func InitEmptyPostfixExpressionContext(p *PostfixExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_postfixExpression
}

func (*PostfixExpressionContext) IsPostfixExpressionContext() {}

func NewPostfixExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostfixExpressionContext {
	var p = new(PostfixExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_postfixExpression

	return p
}

func (s *PostfixExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PostfixExpressionContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *PostfixExpressionContext) SimpleTypeSpecifier() ISimpleTypeSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleTypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleTypeSpecifierContext)
}

func (s *PostfixExpressionContext) TypeNameSpecifier() ITypeNameSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameSpecifierContext)
}

func (s *PostfixExpressionContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CPP14ParserLeftParen, 0)
}

func (s *PostfixExpressionContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CPP14ParserRightParen, 0)
}

func (s *PostfixExpressionContext) BracedInitList() IBracedInitListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBracedInitListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBracedInitListContext)
}

func (s *PostfixExpressionContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *PostfixExpressionContext) Less() antlr.TerminalNode {
	return s.GetToken(CPP14ParserLess, 0)
}

func (s *PostfixExpressionContext) TheTypeId() ITheTypeIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITheTypeIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITheTypeIdContext)
}

func (s *PostfixExpressionContext) Greater() antlr.TerminalNode {
	return s.GetToken(CPP14ParserGreater, 0)
}

func (s *PostfixExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PostfixExpressionContext) Dynamic_cast() antlr.TerminalNode {
	return s.GetToken(CPP14ParserDynamic_cast, 0)
}

func (s *PostfixExpressionContext) Static_cast() antlr.TerminalNode {
	return s.GetToken(CPP14ParserStatic_cast, 0)
}

func (s *PostfixExpressionContext) Reinterpret_cast() antlr.TerminalNode {
	return s.GetToken(CPP14ParserReinterpret_cast, 0)
}

func (s *PostfixExpressionContext) Const_cast() antlr.TerminalNode {
	return s.GetToken(CPP14ParserConst_cast, 0)
}

func (s *PostfixExpressionContext) TypeIdOfTheTypeId() ITypeIdOfTheTypeIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdOfTheTypeIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdOfTheTypeIdContext)
}

func (s *PostfixExpressionContext) PostfixExpression() IPostfixExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixExpressionContext)
}

func (s *PostfixExpressionContext) LeftBracket() antlr.TerminalNode {
	return s.GetToken(CPP14ParserLeftBracket, 0)
}

func (s *PostfixExpressionContext) RightBracket() antlr.TerminalNode {
	return s.GetToken(CPP14ParserRightBracket, 0)
}

func (s *PostfixExpressionContext) Dot() antlr.TerminalNode {
	return s.GetToken(CPP14ParserDot, 0)
}

func (s *PostfixExpressionContext) Arrow() antlr.TerminalNode {
	return s.GetToken(CPP14ParserArrow, 0)
}

func (s *PostfixExpressionContext) IdExpression() IIdExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdExpressionContext)
}

func (s *PostfixExpressionContext) PseudoDestructorName() IPseudoDestructorNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPseudoDestructorNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPseudoDestructorNameContext)
}

func (s *PostfixExpressionContext) Template() antlr.TerminalNode {
	return s.GetToken(CPP14ParserTemplate, 0)
}

func (s *PostfixExpressionContext) PlusPlus() antlr.TerminalNode {
	return s.GetToken(CPP14ParserPlusPlus, 0)
}

func (s *PostfixExpressionContext) MinusMinus() antlr.TerminalNode {
	return s.GetToken(CPP14ParserMinusMinus, 0)
}

func (s *PostfixExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostfixExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterPostfixExpression(s)
	}
}

func (s *PostfixExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitPostfixExpression(s)
	}
}

func (s *PostfixExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitPostfixExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) PostfixExpression() (localctx IPostfixExpressionContext) {
	return p.postfixExpression(0)
}

func (p *CPP14Parser) postfixExpression(_p int) (localctx IPostfixExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewPostfixExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPostfixExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 30
	p.EnterRecursionRule(localctx, 30, CPP14ParserRULE_postfixExpression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(542)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 30, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(513)
			p.PrimaryExpression()
		}

	case 2:
		p.SetState(516)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case CPP14ParserAuto, CPP14ParserBool, CPP14ParserChar, CPP14ParserChar16, CPP14ParserChar32, CPP14ParserDecltype, CPP14ParserDouble, CPP14ParserFloat, CPP14ParserInt, CPP14ParserLong, CPP14ParserShort, CPP14ParserSigned, CPP14ParserUnsigned, CPP14ParserVoid, CPP14ParserWchar, CPP14ParserDoublecolon, CPP14ParserIdentifier:
			{
				p.SetState(514)
				p.SimpleTypeSpecifier()
			}

		case CPP14ParserTypename_:
			{
				p.SetState(515)
				p.TypeNameSpecifier()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(524)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case CPP14ParserLeftParen:
			{
				p.SetState(518)
				p.Match(CPP14ParserLeftParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(520)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8364979464334764286) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&4719772474400910417) != 0) || _la == CPP14ParserIdentifier {
				{
					p.SetState(519)
					p.ExpressionList()
				}

			}
			{
				p.SetState(522)
				p.Match(CPP14ParserRightParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case CPP14ParserLeftBrace:
			{
				p.SetState(523)
				p.BracedInitList()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 3:
		{
			p.SetState(526)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-24)) & ^0x3f) == 0 && ((int64(1)<<(_la-24))&2216203124865) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(527)
			p.Match(CPP14ParserLess)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(528)
			p.TheTypeId()
		}
		{
			p.SetState(529)
			p.Match(CPP14ParserGreater)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(530)
			p.Match(CPP14ParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(531)
			p.Expression()
		}
		{
			p.SetState(532)
			p.Match(CPP14ParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		{
			p.SetState(534)
			p.TypeIdOfTheTypeId()
		}
		{
			p.SetState(535)
			p.Match(CPP14ParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(538)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 29, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(536)
				p.Expression()
			}

		case 2:
			{
				p.SetState(537)
				p.TheTypeId()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(540)
			p.Match(CPP14ParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(571)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 36, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(569)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 35, p.GetParserRuleContext()) {
			case 1:
				localctx = NewPostfixExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CPP14ParserRULE_postfixExpression)
				p.SetState(544)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
					goto errorExit
				}
				{
					p.SetState(545)
					p.Match(CPP14ParserLeftBracket)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(548)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetTokenStream().LA(1) {
				case CPP14ParserIntegerLiteral, CPP14ParserCharacterLiteral, CPP14ParserFloatingLiteral, CPP14ParserStringLiteral, CPP14ParserBooleanLiteral, CPP14ParserPointerLiteral, CPP14ParserUserDefinedLiteral, CPP14ParserAlignof, CPP14ParserAuto, CPP14ParserBool, CPP14ParserChar, CPP14ParserChar16, CPP14ParserChar32, CPP14ParserConst_cast, CPP14ParserDecltype, CPP14ParserDelete, CPP14ParserDouble, CPP14ParserDynamic_cast, CPP14ParserFloat, CPP14ParserInt, CPP14ParserLong, CPP14ParserNew, CPP14ParserNoexcept, CPP14ParserOperator, CPP14ParserReinterpret_cast, CPP14ParserShort, CPP14ParserSigned, CPP14ParserSizeof, CPP14ParserStatic_cast, CPP14ParserThis, CPP14ParserThrow, CPP14ParserTypeid_, CPP14ParserTypename_, CPP14ParserUnsigned, CPP14ParserVoid, CPP14ParserWchar, CPP14ParserLeftParen, CPP14ParserLeftBracket, CPP14ParserPlus, CPP14ParserMinus, CPP14ParserStar, CPP14ParserAnd, CPP14ParserOr, CPP14ParserTilde, CPP14ParserNot, CPP14ParserPlusPlus, CPP14ParserMinusMinus, CPP14ParserDoublecolon, CPP14ParserIdentifier:
					{
						p.SetState(546)
						p.Expression()
					}

				case CPP14ParserLeftBrace:
					{
						p.SetState(547)
						p.BracedInitList()
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}
				{
					p.SetState(550)
					p.Match(CPP14ParserRightBracket)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 2:
				localctx = NewPostfixExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CPP14ParserRULE_postfixExpression)
				p.SetState(552)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
					goto errorExit
				}
				{
					p.SetState(553)
					p.Match(CPP14ParserLeftParen)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(555)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8364979464334764286) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&4719772474400910417) != 0) || _la == CPP14ParserIdentifier {
					{
						p.SetState(554)
						p.ExpressionList()
					}

				}
				{
					p.SetState(557)
					p.Match(CPP14ParserRightParen)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 3:
				localctx = NewPostfixExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CPP14ParserRULE_postfixExpression)
				p.SetState(558)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				{
					p.SetState(559)
					_la = p.GetTokenStream().LA(1)

					if !(_la == CPP14ParserArrow || _la == CPP14ParserDot) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				p.SetState(565)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 34, p.GetParserRuleContext()) {
				case 1:
					p.SetState(561)
					p.GetErrorHandler().Sync(p)
					if p.HasError() {
						goto errorExit
					}
					_la = p.GetTokenStream().LA(1)

					if _la == CPP14ParserTemplate {
						{
							p.SetState(560)
							p.Match(CPP14ParserTemplate)
							if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
							}
						}

					}
					{
						p.SetState(563)
						p.IdExpression()
					}

				case 2:
					{
						p.SetState(564)
						p.PseudoDestructorName()
					}

				case antlr.ATNInvalidAltNumber:
					goto errorExit
				}

			case 4:
				localctx = NewPostfixExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, CPP14ParserRULE_postfixExpression)
				p.SetState(567)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(568)
					_la = p.GetTokenStream().LA(1)

					if !(_la == CPP14ParserPlusPlus || _la == CPP14ParserMinusMinus) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(573)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 36, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeIdOfTheTypeIdContext is an interface to support dynamic dispatch.
type ITypeIdOfTheTypeIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Typeid_() antlr.TerminalNode

	// IsTypeIdOfTheTypeIdContext differentiates from other interfaces.
	IsTypeIdOfTheTypeIdContext()
}

type TypeIdOfTheTypeIdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeIdOfTheTypeIdContext() *TypeIdOfTheTypeIdContext {
	var p = new(TypeIdOfTheTypeIdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_typeIdOfTheTypeId
	return p
}

func InitEmptyTypeIdOfTheTypeIdContext(p *TypeIdOfTheTypeIdContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_typeIdOfTheTypeId
}

func (*TypeIdOfTheTypeIdContext) IsTypeIdOfTheTypeIdContext() {}

func NewTypeIdOfTheTypeIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeIdOfTheTypeIdContext {
	var p = new(TypeIdOfTheTypeIdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_typeIdOfTheTypeId

	return p
}

func (s *TypeIdOfTheTypeIdContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeIdOfTheTypeIdContext) Typeid_() antlr.TerminalNode {
	return s.GetToken(CPP14ParserTypeid_, 0)
}

func (s *TypeIdOfTheTypeIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeIdOfTheTypeIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeIdOfTheTypeIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterTypeIdOfTheTypeId(s)
	}
}

func (s *TypeIdOfTheTypeIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitTypeIdOfTheTypeId(s)
	}
}

func (s *TypeIdOfTheTypeIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitTypeIdOfTheTypeId(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) TypeIdOfTheTypeId() (localctx ITypeIdOfTheTypeIdContext) {
	localctx = NewTypeIdOfTheTypeIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, CPP14ParserRULE_typeIdOfTheTypeId)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(574)
		p.Match(CPP14ParserTypeid_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionListContext is an interface to support dynamic dispatch.
type IExpressionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	InitializerList() IInitializerListContext

	// IsExpressionListContext differentiates from other interfaces.
	IsExpressionListContext()
}

type ExpressionListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionListContext() *ExpressionListContext {
	var p = new(ExpressionListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_expressionList
	return p
}

func InitEmptyExpressionListContext(p *ExpressionListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_expressionList
}

func (*ExpressionListContext) IsExpressionListContext() {}

func NewExpressionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionListContext {
	var p = new(ExpressionListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_expressionList

	return p
}

func (s *ExpressionListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionListContext) InitializerList() IInitializerListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitializerListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitializerListContext)
}

func (s *ExpressionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterExpressionList(s)
	}
}

func (s *ExpressionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitExpressionList(s)
	}
}

func (s *ExpressionListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitExpressionList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) ExpressionList() (localctx IExpressionListContext) {
	localctx = NewExpressionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, CPP14ParserRULE_expressionList)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(576)
		p.InitializerList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPseudoDestructorNameContext is an interface to support dynamic dispatch.
type IPseudoDestructorNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Tilde() antlr.TerminalNode
	AllTheTypeName() []ITheTypeNameContext
	TheTypeName(i int) ITheTypeNameContext
	NestedNameSpecifier() INestedNameSpecifierContext
	Doublecolon() antlr.TerminalNode
	Template() antlr.TerminalNode
	SimpleTemplateId() ISimpleTemplateIdContext
	DecltypeSpecifier() IDecltypeSpecifierContext

	// IsPseudoDestructorNameContext differentiates from other interfaces.
	IsPseudoDestructorNameContext()
}

type PseudoDestructorNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPseudoDestructorNameContext() *PseudoDestructorNameContext {
	var p = new(PseudoDestructorNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_pseudoDestructorName
	return p
}

func InitEmptyPseudoDestructorNameContext(p *PseudoDestructorNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_pseudoDestructorName
}

func (*PseudoDestructorNameContext) IsPseudoDestructorNameContext() {}

func NewPseudoDestructorNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PseudoDestructorNameContext {
	var p = new(PseudoDestructorNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_pseudoDestructorName

	return p
}

func (s *PseudoDestructorNameContext) GetParser() antlr.Parser { return s.parser }

func (s *PseudoDestructorNameContext) Tilde() antlr.TerminalNode {
	return s.GetToken(CPP14ParserTilde, 0)
}

func (s *PseudoDestructorNameContext) AllTheTypeName() []ITheTypeNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITheTypeNameContext); ok {
			len++
		}
	}

	tst := make([]ITheTypeNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITheTypeNameContext); ok {
			tst[i] = t.(ITheTypeNameContext)
			i++
		}
	}

	return tst
}

func (s *PseudoDestructorNameContext) TheTypeName(i int) ITheTypeNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITheTypeNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITheTypeNameContext)
}

func (s *PseudoDestructorNameContext) NestedNameSpecifier() INestedNameSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedNameSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedNameSpecifierContext)
}

func (s *PseudoDestructorNameContext) Doublecolon() antlr.TerminalNode {
	return s.GetToken(CPP14ParserDoublecolon, 0)
}

func (s *PseudoDestructorNameContext) Template() antlr.TerminalNode {
	return s.GetToken(CPP14ParserTemplate, 0)
}

func (s *PseudoDestructorNameContext) SimpleTemplateId() ISimpleTemplateIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleTemplateIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleTemplateIdContext)
}

func (s *PseudoDestructorNameContext) DecltypeSpecifier() IDecltypeSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecltypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecltypeSpecifierContext)
}

func (s *PseudoDestructorNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PseudoDestructorNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PseudoDestructorNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterPseudoDestructorName(s)
	}
}

func (s *PseudoDestructorNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitPseudoDestructorName(s)
	}
}

func (s *PseudoDestructorNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitPseudoDestructorName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) PseudoDestructorName() (localctx IPseudoDestructorNameContext) {
	localctx = NewPseudoDestructorNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, CPP14ParserRULE_pseudoDestructorName)
	var _la int

	p.SetState(597)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 39, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(579)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 37, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(578)
				p.nestedNameSpecifier(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(584)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CPP14ParserIdentifier {
			{
				p.SetState(581)
				p.TheTypeName()
			}
			{
				p.SetState(582)
				p.Match(CPP14ParserDoublecolon)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(586)
			p.Match(CPP14ParserTilde)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(587)
			p.TheTypeName()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(588)
			p.nestedNameSpecifier(0)
		}
		{
			p.SetState(589)
			p.Match(CPP14ParserTemplate)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(590)
			p.SimpleTemplateId()
		}
		{
			p.SetState(591)
			p.Match(CPP14ParserDoublecolon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(592)
			p.Match(CPP14ParserTilde)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(593)
			p.TheTypeName()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(595)
			p.Match(CPP14ParserTilde)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(596)
			p.DecltypeSpecifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnaryExpressionContext is an interface to support dynamic dispatch.
type IUnaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PostfixExpression() IPostfixExpressionContext
	UnaryExpression() IUnaryExpressionContext
	PlusPlus() antlr.TerminalNode
	MinusMinus() antlr.TerminalNode
	UnaryOperator() IUnaryOperatorContext
	Sizeof() antlr.TerminalNode
	LeftParen() antlr.TerminalNode
	TheTypeId() ITheTypeIdContext
	RightParen() antlr.TerminalNode
	Ellipsis() antlr.TerminalNode
	Identifier() antlr.TerminalNode
	Alignof() antlr.TerminalNode
	NoExceptExpression() INoExceptExpressionContext
	NewExpression_() INewExpression_Context
	DeleteExpression() IDeleteExpressionContext

	// IsUnaryExpressionContext differentiates from other interfaces.
	IsUnaryExpressionContext()
}

type UnaryExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnaryExpressionContext() *UnaryExpressionContext {
	var p = new(UnaryExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_unaryExpression
	return p
}

func InitEmptyUnaryExpressionContext(p *UnaryExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_unaryExpression
}

func (*UnaryExpressionContext) IsUnaryExpressionContext() {}

func NewUnaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnaryExpressionContext {
	var p = new(UnaryExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_unaryExpression

	return p
}

func (s *UnaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *UnaryExpressionContext) PostfixExpression() IPostfixExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixExpressionContext)
}

func (s *UnaryExpressionContext) UnaryExpression() IUnaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryExpressionContext)
}

func (s *UnaryExpressionContext) PlusPlus() antlr.TerminalNode {
	return s.GetToken(CPP14ParserPlusPlus, 0)
}

func (s *UnaryExpressionContext) MinusMinus() antlr.TerminalNode {
	return s.GetToken(CPP14ParserMinusMinus, 0)
}

func (s *UnaryExpressionContext) UnaryOperator() IUnaryOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryOperatorContext)
}

func (s *UnaryExpressionContext) Sizeof() antlr.TerminalNode {
	return s.GetToken(CPP14ParserSizeof, 0)
}

func (s *UnaryExpressionContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CPP14ParserLeftParen, 0)
}

func (s *UnaryExpressionContext) TheTypeId() ITheTypeIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITheTypeIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITheTypeIdContext)
}

func (s *UnaryExpressionContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CPP14ParserRightParen, 0)
}

func (s *UnaryExpressionContext) Ellipsis() antlr.TerminalNode {
	return s.GetToken(CPP14ParserEllipsis, 0)
}

func (s *UnaryExpressionContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CPP14ParserIdentifier, 0)
}

func (s *UnaryExpressionContext) Alignof() antlr.TerminalNode {
	return s.GetToken(CPP14ParserAlignof, 0)
}

func (s *UnaryExpressionContext) NoExceptExpression() INoExceptExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INoExceptExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INoExceptExpressionContext)
}

func (s *UnaryExpressionContext) NewExpression_() INewExpression_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INewExpression_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INewExpression_Context)
}

func (s *UnaryExpressionContext) DeleteExpression() IDeleteExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeleteExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeleteExpressionContext)
}

func (s *UnaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnaryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterUnaryExpression(s)
	}
}

func (s *UnaryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitUnaryExpression(s)
	}
}

func (s *UnaryExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitUnaryExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) UnaryExpression() (localctx IUnaryExpressionContext) {
	localctx = NewUnaryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, CPP14ParserRULE_unaryExpression)
	p.SetState(626)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 42, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(599)
			p.postfixExpression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(604)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case CPP14ParserPlusPlus:
			{
				p.SetState(600)
				p.Match(CPP14ParserPlusPlus)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case CPP14ParserMinusMinus:
			{
				p.SetState(601)
				p.Match(CPP14ParserMinusMinus)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case CPP14ParserPlus, CPP14ParserMinus, CPP14ParserStar, CPP14ParserAnd, CPP14ParserOr, CPP14ParserTilde, CPP14ParserNot:
			{
				p.SetState(602)
				p.UnaryOperator()
			}

		case CPP14ParserSizeof:
			{
				p.SetState(603)
				p.Match(CPP14ParserSizeof)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(606)
			p.UnaryExpression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(607)
			p.Match(CPP14ParserSizeof)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(616)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case CPP14ParserLeftParen:
			{
				p.SetState(608)
				p.Match(CPP14ParserLeftParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(609)
				p.TheTypeId()
			}
			{
				p.SetState(610)
				p.Match(CPP14ParserRightParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case CPP14ParserEllipsis:
			{
				p.SetState(612)
				p.Match(CPP14ParserEllipsis)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(613)
				p.Match(CPP14ParserLeftParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(614)
				p.Match(CPP14ParserIdentifier)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(615)
				p.Match(CPP14ParserRightParen)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(618)
			p.Match(CPP14ParserAlignof)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(619)
			p.Match(CPP14ParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(620)
			p.TheTypeId()
		}
		{
			p.SetState(621)
			p.Match(CPP14ParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(623)
			p.NoExceptExpression()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(624)
			p.NewExpression_()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(625)
			p.DeleteExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnaryOperatorContext is an interface to support dynamic dispatch.
type IUnaryOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Or() antlr.TerminalNode
	Star() antlr.TerminalNode
	And() antlr.TerminalNode
	Plus() antlr.TerminalNode
	Tilde() antlr.TerminalNode
	Minus() antlr.TerminalNode
	Not() antlr.TerminalNode

	// IsUnaryOperatorContext differentiates from other interfaces.
	IsUnaryOperatorContext()
}

type UnaryOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnaryOperatorContext() *UnaryOperatorContext {
	var p = new(UnaryOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_unaryOperator
	return p
}

func InitEmptyUnaryOperatorContext(p *UnaryOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_unaryOperator
}

func (*UnaryOperatorContext) IsUnaryOperatorContext() {}

func NewUnaryOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnaryOperatorContext {
	var p = new(UnaryOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_unaryOperator

	return p
}

func (s *UnaryOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *UnaryOperatorContext) Or() antlr.TerminalNode {
	return s.GetToken(CPP14ParserOr, 0)
}

func (s *UnaryOperatorContext) Star() antlr.TerminalNode {
	return s.GetToken(CPP14ParserStar, 0)
}

func (s *UnaryOperatorContext) And() antlr.TerminalNode {
	return s.GetToken(CPP14ParserAnd, 0)
}

func (s *UnaryOperatorContext) Plus() antlr.TerminalNode {
	return s.GetToken(CPP14ParserPlus, 0)
}

func (s *UnaryOperatorContext) Tilde() antlr.TerminalNode {
	return s.GetToken(CPP14ParserTilde, 0)
}

func (s *UnaryOperatorContext) Minus() antlr.TerminalNode {
	return s.GetToken(CPP14ParserMinus, 0)
}

func (s *UnaryOperatorContext) Not() antlr.TerminalNode {
	return s.GetToken(CPP14ParserNot, 0)
}

func (s *UnaryOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnaryOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnaryOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterUnaryOperator(s)
	}
}

func (s *UnaryOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitUnaryOperator(s)
	}
}

func (s *UnaryOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitUnaryOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) UnaryOperator() (localctx IUnaryOperatorContext) {
	localctx = NewUnaryOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, CPP14ParserRULE_unaryOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(628)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-91)) & ^0x3f) == 0 && ((int64(1)<<(_la-91))&967) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INewExpression_Context is an interface to support dynamic dispatch.
type INewExpression_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	New() antlr.TerminalNode
	NewTypeId() INewTypeIdContext
	LeftParen() antlr.TerminalNode
	TheTypeId() ITheTypeIdContext
	RightParen() antlr.TerminalNode
	Doublecolon() antlr.TerminalNode
	NewPlacement() INewPlacementContext
	NewInitializer_() INewInitializer_Context

	// IsNewExpression_Context differentiates from other interfaces.
	IsNewExpression_Context()
}

type NewExpression_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNewExpression_Context() *NewExpression_Context {
	var p = new(NewExpression_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_newExpression_
	return p
}

func InitEmptyNewExpression_Context(p *NewExpression_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_newExpression_
}

func (*NewExpression_Context) IsNewExpression_Context() {}

func NewNewExpression_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NewExpression_Context {
	var p = new(NewExpression_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_newExpression_

	return p
}

func (s *NewExpression_Context) GetParser() antlr.Parser { return s.parser }

func (s *NewExpression_Context) New() antlr.TerminalNode {
	return s.GetToken(CPP14ParserNew, 0)
}

func (s *NewExpression_Context) NewTypeId() INewTypeIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INewTypeIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INewTypeIdContext)
}

func (s *NewExpression_Context) LeftParen() antlr.TerminalNode {
	return s.GetToken(CPP14ParserLeftParen, 0)
}

func (s *NewExpression_Context) TheTypeId() ITheTypeIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITheTypeIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITheTypeIdContext)
}

func (s *NewExpression_Context) RightParen() antlr.TerminalNode {
	return s.GetToken(CPP14ParserRightParen, 0)
}

func (s *NewExpression_Context) Doublecolon() antlr.TerminalNode {
	return s.GetToken(CPP14ParserDoublecolon, 0)
}

func (s *NewExpression_Context) NewPlacement() INewPlacementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INewPlacementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INewPlacementContext)
}

func (s *NewExpression_Context) NewInitializer_() INewInitializer_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INewInitializer_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INewInitializer_Context)
}

func (s *NewExpression_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NewExpression_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NewExpression_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterNewExpression_(s)
	}
}

func (s *NewExpression_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitNewExpression_(s)
	}
}

func (s *NewExpression_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitNewExpression_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) NewExpression_() (localctx INewExpression_Context) {
	localctx = NewNewExpression_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, CPP14ParserRULE_newExpression_)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(631)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CPP14ParserDoublecolon {
		{
			p.SetState(630)
			p.Match(CPP14ParserDoublecolon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(633)
		p.Match(CPP14ParserNew)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(635)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 44, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(634)
			p.NewPlacement()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(642)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CPP14ParserAuto, CPP14ParserBool, CPP14ParserChar, CPP14ParserChar16, CPP14ParserChar32, CPP14ParserClass, CPP14ParserConst, CPP14ParserDecltype, CPP14ParserDouble, CPP14ParserEnum, CPP14ParserFloat, CPP14ParserInt, CPP14ParserLong, CPP14ParserShort, CPP14ParserSigned, CPP14ParserStruct, CPP14ParserTypename_, CPP14ParserUnion, CPP14ParserUnsigned, CPP14ParserVoid, CPP14ParserVolatile, CPP14ParserWchar, CPP14ParserDoublecolon, CPP14ParserIdentifier:
		{
			p.SetState(637)
			p.NewTypeId()
		}

	case CPP14ParserLeftParen:
		{
			p.SetState(638)
			p.Match(CPP14ParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(639)
			p.TheTypeId()
		}
		{
			p.SetState(640)
			p.Match(CPP14ParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(645)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CPP14ParserLeftParen || _la == CPP14ParserLeftBrace {
		{
			p.SetState(644)
			p.NewInitializer_()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INewPlacementContext is an interface to support dynamic dispatch.
type INewPlacementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LeftParen() antlr.TerminalNode
	ExpressionList() IExpressionListContext
	RightParen() antlr.TerminalNode

	// IsNewPlacementContext differentiates from other interfaces.
	IsNewPlacementContext()
}

type NewPlacementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNewPlacementContext() *NewPlacementContext {
	var p = new(NewPlacementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_newPlacement
	return p
}

func InitEmptyNewPlacementContext(p *NewPlacementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_newPlacement
}

func (*NewPlacementContext) IsNewPlacementContext() {}

func NewNewPlacementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NewPlacementContext {
	var p = new(NewPlacementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_newPlacement

	return p
}

func (s *NewPlacementContext) GetParser() antlr.Parser { return s.parser }

func (s *NewPlacementContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CPP14ParserLeftParen, 0)
}

func (s *NewPlacementContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *NewPlacementContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CPP14ParserRightParen, 0)
}

func (s *NewPlacementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NewPlacementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NewPlacementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterNewPlacement(s)
	}
}

func (s *NewPlacementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitNewPlacement(s)
	}
}

func (s *NewPlacementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitNewPlacement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) NewPlacement() (localctx INewPlacementContext) {
	localctx = NewNewPlacementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, CPP14ParserRULE_newPlacement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(647)
		p.Match(CPP14ParserLeftParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(648)
		p.ExpressionList()
	}
	{
		p.SetState(649)
		p.Match(CPP14ParserRightParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INewTypeIdContext is an interface to support dynamic dispatch.
type INewTypeIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeSpecifierSeq() ITypeSpecifierSeqContext
	NewDeclarator_() INewDeclarator_Context

	// IsNewTypeIdContext differentiates from other interfaces.
	IsNewTypeIdContext()
}

type NewTypeIdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNewTypeIdContext() *NewTypeIdContext {
	var p = new(NewTypeIdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_newTypeId
	return p
}

func InitEmptyNewTypeIdContext(p *NewTypeIdContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_newTypeId
}

func (*NewTypeIdContext) IsNewTypeIdContext() {}

func NewNewTypeIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NewTypeIdContext {
	var p = new(NewTypeIdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_newTypeId

	return p
}

func (s *NewTypeIdContext) GetParser() antlr.Parser { return s.parser }

func (s *NewTypeIdContext) TypeSpecifierSeq() ITypeSpecifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSpecifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSpecifierSeqContext)
}

func (s *NewTypeIdContext) NewDeclarator_() INewDeclarator_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INewDeclarator_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INewDeclarator_Context)
}

func (s *NewTypeIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NewTypeIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NewTypeIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterNewTypeId(s)
	}
}

func (s *NewTypeIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitNewTypeId(s)
	}
}

func (s *NewTypeIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitNewTypeId(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) NewTypeId() (localctx INewTypeIdContext) {
	localctx = NewNewTypeIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, CPP14ParserRULE_newTypeId)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(651)
		p.TypeSpecifierSeq()
	}
	p.SetState(653)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 47, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(652)
			p.NewDeclarator_()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INewDeclarator_Context is an interface to support dynamic dispatch.
type INewDeclarator_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PointerOperator() IPointerOperatorContext
	NewDeclarator_() INewDeclarator_Context
	NoPointerNewDeclarator() INoPointerNewDeclaratorContext

	// IsNewDeclarator_Context differentiates from other interfaces.
	IsNewDeclarator_Context()
}

type NewDeclarator_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNewDeclarator_Context() *NewDeclarator_Context {
	var p = new(NewDeclarator_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_newDeclarator_
	return p
}

func InitEmptyNewDeclarator_Context(p *NewDeclarator_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_newDeclarator_
}

func (*NewDeclarator_Context) IsNewDeclarator_Context() {}

func NewNewDeclarator_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NewDeclarator_Context {
	var p = new(NewDeclarator_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_newDeclarator_

	return p
}

func (s *NewDeclarator_Context) GetParser() antlr.Parser { return s.parser }

func (s *NewDeclarator_Context) PointerOperator() IPointerOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPointerOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPointerOperatorContext)
}

func (s *NewDeclarator_Context) NewDeclarator_() INewDeclarator_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INewDeclarator_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INewDeclarator_Context)
}

func (s *NewDeclarator_Context) NoPointerNewDeclarator() INoPointerNewDeclaratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INoPointerNewDeclaratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INoPointerNewDeclaratorContext)
}

func (s *NewDeclarator_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NewDeclarator_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NewDeclarator_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterNewDeclarator_(s)
	}
}

func (s *NewDeclarator_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitNewDeclarator_(s)
	}
}

func (s *NewDeclarator_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitNewDeclarator_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) NewDeclarator_() (localctx INewDeclarator_Context) {
	localctx = NewNewDeclarator_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, CPP14ParserRULE_newDeclarator_)
	p.SetState(660)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CPP14ParserDecltype, CPP14ParserStar, CPP14ParserAnd, CPP14ParserAndAnd, CPP14ParserDoublecolon, CPP14ParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(655)
			p.PointerOperator()
		}
		p.SetState(657)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 48, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(656)
				p.NewDeclarator_()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case CPP14ParserLeftBracket:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(659)
			p.noPointerNewDeclarator(0)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INoPointerNewDeclaratorContext is an interface to support dynamic dispatch.
type INoPointerNewDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LeftBracket() antlr.TerminalNode
	Expression() IExpressionContext
	RightBracket() antlr.TerminalNode
	AttributeSpecifierSeq() IAttributeSpecifierSeqContext
	NoPointerNewDeclarator() INoPointerNewDeclaratorContext
	ConstantExpression() IConstantExpressionContext

	// IsNoPointerNewDeclaratorContext differentiates from other interfaces.
	IsNoPointerNewDeclaratorContext()
}

type NoPointerNewDeclaratorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNoPointerNewDeclaratorContext() *NoPointerNewDeclaratorContext {
	var p = new(NoPointerNewDeclaratorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_noPointerNewDeclarator
	return p
}

func InitEmptyNoPointerNewDeclaratorContext(p *NoPointerNewDeclaratorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_noPointerNewDeclarator
}

func (*NoPointerNewDeclaratorContext) IsNoPointerNewDeclaratorContext() {}

func NewNoPointerNewDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NoPointerNewDeclaratorContext {
	var p = new(NoPointerNewDeclaratorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_noPointerNewDeclarator

	return p
}

func (s *NoPointerNewDeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *NoPointerNewDeclaratorContext) LeftBracket() antlr.TerminalNode {
	return s.GetToken(CPP14ParserLeftBracket, 0)
}

func (s *NoPointerNewDeclaratorContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NoPointerNewDeclaratorContext) RightBracket() antlr.TerminalNode {
	return s.GetToken(CPP14ParserRightBracket, 0)
}

func (s *NoPointerNewDeclaratorContext) AttributeSpecifierSeq() IAttributeSpecifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSpecifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSpecifierSeqContext)
}

func (s *NoPointerNewDeclaratorContext) NoPointerNewDeclarator() INoPointerNewDeclaratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INoPointerNewDeclaratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INoPointerNewDeclaratorContext)
}

func (s *NoPointerNewDeclaratorContext) ConstantExpression() IConstantExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantExpressionContext)
}

func (s *NoPointerNewDeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NoPointerNewDeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NoPointerNewDeclaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterNoPointerNewDeclarator(s)
	}
}

func (s *NoPointerNewDeclaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitNoPointerNewDeclarator(s)
	}
}

func (s *NoPointerNewDeclaratorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitNoPointerNewDeclarator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) NoPointerNewDeclarator() (localctx INoPointerNewDeclaratorContext) {
	return p.noPointerNewDeclarator(0)
}

func (p *CPP14Parser) noPointerNewDeclarator(_p int) (localctx INoPointerNewDeclaratorContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewNoPointerNewDeclaratorContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx INoPointerNewDeclaratorContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 50
	p.EnterRecursionRule(localctx, 50, CPP14ParserRULE_noPointerNewDeclarator, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(663)
		p.Match(CPP14ParserLeftBracket)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(664)
		p.Expression()
	}
	{
		p.SetState(665)
		p.Match(CPP14ParserRightBracket)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(667)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 50, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(666)
			p.AttributeSpecifierSeq()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(678)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewNoPointerNewDeclaratorContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, CPP14ParserRULE_noPointerNewDeclarator)
			p.SetState(669)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				goto errorExit
			}
			{
				p.SetState(670)
				p.Match(CPP14ParserLeftBracket)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(671)
				p.ConstantExpression()
			}
			{
				p.SetState(672)
				p.Match(CPP14ParserRightBracket)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(674)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 51, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(673)
					p.AttributeSpecifierSeq()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		}
		p.SetState(680)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INewInitializer_Context is an interface to support dynamic dispatch.
type INewInitializer_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LeftParen() antlr.TerminalNode
	RightParen() antlr.TerminalNode
	ExpressionList() IExpressionListContext
	BracedInitList() IBracedInitListContext

	// IsNewInitializer_Context differentiates from other interfaces.
	IsNewInitializer_Context()
}

type NewInitializer_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNewInitializer_Context() *NewInitializer_Context {
	var p = new(NewInitializer_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_newInitializer_
	return p
}

func InitEmptyNewInitializer_Context(p *NewInitializer_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_newInitializer_
}

func (*NewInitializer_Context) IsNewInitializer_Context() {}

func NewNewInitializer_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NewInitializer_Context {
	var p = new(NewInitializer_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_newInitializer_

	return p
}

func (s *NewInitializer_Context) GetParser() antlr.Parser { return s.parser }

func (s *NewInitializer_Context) LeftParen() antlr.TerminalNode {
	return s.GetToken(CPP14ParserLeftParen, 0)
}

func (s *NewInitializer_Context) RightParen() antlr.TerminalNode {
	return s.GetToken(CPP14ParserRightParen, 0)
}

func (s *NewInitializer_Context) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *NewInitializer_Context) BracedInitList() IBracedInitListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBracedInitListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBracedInitListContext)
}

func (s *NewInitializer_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NewInitializer_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NewInitializer_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterNewInitializer_(s)
	}
}

func (s *NewInitializer_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitNewInitializer_(s)
	}
}

func (s *NewInitializer_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitNewInitializer_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) NewInitializer_() (localctx INewInitializer_Context) {
	localctx = NewNewInitializer_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, CPP14ParserRULE_newInitializer_)
	var _la int

	p.SetState(687)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CPP14ParserLeftParen:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(681)
			p.Match(CPP14ParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(683)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8364979464334764286) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&4719772474400910417) != 0) || _la == CPP14ParserIdentifier {
			{
				p.SetState(682)
				p.ExpressionList()
			}

		}
		{
			p.SetState(685)
			p.Match(CPP14ParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case CPP14ParserLeftBrace:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(686)
			p.BracedInitList()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeleteExpressionContext is an interface to support dynamic dispatch.
type IDeleteExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Delete() antlr.TerminalNode
	CastExpression() ICastExpressionContext
	Doublecolon() antlr.TerminalNode
	LeftBracket() antlr.TerminalNode
	RightBracket() antlr.TerminalNode

	// IsDeleteExpressionContext differentiates from other interfaces.
	IsDeleteExpressionContext()
}

type DeleteExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeleteExpressionContext() *DeleteExpressionContext {
	var p = new(DeleteExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_deleteExpression
	return p
}

func InitEmptyDeleteExpressionContext(p *DeleteExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_deleteExpression
}

func (*DeleteExpressionContext) IsDeleteExpressionContext() {}

func NewDeleteExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeleteExpressionContext {
	var p = new(DeleteExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_deleteExpression

	return p
}

func (s *DeleteExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *DeleteExpressionContext) Delete() antlr.TerminalNode {
	return s.GetToken(CPP14ParserDelete, 0)
}

func (s *DeleteExpressionContext) CastExpression() ICastExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastExpressionContext)
}

func (s *DeleteExpressionContext) Doublecolon() antlr.TerminalNode {
	return s.GetToken(CPP14ParserDoublecolon, 0)
}

func (s *DeleteExpressionContext) LeftBracket() antlr.TerminalNode {
	return s.GetToken(CPP14ParserLeftBracket, 0)
}

func (s *DeleteExpressionContext) RightBracket() antlr.TerminalNode {
	return s.GetToken(CPP14ParserRightBracket, 0)
}

func (s *DeleteExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeleteExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterDeleteExpression(s)
	}
}

func (s *DeleteExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitDeleteExpression(s)
	}
}

func (s *DeleteExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitDeleteExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) DeleteExpression() (localctx IDeleteExpressionContext) {
	localctx = NewDeleteExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, CPP14ParserRULE_deleteExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(690)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CPP14ParserDoublecolon {
		{
			p.SetState(689)
			p.Match(CPP14ParserDoublecolon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(692)
		p.Match(CPP14ParserDelete)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(695)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 56, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(693)
			p.Match(CPP14ParserLeftBracket)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(694)
			p.Match(CPP14ParserRightBracket)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(697)
		p.CastExpression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INoExceptExpressionContext is an interface to support dynamic dispatch.
type INoExceptExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Noexcept() antlr.TerminalNode
	LeftParen() antlr.TerminalNode
	Expression() IExpressionContext
	RightParen() antlr.TerminalNode

	// IsNoExceptExpressionContext differentiates from other interfaces.
	IsNoExceptExpressionContext()
}

type NoExceptExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNoExceptExpressionContext() *NoExceptExpressionContext {
	var p = new(NoExceptExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_noExceptExpression
	return p
}

func InitEmptyNoExceptExpressionContext(p *NoExceptExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_noExceptExpression
}

func (*NoExceptExpressionContext) IsNoExceptExpressionContext() {}

func NewNoExceptExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NoExceptExpressionContext {
	var p = new(NoExceptExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_noExceptExpression

	return p
}

func (s *NoExceptExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *NoExceptExpressionContext) Noexcept() antlr.TerminalNode {
	return s.GetToken(CPP14ParserNoexcept, 0)
}

func (s *NoExceptExpressionContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CPP14ParserLeftParen, 0)
}

func (s *NoExceptExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NoExceptExpressionContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CPP14ParserRightParen, 0)
}

func (s *NoExceptExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NoExceptExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NoExceptExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterNoExceptExpression(s)
	}
}

func (s *NoExceptExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitNoExceptExpression(s)
	}
}

func (s *NoExceptExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitNoExceptExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) NoExceptExpression() (localctx INoExceptExpressionContext) {
	localctx = NewNoExceptExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, CPP14ParserRULE_noExceptExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(699)
		p.Match(CPP14ParserNoexcept)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(700)
		p.Match(CPP14ParserLeftParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(701)
		p.Expression()
	}
	{
		p.SetState(702)
		p.Match(CPP14ParserRightParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICastExpressionContext is an interface to support dynamic dispatch.
type ICastExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UnaryExpression() IUnaryExpressionContext
	LeftParen() antlr.TerminalNode
	TheTypeId() ITheTypeIdContext
	RightParen() antlr.TerminalNode
	CastExpression() ICastExpressionContext

	// IsCastExpressionContext differentiates from other interfaces.
	IsCastExpressionContext()
}

type CastExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCastExpressionContext() *CastExpressionContext {
	var p = new(CastExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_castExpression
	return p
}

func InitEmptyCastExpressionContext(p *CastExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_castExpression
}

func (*CastExpressionContext) IsCastExpressionContext() {}

func NewCastExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CastExpressionContext {
	var p = new(CastExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_castExpression

	return p
}

func (s *CastExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *CastExpressionContext) UnaryExpression() IUnaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnaryExpressionContext)
}

func (s *CastExpressionContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CPP14ParserLeftParen, 0)
}

func (s *CastExpressionContext) TheTypeId() ITheTypeIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITheTypeIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITheTypeIdContext)
}

func (s *CastExpressionContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CPP14ParserRightParen, 0)
}

func (s *CastExpressionContext) CastExpression() ICastExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastExpressionContext)
}

func (s *CastExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CastExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterCastExpression(s)
	}
}

func (s *CastExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitCastExpression(s)
	}
}

func (s *CastExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitCastExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) CastExpression() (localctx ICastExpressionContext) {
	localctx = NewCastExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, CPP14ParserRULE_castExpression)
	p.SetState(710)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 57, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(704)
			p.UnaryExpression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(705)
			p.Match(CPP14ParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(706)
			p.TheTypeId()
		}
		{
			p.SetState(707)
			p.Match(CPP14ParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(708)
			p.CastExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPointerMemberExpressionContext is an interface to support dynamic dispatch.
type IPointerMemberExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCastExpression() []ICastExpressionContext
	CastExpression(i int) ICastExpressionContext
	AllDotStar() []antlr.TerminalNode
	DotStar(i int) antlr.TerminalNode
	AllArrowStar() []antlr.TerminalNode
	ArrowStar(i int) antlr.TerminalNode

	// IsPointerMemberExpressionContext differentiates from other interfaces.
	IsPointerMemberExpressionContext()
}

type PointerMemberExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPointerMemberExpressionContext() *PointerMemberExpressionContext {
	var p = new(PointerMemberExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_pointerMemberExpression
	return p
}

func InitEmptyPointerMemberExpressionContext(p *PointerMemberExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_pointerMemberExpression
}

func (*PointerMemberExpressionContext) IsPointerMemberExpressionContext() {}

func NewPointerMemberExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PointerMemberExpressionContext {
	var p = new(PointerMemberExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_pointerMemberExpression

	return p
}

func (s *PointerMemberExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PointerMemberExpressionContext) AllCastExpression() []ICastExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICastExpressionContext); ok {
			len++
		}
	}

	tst := make([]ICastExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICastExpressionContext); ok {
			tst[i] = t.(ICastExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PointerMemberExpressionContext) CastExpression(i int) ICastExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastExpressionContext)
}

func (s *PointerMemberExpressionContext) AllDotStar() []antlr.TerminalNode {
	return s.GetTokens(CPP14ParserDotStar)
}

func (s *PointerMemberExpressionContext) DotStar(i int) antlr.TerminalNode {
	return s.GetToken(CPP14ParserDotStar, i)
}

func (s *PointerMemberExpressionContext) AllArrowStar() []antlr.TerminalNode {
	return s.GetTokens(CPP14ParserArrowStar)
}

func (s *PointerMemberExpressionContext) ArrowStar(i int) antlr.TerminalNode {
	return s.GetToken(CPP14ParserArrowStar, i)
}

func (s *PointerMemberExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PointerMemberExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PointerMemberExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterPointerMemberExpression(s)
	}
}

func (s *PointerMemberExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitPointerMemberExpression(s)
	}
}

func (s *PointerMemberExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitPointerMemberExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) PointerMemberExpression() (localctx IPointerMemberExpressionContext) {
	localctx = NewPointerMemberExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, CPP14ParserRULE_pointerMemberExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(712)
		p.CastExpression()
	}
	p.SetState(717)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CPP14ParserArrowStar || _la == CPP14ParserDotStar {
		{
			p.SetState(713)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CPP14ParserArrowStar || _la == CPP14ParserDotStar) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(714)
			p.CastExpression()
		}

		p.SetState(719)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiplicativeExpressionContext is an interface to support dynamic dispatch.
type IMultiplicativeExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPointerMemberExpression() []IPointerMemberExpressionContext
	PointerMemberExpression(i int) IPointerMemberExpressionContext
	AllStar() []antlr.TerminalNode
	Star(i int) antlr.TerminalNode
	AllDiv() []antlr.TerminalNode
	Div(i int) antlr.TerminalNode
	AllMod() []antlr.TerminalNode
	Mod(i int) antlr.TerminalNode

	// IsMultiplicativeExpressionContext differentiates from other interfaces.
	IsMultiplicativeExpressionContext()
}

type MultiplicativeExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplicativeExpressionContext() *MultiplicativeExpressionContext {
	var p = new(MultiplicativeExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_multiplicativeExpression
	return p
}

func InitEmptyMultiplicativeExpressionContext(p *MultiplicativeExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_multiplicativeExpression
}

func (*MultiplicativeExpressionContext) IsMultiplicativeExpressionContext() {}

func NewMultiplicativeExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplicativeExpressionContext {
	var p = new(MultiplicativeExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_multiplicativeExpression

	return p
}

func (s *MultiplicativeExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplicativeExpressionContext) AllPointerMemberExpression() []IPointerMemberExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPointerMemberExpressionContext); ok {
			len++
		}
	}

	tst := make([]IPointerMemberExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPointerMemberExpressionContext); ok {
			tst[i] = t.(IPointerMemberExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MultiplicativeExpressionContext) PointerMemberExpression(i int) IPointerMemberExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPointerMemberExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPointerMemberExpressionContext)
}

func (s *MultiplicativeExpressionContext) AllStar() []antlr.TerminalNode {
	return s.GetTokens(CPP14ParserStar)
}

func (s *MultiplicativeExpressionContext) Star(i int) antlr.TerminalNode {
	return s.GetToken(CPP14ParserStar, i)
}

func (s *MultiplicativeExpressionContext) AllDiv() []antlr.TerminalNode {
	return s.GetTokens(CPP14ParserDiv)
}

func (s *MultiplicativeExpressionContext) Div(i int) antlr.TerminalNode {
	return s.GetToken(CPP14ParserDiv, i)
}

func (s *MultiplicativeExpressionContext) AllMod() []antlr.TerminalNode {
	return s.GetTokens(CPP14ParserMod)
}

func (s *MultiplicativeExpressionContext) Mod(i int) antlr.TerminalNode {
	return s.GetToken(CPP14ParserMod, i)
}

func (s *MultiplicativeExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplicativeExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplicativeExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterMultiplicativeExpression(s)
	}
}

func (s *MultiplicativeExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitMultiplicativeExpression(s)
	}

	
}

func (s *MultiplicativeExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitMultiplicativeExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) MultiplicativeExpression() (localctx IMultiplicativeExpressionContext) {
	localctx = NewMultiplicativeExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, CPP14ParserRULE_multiplicativeExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(720)
		p.PointerMemberExpression()
	}
	p.SetState(725)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-93)) & ^0x3f) == 0 && ((int64(1)<<(_la-93))&7) != 0 {
		{
			p.SetState(721)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-93)) & ^0x3f) == 0 && ((int64(1)<<(_la-93))&7) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(722)
			p.PointerMemberExpression()
		}

		p.SetState(727)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdditiveExpressionContext is an interface to support dynamic dispatch.
type IAdditiveExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMultiplicativeExpression() []IMultiplicativeExpressionContext
	MultiplicativeExpression(i int) IMultiplicativeExpressionContext
	AllPlus() []antlr.TerminalNode
	Plus(i int) antlr.TerminalNode
	AllMinus() []antlr.TerminalNode
	Minus(i int) antlr.TerminalNode

	// IsAdditiveExpressionContext differentiates from other interfaces.
	IsAdditiveExpressionContext()
}

type AdditiveExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdditiveExpressionContext() *AdditiveExpressionContext {
	var p = new(AdditiveExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_additiveExpression
	return p
}

func InitEmptyAdditiveExpressionContext(p *AdditiveExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_additiveExpression
}

func (*AdditiveExpressionContext) IsAdditiveExpressionContext() {}

func NewAdditiveExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdditiveExpressionContext {
	var p = new(AdditiveExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_additiveExpression

	return p
}

func (s *AdditiveExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AdditiveExpressionContext) AllMultiplicativeExpression() []IMultiplicativeExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultiplicativeExpressionContext); ok {
			len++
		}
	}

	tst := make([]IMultiplicativeExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultiplicativeExpressionContext); ok {
			tst[i] = t.(IMultiplicativeExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AdditiveExpressionContext) MultiplicativeExpression(i int) IMultiplicativeExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiplicativeExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiplicativeExpressionContext)
}

func (s *AdditiveExpressionContext) AllPlus() []antlr.TerminalNode {
	return s.GetTokens(CPP14ParserPlus)
}

func (s *AdditiveExpressionContext) Plus(i int) antlr.TerminalNode {
	return s.GetToken(CPP14ParserPlus, i)
}

func (s *AdditiveExpressionContext) AllMinus() []antlr.TerminalNode {
	return s.GetTokens(CPP14ParserMinus)
}

func (s *AdditiveExpressionContext) Minus(i int) antlr.TerminalNode {
	return s.GetToken(CPP14ParserMinus, i)
}

func (s *AdditiveExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditiveExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdditiveExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterAdditiveExpression(s)
	}
}

func (s *AdditiveExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitAdditiveExpression(s)
	}
}

func (s *AdditiveExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitAdditiveExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) AdditiveExpression() (localctx IAdditiveExpressionContext) {
	localctx = NewAdditiveExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, CPP14ParserRULE_additiveExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(728)
		p.MultiplicativeExpression()
	}
	p.SetState(733)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CPP14ParserPlus || _la == CPP14ParserMinus {
		{
			p.SetState(729)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CPP14ParserPlus || _la == CPP14ParserMinus) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(730)
			p.MultiplicativeExpression()
		}

		p.SetState(735)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShiftExpressionContext is an interface to support dynamic dispatch.
type IShiftExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAdditiveExpression() []IAdditiveExpressionContext
	AdditiveExpression(i int) IAdditiveExpressionContext
	AllShiftOperator() []IShiftOperatorContext
	ShiftOperator(i int) IShiftOperatorContext

	// IsShiftExpressionContext differentiates from other interfaces.
	IsShiftExpressionContext()
}

type ShiftExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShiftExpressionContext() *ShiftExpressionContext {
	var p = new(ShiftExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_shiftExpression
	return p
}

func InitEmptyShiftExpressionContext(p *ShiftExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_shiftExpression
}

func (*ShiftExpressionContext) IsShiftExpressionContext() {}

func NewShiftExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShiftExpressionContext {
	var p = new(ShiftExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_shiftExpression

	return p
}

func (s *ShiftExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ShiftExpressionContext) AllAdditiveExpression() []IAdditiveExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAdditiveExpressionContext); ok {
			len++
		}
	}

	tst := make([]IAdditiveExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAdditiveExpressionContext); ok {
			tst[i] = t.(IAdditiveExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ShiftExpressionContext) AdditiveExpression(i int) IAdditiveExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdditiveExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdditiveExpressionContext)
}

func (s *ShiftExpressionContext) AllShiftOperator() []IShiftOperatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IShiftOperatorContext); ok {
			len++
		}
	}

	tst := make([]IShiftOperatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IShiftOperatorContext); ok {
			tst[i] = t.(IShiftOperatorContext)
			i++
		}
	}

	return tst
}

func (s *ShiftExpressionContext) ShiftOperator(i int) IShiftOperatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShiftOperatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShiftOperatorContext)
}

func (s *ShiftExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShiftExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShiftExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterShiftExpression(s)
	}
}

func (s *ShiftExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitShiftExpression(s)
	}
}

func (s *ShiftExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitShiftExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) ShiftExpression() (localctx IShiftExpressionContext) {
	localctx = NewShiftExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, CPP14ParserRULE_shiftExpression)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(736)
		p.AdditiveExpression()
	}
	p.SetState(742)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 61, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(737)
				p.ShiftOperator()
			}
			{
				p.SetState(738)
				p.AdditiveExpression()
			}

		}
		p.SetState(744)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 61, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShiftOperatorContext is an interface to support dynamic dispatch.
type IShiftOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllGreater() []antlr.TerminalNode
	Greater(i int) antlr.TerminalNode
	AllLess() []antlr.TerminalNode
	Less(i int) antlr.TerminalNode

	// IsShiftOperatorContext differentiates from other interfaces.
	IsShiftOperatorContext()
}

type ShiftOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShiftOperatorContext() *ShiftOperatorContext {
	var p = new(ShiftOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_shiftOperator
	return p
}

func InitEmptyShiftOperatorContext(p *ShiftOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_shiftOperator
}

func (*ShiftOperatorContext) IsShiftOperatorContext() {}

func NewShiftOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShiftOperatorContext {
	var p = new(ShiftOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_shiftOperator

	return p
}

func (s *ShiftOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ShiftOperatorContext) AllGreater() []antlr.TerminalNode {
	return s.GetTokens(CPP14ParserGreater)
}

func (s *ShiftOperatorContext) Greater(i int) antlr.TerminalNode {
	return s.GetToken(CPP14ParserGreater, i)
}

func (s *ShiftOperatorContext) AllLess() []antlr.TerminalNode {
	return s.GetTokens(CPP14ParserLess)
}

func (s *ShiftOperatorContext) Less(i int) antlr.TerminalNode {
	return s.GetToken(CPP14ParserLess, i)
}

func (s *ShiftOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShiftOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShiftOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterShiftOperator(s)
	}
}

func (s *ShiftOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitShiftOperator(s)
	}
}

func (s *ShiftOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitShiftOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) ShiftOperator() (localctx IShiftOperatorContext) {
	localctx = NewShiftOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, CPP14ParserRULE_shiftOperator)
	p.SetState(749)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CPP14ParserGreater:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(745)
			p.Match(CPP14ParserGreater)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(746)
			p.Match(CPP14ParserGreater)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case CPP14ParserLess:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(747)
			p.Match(CPP14ParserLess)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(748)
			p.Match(CPP14ParserLess)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationalExpressionContext is an interface to support dynamic dispatch.
type IRelationalExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllShiftExpression() []IShiftExpressionContext
	ShiftExpression(i int) IShiftExpressionContext
	AllLess() []antlr.TerminalNode
	Less(i int) antlr.TerminalNode
	AllGreater() []antlr.TerminalNode
	Greater(i int) antlr.TerminalNode
	AllLessEqual() []antlr.TerminalNode
	LessEqual(i int) antlr.TerminalNode
	AllGreaterEqual() []antlr.TerminalNode
	GreaterEqual(i int) antlr.TerminalNode

	// IsRelationalExpressionContext differentiates from other interfaces.
	IsRelationalExpressionContext()
}

type RelationalExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationalExpressionContext() *RelationalExpressionContext {
	var p = new(RelationalExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_relationalExpression
	return p
}

func InitEmptyRelationalExpressionContext(p *RelationalExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_relationalExpression
}

func (*RelationalExpressionContext) IsRelationalExpressionContext() {}

func NewRelationalExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationalExpressionContext {
	var p = new(RelationalExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_relationalExpression

	return p
}

func (s *RelationalExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationalExpressionContext) AllShiftExpression() []IShiftExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IShiftExpressionContext); ok {
			len++
		}
	}

	tst := make([]IShiftExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IShiftExpressionContext); ok {
			tst[i] = t.(IShiftExpressionContext)
			i++
		}
	}

	return tst
}

func (s *RelationalExpressionContext) ShiftExpression(i int) IShiftExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShiftExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShiftExpressionContext)
}

func (s *RelationalExpressionContext) AllLess() []antlr.TerminalNode {
	return s.GetTokens(CPP14ParserLess)
}

func (s *RelationalExpressionContext) Less(i int) antlr.TerminalNode {
	return s.GetToken(CPP14ParserLess, i)
}

func (s *RelationalExpressionContext) AllGreater() []antlr.TerminalNode {
	return s.GetTokens(CPP14ParserGreater)
}

func (s *RelationalExpressionContext) Greater(i int) antlr.TerminalNode {
	return s.GetToken(CPP14ParserGreater, i)
}

func (s *RelationalExpressionContext) AllLessEqual() []antlr.TerminalNode {
	return s.GetTokens(CPP14ParserLessEqual)
}

func (s *RelationalExpressionContext) LessEqual(i int) antlr.TerminalNode {
	return s.GetToken(CPP14ParserLessEqual, i)
}

func (s *RelationalExpressionContext) AllGreaterEqual() []antlr.TerminalNode {
	return s.GetTokens(CPP14ParserGreaterEqual)
}

func (s *RelationalExpressionContext) GreaterEqual(i int) antlr.TerminalNode {
	return s.GetToken(CPP14ParserGreaterEqual, i)
}

func (s *RelationalExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationalExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationalExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterRelationalExpression(s)
	}
}

func (s *RelationalExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitRelationalExpression(s)
	}
}

func (s *RelationalExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitRelationalExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) RelationalExpression() (localctx IRelationalExpressionContext) {
	localctx = NewRelationalExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, CPP14ParserRULE_relationalExpression)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(751)
		p.ShiftExpression()
	}
	p.SetState(756)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 63, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(752)
				_la = p.GetTokenStream().LA(1)

				if !((int64((_la-102)) & ^0x3f) == 0 && ((int64(1)<<(_la-102))&49155) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(753)
				p.ShiftExpression()
			}

		}
		p.SetState(758)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 63, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEqualityExpressionContext is an interface to support dynamic dispatch.
type IEqualityExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRelationalExpression() []IRelationalExpressionContext
	RelationalExpression(i int) IRelationalExpressionContext
	AllEqual() []antlr.TerminalNode
	Equal(i int) antlr.TerminalNode
	AllNotEqual() []antlr.TerminalNode
	NotEqual(i int) antlr.TerminalNode

	// IsEqualityExpressionContext differentiates from other interfaces.
	IsEqualityExpressionContext()
}

type EqualityExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEqualityExpressionContext() *EqualityExpressionContext {
	var p = new(EqualityExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_equalityExpression
	return p
}

func InitEmptyEqualityExpressionContext(p *EqualityExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_equalityExpression
}

func (*EqualityExpressionContext) IsEqualityExpressionContext() {}

func NewEqualityExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EqualityExpressionContext {
	var p = new(EqualityExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_equalityExpression

	return p
}

func (s *EqualityExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *EqualityExpressionContext) AllRelationalExpression() []IRelationalExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRelationalExpressionContext); ok {
			len++
		}
	}

	tst := make([]IRelationalExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRelationalExpressionContext); ok {
			tst[i] = t.(IRelationalExpressionContext)
			i++
		}
	}

	return tst
}

func (s *EqualityExpressionContext) RelationalExpression(i int) IRelationalExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationalExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationalExpressionContext)
}

func (s *EqualityExpressionContext) AllEqual() []antlr.TerminalNode {
	return s.GetTokens(CPP14ParserEqual)
}

func (s *EqualityExpressionContext) Equal(i int) antlr.TerminalNode {
	return s.GetToken(CPP14ParserEqual, i)
}

func (s *EqualityExpressionContext) AllNotEqual() []antlr.TerminalNode {
	return s.GetTokens(CPP14ParserNotEqual)
}

func (s *EqualityExpressionContext) NotEqual(i int) antlr.TerminalNode {
	return s.GetToken(CPP14ParserNotEqual, i)
}

func (s *EqualityExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EqualityExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EqualityExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterEqualityExpression(s)
	}
}

func (s *EqualityExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitEqualityExpression(s)
	}
}

func (s *EqualityExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitEqualityExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) EqualityExpression() (localctx IEqualityExpressionContext) {
	localctx = NewEqualityExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, CPP14ParserRULE_equalityExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(759)
		p.RelationalExpression()
	}
	p.SetState(764)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CPP14ParserEqual || _la == CPP14ParserNotEqual {
		{
			p.SetState(760)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CPP14ParserEqual || _la == CPP14ParserNotEqual) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(761)
			p.RelationalExpression()
		}

		p.SetState(766)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAndExpressionContext is an interface to support dynamic dispatch.
type IAndExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllEqualityExpression() []IEqualityExpressionContext
	EqualityExpression(i int) IEqualityExpressionContext
	AllAnd() []antlr.TerminalNode
	And(i int) antlr.TerminalNode

	// IsAndExpressionContext differentiates from other interfaces.
	IsAndExpressionContext()
}

type AndExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAndExpressionContext() *AndExpressionContext {
	var p = new(AndExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_andExpression
	return p
}

func InitEmptyAndExpressionContext(p *AndExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_andExpression
}

func (*AndExpressionContext) IsAndExpressionContext() {}

func NewAndExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AndExpressionContext {
	var p = new(AndExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_andExpression

	return p
}

func (s *AndExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AndExpressionContext) AllEqualityExpression() []IEqualityExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEqualityExpressionContext); ok {
			len++
		}
	}

	tst := make([]IEqualityExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEqualityExpressionContext); ok {
			tst[i] = t.(IEqualityExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AndExpressionContext) EqualityExpression(i int) IEqualityExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualityExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualityExpressionContext)
}

func (s *AndExpressionContext) AllAnd() []antlr.TerminalNode {
	return s.GetTokens(CPP14ParserAnd)
}

func (s *AndExpressionContext) And(i int) antlr.TerminalNode {
	return s.GetToken(CPP14ParserAnd, i)
}

func (s *AndExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AndExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AndExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterAndExpression(s)
	}
}

func (s *AndExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitAndExpression(s)
	}
}

func (s *AndExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitAndExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) AndExpression() (localctx IAndExpressionContext) {
	localctx = NewAndExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, CPP14ParserRULE_andExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(767)
		p.EqualityExpression()
	}
	p.SetState(772)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CPP14ParserAnd {
		{
			p.SetState(768)
			p.Match(CPP14ParserAnd)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(769)
			p.EqualityExpression()
		}

		p.SetState(774)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExclusiveOrExpressionContext is an interface to support dynamic dispatch.
type IExclusiveOrExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAndExpression() []IAndExpressionContext
	AndExpression(i int) IAndExpressionContext
	AllCaret() []antlr.TerminalNode
	Caret(i int) antlr.TerminalNode

	// IsExclusiveOrExpressionContext differentiates from other interfaces.
	IsExclusiveOrExpressionContext()
}

type ExclusiveOrExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExclusiveOrExpressionContext() *ExclusiveOrExpressionContext {
	var p = new(ExclusiveOrExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_exclusiveOrExpression
	return p
}

func InitEmptyExclusiveOrExpressionContext(p *ExclusiveOrExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_exclusiveOrExpression
}

func (*ExclusiveOrExpressionContext) IsExclusiveOrExpressionContext() {}

func NewExclusiveOrExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExclusiveOrExpressionContext {
	var p = new(ExclusiveOrExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_exclusiveOrExpression

	return p
}

func (s *ExclusiveOrExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExclusiveOrExpressionContext) AllAndExpression() []IAndExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAndExpressionContext); ok {
			len++
		}
	}

	tst := make([]IAndExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAndExpressionContext); ok {
			tst[i] = t.(IAndExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExclusiveOrExpressionContext) AndExpression(i int) IAndExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAndExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAndExpressionContext)
}

func (s *ExclusiveOrExpressionContext) AllCaret() []antlr.TerminalNode {
	return s.GetTokens(CPP14ParserCaret)
}

func (s *ExclusiveOrExpressionContext) Caret(i int) antlr.TerminalNode {
	return s.GetToken(CPP14ParserCaret, i)
}

func (s *ExclusiveOrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExclusiveOrExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExclusiveOrExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterExclusiveOrExpression(s)
	}
}

func (s *ExclusiveOrExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitExclusiveOrExpression(s)
	}
}

func (s *ExclusiveOrExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitExclusiveOrExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) ExclusiveOrExpression() (localctx IExclusiveOrExpressionContext) {
	localctx = NewExclusiveOrExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, CPP14ParserRULE_exclusiveOrExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(775)
		p.AndExpression()
	}
	p.SetState(780)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CPP14ParserCaret {
		{
			p.SetState(776)
			p.Match(CPP14ParserCaret)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(777)
			p.AndExpression()
		}

		p.SetState(782)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInclusiveOrExpressionContext is an interface to support dynamic dispatch.
type IInclusiveOrExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExclusiveOrExpression() []IExclusiveOrExpressionContext
	ExclusiveOrExpression(i int) IExclusiveOrExpressionContext
	AllOr() []antlr.TerminalNode
	Or(i int) antlr.TerminalNode

	// IsInclusiveOrExpressionContext differentiates from other interfaces.
	IsInclusiveOrExpressionContext()
}

type InclusiveOrExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInclusiveOrExpressionContext() *InclusiveOrExpressionContext {
	var p = new(InclusiveOrExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_inclusiveOrExpression
	return p
}

func InitEmptyInclusiveOrExpressionContext(p *InclusiveOrExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_inclusiveOrExpression
}

func (*InclusiveOrExpressionContext) IsInclusiveOrExpressionContext() {}

func NewInclusiveOrExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InclusiveOrExpressionContext {
	var p = new(InclusiveOrExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_inclusiveOrExpression

	return p
}

func (s *InclusiveOrExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *InclusiveOrExpressionContext) AllExclusiveOrExpression() []IExclusiveOrExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExclusiveOrExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExclusiveOrExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExclusiveOrExpressionContext); ok {
			tst[i] = t.(IExclusiveOrExpressionContext)
			i++
		}
	}

	return tst
}

func (s *InclusiveOrExpressionContext) ExclusiveOrExpression(i int) IExclusiveOrExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExclusiveOrExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExclusiveOrExpressionContext)
}

func (s *InclusiveOrExpressionContext) AllOr() []antlr.TerminalNode {
	return s.GetTokens(CPP14ParserOr)
}

func (s *InclusiveOrExpressionContext) Or(i int) antlr.TerminalNode {
	return s.GetToken(CPP14ParserOr, i)
}

func (s *InclusiveOrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InclusiveOrExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InclusiveOrExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterInclusiveOrExpression(s)
	}
}

func (s *InclusiveOrExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitInclusiveOrExpression(s)
	}
}

func (s *InclusiveOrExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitInclusiveOrExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) InclusiveOrExpression() (localctx IInclusiveOrExpressionContext) {
	localctx = NewInclusiveOrExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, CPP14ParserRULE_inclusiveOrExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(783)
		p.ExclusiveOrExpression()
	}
	p.SetState(788)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CPP14ParserOr {
		{
			p.SetState(784)
			p.Match(CPP14ParserOr)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(785)
			p.ExclusiveOrExpression()
		}

		p.SetState(790)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILogicalAndExpressionContext is an interface to support dynamic dispatch.
type ILogicalAndExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllInclusiveOrExpression() []IInclusiveOrExpressionContext
	InclusiveOrExpression(i int) IInclusiveOrExpressionContext
	AllAndAnd() []antlr.TerminalNode
	AndAnd(i int) antlr.TerminalNode

	// IsLogicalAndExpressionContext differentiates from other interfaces.
	IsLogicalAndExpressionContext()
}

type LogicalAndExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogicalAndExpressionContext() *LogicalAndExpressionContext {
	var p = new(LogicalAndExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_logicalAndExpression
	return p
}

func InitEmptyLogicalAndExpressionContext(p *LogicalAndExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_logicalAndExpression
}

func (*LogicalAndExpressionContext) IsLogicalAndExpressionContext() {}

func NewLogicalAndExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LogicalAndExpressionContext {
	var p = new(LogicalAndExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_logicalAndExpression

	return p
}

func (s *LogicalAndExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *LogicalAndExpressionContext) AllInclusiveOrExpression() []IInclusiveOrExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInclusiveOrExpressionContext); ok {
			len++
		}
	}

	tst := make([]IInclusiveOrExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInclusiveOrExpressionContext); ok {
			tst[i] = t.(IInclusiveOrExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogicalAndExpressionContext) InclusiveOrExpression(i int) IInclusiveOrExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInclusiveOrExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInclusiveOrExpressionContext)
}

func (s *LogicalAndExpressionContext) AllAndAnd() []antlr.TerminalNode {
	return s.GetTokens(CPP14ParserAndAnd)
}

func (s *LogicalAndExpressionContext) AndAnd(i int) antlr.TerminalNode {
	return s.GetToken(CPP14ParserAndAnd, i)
}

func (s *LogicalAndExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalAndExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LogicalAndExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterLogicalAndExpression(s)
	}
}

func (s *LogicalAndExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitLogicalAndExpression(s)
	}
}

func (s *LogicalAndExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitLogicalAndExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) LogicalAndExpression() (localctx ILogicalAndExpressionContext) {
	localctx = NewLogicalAndExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, CPP14ParserRULE_logicalAndExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(791)
		p.InclusiveOrExpression()
	}
	p.SetState(796)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CPP14ParserAndAnd {
		{
			p.SetState(792)
			p.Match(CPP14ParserAndAnd)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(793)
			p.InclusiveOrExpression()
		}

		p.SetState(798)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILogicalOrExpressionContext is an interface to support dynamic dispatch.
type ILogicalOrExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLogicalAndExpression() []ILogicalAndExpressionContext
	LogicalAndExpression(i int) ILogicalAndExpressionContext
	AllOrOr() []antlr.TerminalNode
	OrOr(i int) antlr.TerminalNode

	// IsLogicalOrExpressionContext differentiates from other interfaces.
	IsLogicalOrExpressionContext()
}

type LogicalOrExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogicalOrExpressionContext() *LogicalOrExpressionContext {
	var p = new(LogicalOrExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_logicalOrExpression
	return p
}

func InitEmptyLogicalOrExpressionContext(p *LogicalOrExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_logicalOrExpression
}

func (*LogicalOrExpressionContext) IsLogicalOrExpressionContext() {}

func NewLogicalOrExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LogicalOrExpressionContext {
	var p = new(LogicalOrExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_logicalOrExpression

	return p
}

func (s *LogicalOrExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *LogicalOrExpressionContext) AllLogicalAndExpression() []ILogicalAndExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILogicalAndExpressionContext); ok {
			len++
		}
	}

	tst := make([]ILogicalAndExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILogicalAndExpressionContext); ok {
			tst[i] = t.(ILogicalAndExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogicalOrExpressionContext) LogicalAndExpression(i int) ILogicalAndExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogicalAndExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogicalAndExpressionContext)
}

func (s *LogicalOrExpressionContext) AllOrOr() []antlr.TerminalNode {
	return s.GetTokens(CPP14ParserOrOr)
}

func (s *LogicalOrExpressionContext) OrOr(i int) antlr.TerminalNode {
	return s.GetToken(CPP14ParserOrOr, i)
}

func (s *LogicalOrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalOrExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LogicalOrExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterLogicalOrExpression(s)
	}
}

func (s *LogicalOrExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitLogicalOrExpression(s)
	}
}

func (s *LogicalOrExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitLogicalOrExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) LogicalOrExpression() (localctx ILogicalOrExpressionContext) {
	localctx = NewLogicalOrExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, CPP14ParserRULE_logicalOrExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(799)
		p.LogicalAndExpression()
	}
	p.SetState(804)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CPP14ParserOrOr {
		{
			p.SetState(800)
			p.Match(CPP14ParserOrOr)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(801)
			p.LogicalAndExpression()
		}

		p.SetState(806)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConditionalExpressionContext is an interface to support dynamic dispatch.
type IConditionalExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LogicalOrExpression() ILogicalOrExpressionContext
	Question() antlr.TerminalNode
	Expression() IExpressionContext
	Colon() antlr.TerminalNode
	AssignmentExpression() IAssignmentExpressionContext

	// IsConditionalExpressionContext differentiates from other interfaces.
	IsConditionalExpressionContext()
}

type ConditionalExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionalExpressionContext() *ConditionalExpressionContext {
	var p = new(ConditionalExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_conditionalExpression
	return p
}

func InitEmptyConditionalExpressionContext(p *ConditionalExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_conditionalExpression
}

func (*ConditionalExpressionContext) IsConditionalExpressionContext() {}

func NewConditionalExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionalExpressionContext {
	var p = new(ConditionalExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_conditionalExpression

	return p
}

func (s *ConditionalExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionalExpressionContext) LogicalOrExpression() ILogicalOrExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogicalOrExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogicalOrExpressionContext)
}

func (s *ConditionalExpressionContext) Question() antlr.TerminalNode {
	return s.GetToken(CPP14ParserQuestion, 0)
}

func (s *ConditionalExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ConditionalExpressionContext) Colon() antlr.TerminalNode {
	return s.GetToken(CPP14ParserColon, 0)
}

func (s *ConditionalExpressionContext) AssignmentExpression() IAssignmentExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentExpressionContext)
}

func (s *ConditionalExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionalExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionalExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterConditionalExpression(s)
	}
}

func (s *ConditionalExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitConditionalExpression(s)
	}
}

func (s *ConditionalExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitConditionalExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) ConditionalExpression() (localctx IConditionalExpressionContext) {
	localctx = NewConditionalExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, CPP14ParserRULE_conditionalExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(807)
		p.LogicalOrExpression()
	}
	p.SetState(813)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CPP14ParserQuestion {
		{
			p.SetState(808)
			p.Match(CPP14ParserQuestion)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(809)
			p.Expression()
		}
		{
			p.SetState(810)
			p.Match(CPP14ParserColon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(811)
			p.AssignmentExpression()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentExpressionContext is an interface to support dynamic dispatch.
type IAssignmentExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ConditionalExpression() IConditionalExpressionContext
	LogicalOrExpression() ILogicalOrExpressionContext
	AssignmentOperator() IAssignmentOperatorContext
	InitializerClause() IInitializerClauseContext
	ThrowExpression() IThrowExpressionContext

	// IsAssignmentExpressionContext differentiates from other interfaces.
	IsAssignmentExpressionContext()
}

type AssignmentExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentExpressionContext() *AssignmentExpressionContext {
	var p = new(AssignmentExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_assignmentExpression
	return p
}

func InitEmptyAssignmentExpressionContext(p *AssignmentExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_assignmentExpression
}

func (*AssignmentExpressionContext) IsAssignmentExpressionContext() {}

func NewAssignmentExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentExpressionContext {
	var p = new(AssignmentExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_assignmentExpression

	return p
}

func (s *AssignmentExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentExpressionContext) ConditionalExpression() IConditionalExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionalExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionalExpressionContext)
}

func (s *AssignmentExpressionContext) LogicalOrExpression() ILogicalOrExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogicalOrExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogicalOrExpressionContext)
}

func (s *AssignmentExpressionContext) AssignmentOperator() IAssignmentOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentOperatorContext)
}

func (s *AssignmentExpressionContext) InitializerClause() IInitializerClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitializerClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitializerClauseContext)
}

func (s *AssignmentExpressionContext) ThrowExpression() IThrowExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IThrowExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IThrowExpressionContext)
}

func (s *AssignmentExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterAssignmentExpression(s)
	}
}

func (s *AssignmentExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitAssignmentExpression(s)
	}
}

func (s *AssignmentExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitAssignmentExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) AssignmentExpression() (localctx IAssignmentExpressionContext) {
	localctx = NewAssignmentExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, CPP14ParserRULE_assignmentExpression)
	p.SetState(821)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 71, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(815)
			p.ConditionalExpression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(816)
			p.LogicalOrExpression()
		}
		{
			p.SetState(817)
			p.AssignmentOperator()
		}
		{
			p.SetState(818)
			p.InitializerClause()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(820)
			p.ThrowExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentOperatorContext is an interface to support dynamic dispatch.
type IAssignmentOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Assign() antlr.TerminalNode
	StarAssign() antlr.TerminalNode
	DivAssign() antlr.TerminalNode
	ModAssign() antlr.TerminalNode
	PlusAssign() antlr.TerminalNode
	MinusAssign() antlr.TerminalNode
	RightShiftAssign() antlr.TerminalNode
	LeftShiftAssign() antlr.TerminalNode
	AndAssign() antlr.TerminalNode
	XorAssign() antlr.TerminalNode
	OrAssign() antlr.TerminalNode

	// IsAssignmentOperatorContext differentiates from other interfaces.
	IsAssignmentOperatorContext()
}

type AssignmentOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentOperatorContext() *AssignmentOperatorContext {
	var p = new(AssignmentOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_assignmentOperator
	return p
}

func InitEmptyAssignmentOperatorContext(p *AssignmentOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_assignmentOperator
}

func (*AssignmentOperatorContext) IsAssignmentOperatorContext() {}

func NewAssignmentOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentOperatorContext {
	var p = new(AssignmentOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_assignmentOperator

	return p
}

func (s *AssignmentOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentOperatorContext) Assign() antlr.TerminalNode {
	return s.GetToken(CPP14ParserAssign, 0)
}

func (s *AssignmentOperatorContext) StarAssign() antlr.TerminalNode {
	return s.GetToken(CPP14ParserStarAssign, 0)
}

func (s *AssignmentOperatorContext) DivAssign() antlr.TerminalNode {
	return s.GetToken(CPP14ParserDivAssign, 0)
}

func (s *AssignmentOperatorContext) ModAssign() antlr.TerminalNode {
	return s.GetToken(CPP14ParserModAssign, 0)
}

func (s *AssignmentOperatorContext) PlusAssign() antlr.TerminalNode {
	return s.GetToken(CPP14ParserPlusAssign, 0)
}

func (s *AssignmentOperatorContext) MinusAssign() antlr.TerminalNode {
	return s.GetToken(CPP14ParserMinusAssign, 0)
}

func (s *AssignmentOperatorContext) RightShiftAssign() antlr.TerminalNode {
	return s.GetToken(CPP14ParserRightShiftAssign, 0)
}

func (s *AssignmentOperatorContext) LeftShiftAssign() antlr.TerminalNode {
	return s.GetToken(CPP14ParserLeftShiftAssign, 0)
}

func (s *AssignmentOperatorContext) AndAssign() antlr.TerminalNode {
	return s.GetToken(CPP14ParserAndAssign, 0)
}

func (s *AssignmentOperatorContext) XorAssign() antlr.TerminalNode {
	return s.GetToken(CPP14ParserXorAssign, 0)
}

func (s *AssignmentOperatorContext) OrAssign() antlr.TerminalNode {
	return s.GetToken(CPP14ParserOrAssign, 0)
}

func (s *AssignmentOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterAssignmentOperator(s)
	}
}

func (s *AssignmentOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitAssignmentOperator(s)
	}
}

func (s *AssignmentOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitAssignmentOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) AssignmentOperator() (localctx IAssignmentOperatorContext) {
	localctx = NewAssignmentOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, CPP14ParserRULE_assignmentOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(823)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-101)) & ^0x3f) == 0 && ((int64(1)<<(_la-101))&8185) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAssignmentExpression() []IAssignmentExpressionContext
	AssignmentExpression(i int) IAssignmentExpressionContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) AllAssignmentExpression() []IAssignmentExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssignmentExpressionContext); ok {
			len++
		}
	}

	tst := make([]IAssignmentExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssignmentExpressionContext); ok {
			tst[i] = t.(IAssignmentExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionContext) AssignmentExpression(i int) IAssignmentExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentExpressionContext)
}

func (s *ExpressionContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(CPP14ParserComma)
}

func (s *ExpressionContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(CPP14ParserComma, i)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (s *ExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) Expression() (localctx IExpressionContext) {
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, CPP14ParserRULE_expression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(825)
		p.AssignmentExpression()
	}
	p.SetState(830)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CPP14ParserComma {
		{
			p.SetState(826)
			p.Match(CPP14ParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(827)
			p.AssignmentExpression()
		}

		p.SetState(832)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstantExpressionContext is an interface to support dynamic dispatch.
type IConstantExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ConditionalExpression() IConditionalExpressionContext

	// IsConstantExpressionContext differentiates from other interfaces.
	IsConstantExpressionContext()
}

type ConstantExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantExpressionContext() *ConstantExpressionContext {
	var p = new(ConstantExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_constantExpression
	return p
}

func InitEmptyConstantExpressionContext(p *ConstantExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_constantExpression
}

func (*ConstantExpressionContext) IsConstantExpressionContext() {}

func NewConstantExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantExpressionContext {
	var p = new(ConstantExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_constantExpression

	return p
}

func (s *ConstantExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantExpressionContext) ConditionalExpression() IConditionalExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionalExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionalExpressionContext)
}

func (s *ConstantExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterConstantExpression(s)
	}
}

func (s *ConstantExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitConstantExpression(s)
	}
}

func (s *ConstantExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitConstantExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) ConstantExpression() (localctx IConstantExpressionContext) {
	localctx = NewConstantExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, CPP14ParserRULE_constantExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(833)
		p.ConditionalExpression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LabeledStatement() ILabeledStatementContext
	DeclarationStatement() IDeclarationStatementContext
	ExpressionStatement() IExpressionStatementContext
	CompoundStatement() ICompoundStatementContext
	SelectionStatement() ISelectionStatementContext
	IterationStatement() IIterationStatementContext
	JumpStatement() IJumpStatementContext
	TryBlock() ITryBlockContext
	AttributeSpecifierSeq() IAttributeSpecifierSeqContext

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_statement
	return p
}

func InitEmptyStatementContext(p *StatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_statement
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) LabeledStatement() ILabeledStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabeledStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabeledStatementContext)
}

func (s *StatementContext) DeclarationStatement() IDeclarationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationStatementContext)
}

func (s *StatementContext) ExpressionStatement() IExpressionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionStatementContext)
}

func (s *StatementContext) CompoundStatement() ICompoundStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementContext)
}

func (s *StatementContext) SelectionStatement() ISelectionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectionStatementContext)
}

func (s *StatementContext) IterationStatement() IIterationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIterationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIterationStatementContext)
}

func (s *StatementContext) JumpStatement() IJumpStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJumpStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJumpStatementContext)
}

func (s *StatementContext) TryBlock() ITryBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITryBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITryBlockContext)
}

func (s *StatementContext) AttributeSpecifierSeq() IAttributeSpecifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSpecifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSpecifierSeqContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (s *StatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, CPP14ParserRULE_statement)
	p.SetState(848)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 75, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(835)
			p.LabeledStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(836)
			p.DeclarationStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(838)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 73, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(837)
				p.AttributeSpecifierSeq()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(846)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case CPP14ParserIntegerLiteral, CPP14ParserCharacterLiteral, CPP14ParserFloatingLiteral, CPP14ParserStringLiteral, CPP14ParserBooleanLiteral, CPP14ParserPointerLiteral, CPP14ParserUserDefinedLiteral, CPP14ParserAlignof, CPP14ParserAuto, CPP14ParserBool, CPP14ParserChar, CPP14ParserChar16, CPP14ParserChar32, CPP14ParserConst_cast, CPP14ParserDecltype, CPP14ParserDelete, CPP14ParserDouble, CPP14ParserDynamic_cast, CPP14ParserFloat, CPP14ParserInt, CPP14ParserLong, CPP14ParserNew, CPP14ParserNoexcept, CPP14ParserOperator, CPP14ParserReinterpret_cast, CPP14ParserShort, CPP14ParserSigned, CPP14ParserSizeof, CPP14ParserStatic_cast, CPP14ParserThis, CPP14ParserThrow, CPP14ParserTypeid_, CPP14ParserTypename_, CPP14ParserUnsigned, CPP14ParserVoid, CPP14ParserWchar, CPP14ParserLeftParen, CPP14ParserLeftBracket, CPP14ParserPlus, CPP14ParserMinus, CPP14ParserStar, CPP14ParserAnd, CPP14ParserOr, CPP14ParserTilde, CPP14ParserNot, CPP14ParserPlusPlus, CPP14ParserMinusMinus, CPP14ParserDoublecolon, CPP14ParserSemi, CPP14ParserIdentifier:
			{
				p.SetState(840)
				p.ExpressionStatement()
			}

		case CPP14ParserLeftBrace:
			{
				p.SetState(841)
				p.CompoundStatement()
			}

		case CPP14ParserIf, CPP14ParserSwitch:
			{
				p.SetState(842)
				p.SelectionStatement()
			}

		case CPP14ParserDo, CPP14ParserFor, CPP14ParserWhile:
			{
				p.SetState(843)
				p.IterationStatement()
			}

		case CPP14ParserBreak, CPP14ParserContinue, CPP14ParserGoto, CPP14ParserReturn:
			{
				p.SetState(844)
				p.JumpStatement()
			}

		case CPP14ParserTry:
			{
				p.SetState(845)
				p.TryBlock()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILabeledStatementContext is an interface to support dynamic dispatch.
type ILabeledStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Colon() antlr.TerminalNode
	Statement() IStatementContext
	Identifier() antlr.TerminalNode
	Case() antlr.TerminalNode
	ConstantExpression() IConstantExpressionContext
	Default() antlr.TerminalNode
	AttributeSpecifierSeq() IAttributeSpecifierSeqContext

	// IsLabeledStatementContext differentiates from other interfaces.
	IsLabeledStatementContext()
}

type LabeledStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabeledStatementContext() *LabeledStatementContext {
	var p = new(LabeledStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_labeledStatement
	return p
}

func InitEmptyLabeledStatementContext(p *LabeledStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_labeledStatement
}

func (*LabeledStatementContext) IsLabeledStatementContext() {}

func NewLabeledStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabeledStatementContext {
	var p = new(LabeledStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_labeledStatement

	return p
}

func (s *LabeledStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LabeledStatementContext) Colon() antlr.TerminalNode {
	return s.GetToken(CPP14ParserColon, 0)
}

func (s *LabeledStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *LabeledStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CPP14ParserIdentifier, 0)
}

func (s *LabeledStatementContext) Case() antlr.TerminalNode {
	return s.GetToken(CPP14ParserCase, 0)
}

func (s *LabeledStatementContext) ConstantExpression() IConstantExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantExpressionContext)
}

func (s *LabeledStatementContext) Default() antlr.TerminalNode {
	return s.GetToken(CPP14ParserDefault, 0)
}

func (s *LabeledStatementContext) AttributeSpecifierSeq() IAttributeSpecifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSpecifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSpecifierSeqContext)
}

func (s *LabeledStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabeledStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabeledStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterLabeledStatement(s)
	}
}

func (s *LabeledStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitLabeledStatement(s)
	}
}

func (s *LabeledStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitLabeledStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) LabeledStatement() (localctx ILabeledStatementContext) {
	localctx = NewLabeledStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, CPP14ParserRULE_labeledStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(851)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CPP14ParserAlignas || _la == CPP14ParserLeftBracket {
		{
			p.SetState(850)
			p.AttributeSpecifierSeq()
		}

	}
	p.SetState(857)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CPP14ParserIdentifier:
		{
			p.SetState(853)
			p.Match(CPP14ParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case CPP14ParserCase:
		{
			p.SetState(854)
			p.Match(CPP14ParserCase)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(855)
			p.ConstantExpression()
		}

	case CPP14ParserDefault:
		{
			p.SetState(856)
			p.Match(CPP14ParserDefault)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(859)
		p.Match(CPP14ParserColon)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(860)
		p.Statement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionStatementContext is an interface to support dynamic dispatch.
type IExpressionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Semi() antlr.TerminalNode
	Expression() IExpressionContext

	// IsExpressionStatementContext differentiates from other interfaces.
	IsExpressionStatementContext()
}

type ExpressionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionStatementContext() *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_expressionStatement
	return p
}

func InitEmptyExpressionStatementContext(p *ExpressionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_expressionStatement
}

func (*ExpressionStatementContext) IsExpressionStatementContext() {}

func NewExpressionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionStatementContext {
	var p = new(ExpressionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_expressionStatement

	return p
}

func (s *ExpressionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionStatementContext) Semi() antlr.TerminalNode {
	return s.GetToken(CPP14ParserSemi, 0)
}

func (s *ExpressionStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterExpressionStatement(s)
	}
}

func (s *ExpressionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitExpressionStatement(s)
	}
}

func (s *ExpressionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitExpressionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) ExpressionStatement() (localctx IExpressionStatementContext) {
	localctx = NewExpressionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, CPP14ParserRULE_expressionStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(863)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8364979464334764286) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&4719772474384133201) != 0) || _la == CPP14ParserIdentifier {
		{
			p.SetState(862)
			p.Expression()
		}

	}
	{
		p.SetState(865)
		p.Match(CPP14ParserSemi)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompoundStatementContext is an interface to support dynamic dispatch.
type ICompoundStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LeftBrace() antlr.TerminalNode
	RightBrace() antlr.TerminalNode
	StatementSeq() IStatementSeqContext

	// IsCompoundStatementContext differentiates from other interfaces.
	IsCompoundStatementContext()
}

type CompoundStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompoundStatementContext() *CompoundStatementContext {
	var p = new(CompoundStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_compoundStatement
	return p
}

func InitEmptyCompoundStatementContext(p *CompoundStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_compoundStatement
}

func (*CompoundStatementContext) IsCompoundStatementContext() {}

func NewCompoundStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompoundStatementContext {
	var p = new(CompoundStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_compoundStatement

	return p
}

func (s *CompoundStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CompoundStatementContext) LeftBrace() antlr.TerminalNode {
	return s.GetToken(CPP14ParserLeftBrace, 0)
}

func (s *CompoundStatementContext) RightBrace() antlr.TerminalNode {
	return s.GetToken(CPP14ParserRightBrace, 0)
}

func (s *CompoundStatementContext) StatementSeq() IStatementSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementSeqContext)
}

func (s *CompoundStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompoundStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompoundStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterCompoundStatement(s)
	}
}

func (s *CompoundStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitCompoundStatement(s)
	}
}

func (s *CompoundStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitCompoundStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) CompoundStatement() (localctx ICompoundStatementContext) {
	localctx = NewCompoundStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, CPP14ParserRULE_compoundStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(867)
		p.Match(CPP14ParserLeftBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(869)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-137360239606498050) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-8989184726396829969) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&25) != 0) {
		{
			p.SetState(868)
			p.StatementSeq()
		}

	}
	{
		p.SetState(871)
		p.Match(CPP14ParserRightBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementSeqContext is an interface to support dynamic dispatch.
type IStatementSeqContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext

	// IsStatementSeqContext differentiates from other interfaces.
	IsStatementSeqContext()
}

type StatementSeqContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementSeqContext() *StatementSeqContext {
	var p = new(StatementSeqContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_statementSeq
	return p
}

func InitEmptyStatementSeqContext(p *StatementSeqContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_statementSeq
}

func (*StatementSeqContext) IsStatementSeqContext() {}

func NewStatementSeqContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementSeqContext {
	var p = new(StatementSeqContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_statementSeq

	return p
}

func (s *StatementSeqContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementSeqContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *StatementSeqContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *StatementSeqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementSeqContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementSeqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterStatementSeq(s)
	}
}

func (s *StatementSeqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitStatementSeq(s)
	}
}

func (s *StatementSeqContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitStatementSeq(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) StatementSeq() (localctx IStatementSeqContext) {
	localctx = NewStatementSeqContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, CPP14ParserRULE_statementSeq)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(874)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-137360239606498050) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-8989184726396829969) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&25) != 0) {
		{
			p.SetState(873)
			p.Statement()
		}

		p.SetState(876)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectionStatementContext is an interface to support dynamic dispatch.
type ISelectionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	If() antlr.TerminalNode
	LeftParen() antlr.TerminalNode
	Condition() IConditionContext
	RightParen() antlr.TerminalNode
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext
	Else() antlr.TerminalNode
	Switch() antlr.TerminalNode

	// IsSelectionStatementContext differentiates from other interfaces.
	IsSelectionStatementContext()
}

type SelectionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectionStatementContext() *SelectionStatementContext {
	var p = new(SelectionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_selectionStatement
	return p
}

func InitEmptySelectionStatementContext(p *SelectionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_selectionStatement
}

func (*SelectionStatementContext) IsSelectionStatementContext() {}

func NewSelectionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectionStatementContext {
	var p = new(SelectionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_selectionStatement

	return p
}

func (s *SelectionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectionStatementContext) If() antlr.TerminalNode {
	return s.GetToken(CPP14ParserIf, 0)
}

func (s *SelectionStatementContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CPP14ParserLeftParen, 0)
}

func (s *SelectionStatementContext) Condition() IConditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *SelectionStatementContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CPP14ParserRightParen, 0)
}

func (s *SelectionStatementContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *SelectionStatementContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *SelectionStatementContext) Else() antlr.TerminalNode {
	return s.GetToken(CPP14ParserElse, 0)
}

func (s *SelectionStatementContext) Switch() antlr.TerminalNode {
	return s.GetToken(CPP14ParserSwitch, 0)
}

func (s *SelectionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterSelectionStatement(s)
	}
}

func (s *SelectionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitSelectionStatement(s)
	}
}

func (s *SelectionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitSelectionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) SelectionStatement() (localctx ISelectionStatementContext) {
	localctx = NewSelectionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, CPP14ParserRULE_selectionStatement)
	p.SetState(893)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CPP14ParserIf:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(878)
			p.Match(CPP14ParserIf)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(879)
			p.Match(CPP14ParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(880)
			p.Condition()
		}
		{
			p.SetState(881)
			p.Match(CPP14ParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(882)
			p.Statement()
		}
		p.SetState(885)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 81, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(883)
				p.Match(CPP14ParserElse)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(884)
				p.Statement()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case CPP14ParserSwitch:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(887)
			p.Match(CPP14ParserSwitch)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(888)
			p.Match(CPP14ParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(889)
			p.Condition()
		}
		{
			p.SetState(890)
			p.Match(CPP14ParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(891)
			p.Statement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConditionContext is an interface to support dynamic dispatch.
type IConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	DeclSpecifierSeq() IDeclSpecifierSeqContext
	Declarator() IDeclaratorContext
	Assign() antlr.TerminalNode
	InitializerClause() IInitializerClauseContext
	BracedInitList() IBracedInitListContext
	AttributeSpecifierSeq() IAttributeSpecifierSeqContext

	// IsConditionContext differentiates from other interfaces.
	IsConditionContext()
}

type ConditionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionContext() *ConditionContext {
	var p = new(ConditionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_condition
	return p
}

func InitEmptyConditionContext(p *ConditionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_condition
}

func (*ConditionContext) IsConditionContext() {}

func NewConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionContext {
	var p = new(ConditionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_condition

	return p
}

func (s *ConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ConditionContext) DeclSpecifierSeq() IDeclSpecifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclSpecifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclSpecifierSeqContext)
}

func (s *ConditionContext) Declarator() IDeclaratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclaratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclaratorContext)
}

func (s *ConditionContext) Assign() antlr.TerminalNode {
	return s.GetToken(CPP14ParserAssign, 0)
}

func (s *ConditionContext) InitializerClause() IInitializerClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitializerClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitializerClauseContext)
}

func (s *ConditionContext) BracedInitList() IBracedInitListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBracedInitListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBracedInitListContext)
}

func (s *ConditionContext) AttributeSpecifierSeq() IAttributeSpecifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSpecifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSpecifierSeqContext)
}

func (s *ConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterCondition(s)
	}
}

func (s *ConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitCondition(s)
	}
}

func (s *ConditionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitCondition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) Condition() (localctx IConditionContext) {
	localctx = NewConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, CPP14ParserRULE_condition)
	var _la int

	p.SetState(906)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 85, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(895)
			p.Expression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(897)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CPP14ParserAlignas || _la == CPP14ParserLeftBracket {
			{
				p.SetState(896)
				p.AttributeSpecifierSeq()
			}

		}
		{
			p.SetState(899)
			p.DeclSpecifierSeq()
		}
		{
			p.SetState(900)
			p.Declarator()
		}
		p.SetState(904)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case CPP14ParserAssign:
			{
				p.SetState(901)
				p.Match(CPP14ParserAssign)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(902)
				p.InitializerClause()
			}

		case CPP14ParserLeftBrace:
			{
				p.SetState(903)
				p.BracedInitList()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIterationStatementContext is an interface to support dynamic dispatch.
type IIterationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	While() antlr.TerminalNode
	LeftParen() antlr.TerminalNode
	Condition() IConditionContext
	RightParen() antlr.TerminalNode
	Statement() IStatementContext
	Do() antlr.TerminalNode
	Expression() IExpressionContext
	Semi() antlr.TerminalNode
	For() antlr.TerminalNode
	ForInitStatement() IForInitStatementContext
	ForRangeDeclaration() IForRangeDeclarationContext
	Colon() antlr.TerminalNode
	ForRangeInitializer() IForRangeInitializerContext

	// IsIterationStatementContext differentiates from other interfaces.
	IsIterationStatementContext()
}

type IterationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIterationStatementContext() *IterationStatementContext {
	var p = new(IterationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_iterationStatement
	return p
}

func InitEmptyIterationStatementContext(p *IterationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_iterationStatement
}

func (*IterationStatementContext) IsIterationStatementContext() {}

func NewIterationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IterationStatementContext {
	var p = new(IterationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_iterationStatement

	return p
}

func (s *IterationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IterationStatementContext) While() antlr.TerminalNode {
	return s.GetToken(CPP14ParserWhile, 0)
}

func (s *IterationStatementContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CPP14ParserLeftParen, 0)
}

func (s *IterationStatementContext) Condition() IConditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *IterationStatementContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CPP14ParserRightParen, 0)
}

func (s *IterationStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *IterationStatementContext) Do() antlr.TerminalNode {
	return s.GetToken(CPP14ParserDo, 0)
}

func (s *IterationStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IterationStatementContext) Semi() antlr.TerminalNode {
	return s.GetToken(CPP14ParserSemi, 0)
}

func (s *IterationStatementContext) For() antlr.TerminalNode {
	return s.GetToken(CPP14ParserFor, 0)
}

func (s *IterationStatementContext) ForInitStatement() IForInitStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForInitStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForInitStatementContext)
}

func (s *IterationStatementContext) ForRangeDeclaration() IForRangeDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForRangeDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForRangeDeclarationContext)
}

func (s *IterationStatementContext) Colon() antlr.TerminalNode {
	return s.GetToken(CPP14ParserColon, 0)
}

func (s *IterationStatementContext) ForRangeInitializer() IForRangeInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForRangeInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForRangeInitializerContext)
}

func (s *IterationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IterationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IterationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterIterationStatement(s)
	}
}

func (s *IterationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitIterationStatement(s)
	}
}

func (s *IterationStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitIterationStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) IterationStatement() (localctx IIterationStatementContext) {
	localctx = NewIterationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, CPP14ParserRULE_iterationStatement)
	var _la int

	p.SetState(941)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CPP14ParserWhile:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(908)
			p.Match(CPP14ParserWhile)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(909)
			p.Match(CPP14ParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(910)
			p.Condition()
		}
		{
			p.SetState(911)
			p.Match(CPP14ParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(912)
			p.Statement()
		}

	case CPP14ParserDo:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(914)
			p.Match(CPP14ParserDo)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(915)
			p.Statement()
		}
		{
			p.SetState(916)
			p.Match(CPP14ParserWhile)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(917)
			p.Match(CPP14ParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(918)
			p.Expression()
		}
		{
			p.SetState(919)
			p.Match(CPP14ParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(920)
			p.Match(CPP14ParserSemi)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case CPP14ParserFor:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(922)
			p.Match(CPP14ParserFor)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(923)
			p.Match(CPP14ParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(936)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 88, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(924)
				p.ForInitStatement()
			}
			p.SetState(926)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-714116761242538754) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&4719772474384301683) != 0) || _la == CPP14ParserIdentifier {
				{
					p.SetState(925)
					p.Condition()
				}

			}
			{
				p.SetState(928)
				p.Match(CPP14ParserSemi)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(930)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8364979464334764286) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&4719772474384133201) != 0) || _la == CPP14ParserIdentifier {
				{
					p.SetState(929)
					p.Expression()
				}

			}

		case 2:
			{
				p.SetState(932)
				p.ForRangeDeclaration()
			}
			{
				p.SetState(933)
				p.Match(CPP14ParserColon)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(934)
				p.ForRangeInitializer()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(938)
			p.Match(CPP14ParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(939)
			p.Statement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForInitStatementContext is an interface to support dynamic dispatch.
type IForInitStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExpressionStatement() IExpressionStatementContext
	SimpleDeclaration() ISimpleDeclarationContext

	// IsForInitStatementContext differentiates from other interfaces.
	IsForInitStatementContext()
}

type ForInitStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForInitStatementContext() *ForInitStatementContext {
	var p = new(ForInitStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_forInitStatement
	return p
}

func InitEmptyForInitStatementContext(p *ForInitStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_forInitStatement
}

func (*ForInitStatementContext) IsForInitStatementContext() {}

func NewForInitStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForInitStatementContext {
	var p = new(ForInitStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_forInitStatement

	return p
}

func (s *ForInitStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ForInitStatementContext) ExpressionStatement() IExpressionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionStatementContext)
}

func (s *ForInitStatementContext) SimpleDeclaration() ISimpleDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleDeclarationContext)
}

func (s *ForInitStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForInitStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForInitStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterForInitStatement(s)
	}
}

func (s *ForInitStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitForInitStatement(s)
	}
}

func (s *ForInitStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitForInitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) ForInitStatement() (localctx IForInitStatementContext) {
	localctx = NewForInitStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, CPP14ParserRULE_forInitStatement)
	p.SetState(945)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 90, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(943)
			p.ExpressionStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(944)
			p.SimpleDeclaration()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForRangeDeclarationContext is an interface to support dynamic dispatch.
type IForRangeDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DeclSpecifierSeq() IDeclSpecifierSeqContext
	Declarator() IDeclaratorContext
	AttributeSpecifierSeq() IAttributeSpecifierSeqContext

	// IsForRangeDeclarationContext differentiates from other interfaces.
	IsForRangeDeclarationContext()
}

type ForRangeDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForRangeDeclarationContext() *ForRangeDeclarationContext {
	var p = new(ForRangeDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_forRangeDeclaration
	return p
}

func InitEmptyForRangeDeclarationContext(p *ForRangeDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_forRangeDeclaration
}

func (*ForRangeDeclarationContext) IsForRangeDeclarationContext() {}

func NewForRangeDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForRangeDeclarationContext {
	var p = new(ForRangeDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_forRangeDeclaration

	return p
}

func (s *ForRangeDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ForRangeDeclarationContext) DeclSpecifierSeq() IDeclSpecifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclSpecifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclSpecifierSeqContext)
}

func (s *ForRangeDeclarationContext) Declarator() IDeclaratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclaratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclaratorContext)
}

func (s *ForRangeDeclarationContext) AttributeSpecifierSeq() IAttributeSpecifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSpecifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSpecifierSeqContext)
}

func (s *ForRangeDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForRangeDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForRangeDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterForRangeDeclaration(s)
	}
}

func (s *ForRangeDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitForRangeDeclaration(s)
	}
}

func (s *ForRangeDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitForRangeDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) ForRangeDeclaration() (localctx IForRangeDeclarationContext) {
	localctx = NewForRangeDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, CPP14ParserRULE_forRangeDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(948)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CPP14ParserAlignas || _la == CPP14ParserLeftBracket {
		{
			p.SetState(947)
			p.AttributeSpecifierSeq()
		}

	}
	{
		p.SetState(950)
		p.DeclSpecifierSeq()
	}
	{
		p.SetState(951)
		p.Declarator()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForRangeInitializerContext is an interface to support dynamic dispatch.
type IForRangeInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	BracedInitList() IBracedInitListContext

	// IsForRangeInitializerContext differentiates from other interfaces.
	IsForRangeInitializerContext()
}

type ForRangeInitializerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForRangeInitializerContext() *ForRangeInitializerContext {
	var p = new(ForRangeInitializerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_forRangeInitializer
	return p
}

func InitEmptyForRangeInitializerContext(p *ForRangeInitializerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_forRangeInitializer
}

func (*ForRangeInitializerContext) IsForRangeInitializerContext() {}

func NewForRangeInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForRangeInitializerContext {
	var p = new(ForRangeInitializerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_forRangeInitializer

	return p
}

func (s *ForRangeInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *ForRangeInitializerContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ForRangeInitializerContext) BracedInitList() IBracedInitListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBracedInitListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBracedInitListContext)
}

func (s *ForRangeInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForRangeInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForRangeInitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterForRangeInitializer(s)
	}
}

func (s *ForRangeInitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitForRangeInitializer(s)
	}
}

func (s *ForRangeInitializerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitForRangeInitializer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) ForRangeInitializer() (localctx IForRangeInitializerContext) {
	localctx = NewForRangeInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, CPP14ParserRULE_forRangeInitializer)
	p.SetState(955)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CPP14ParserIntegerLiteral, CPP14ParserCharacterLiteral, CPP14ParserFloatingLiteral, CPP14ParserStringLiteral, CPP14ParserBooleanLiteral, CPP14ParserPointerLiteral, CPP14ParserUserDefinedLiteral, CPP14ParserAlignof, CPP14ParserAuto, CPP14ParserBool, CPP14ParserChar, CPP14ParserChar16, CPP14ParserChar32, CPP14ParserConst_cast, CPP14ParserDecltype, CPP14ParserDelete, CPP14ParserDouble, CPP14ParserDynamic_cast, CPP14ParserFloat, CPP14ParserInt, CPP14ParserLong, CPP14ParserNew, CPP14ParserNoexcept, CPP14ParserOperator, CPP14ParserReinterpret_cast, CPP14ParserShort, CPP14ParserSigned, CPP14ParserSizeof, CPP14ParserStatic_cast, CPP14ParserThis, CPP14ParserThrow, CPP14ParserTypeid_, CPP14ParserTypename_, CPP14ParserUnsigned, CPP14ParserVoid, CPP14ParserWchar, CPP14ParserLeftParen, CPP14ParserLeftBracket, CPP14ParserPlus, CPP14ParserMinus, CPP14ParserStar, CPP14ParserAnd, CPP14ParserOr, CPP14ParserTilde, CPP14ParserNot, CPP14ParserPlusPlus, CPP14ParserMinusMinus, CPP14ParserDoublecolon, CPP14ParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(953)
			p.Expression()
		}

	case CPP14ParserLeftBrace:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(954)
			p.BracedInitList()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJumpStatementContext is an interface to support dynamic dispatch.
type IJumpStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Semi() antlr.TerminalNode
	Break() antlr.TerminalNode
	Continue() antlr.TerminalNode
	Return() antlr.TerminalNode
	Goto() antlr.TerminalNode
	Identifier() antlr.TerminalNode
	Expression() IExpressionContext
	BracedInitList() IBracedInitListContext

	// IsJumpStatementContext differentiates from other interfaces.
	IsJumpStatementContext()
}

type JumpStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJumpStatementContext() *JumpStatementContext {
	var p = new(JumpStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_jumpStatement
	return p
}

func InitEmptyJumpStatementContext(p *JumpStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_jumpStatement
}

func (*JumpStatementContext) IsJumpStatementContext() {}

func NewJumpStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JumpStatementContext {
	var p = new(JumpStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_jumpStatement

	return p
}

func (s *JumpStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *JumpStatementContext) Semi() antlr.TerminalNode {
	return s.GetToken(CPP14ParserSemi, 0)
}

func (s *JumpStatementContext) Break() antlr.TerminalNode {
	return s.GetToken(CPP14ParserBreak, 0)
}

func (s *JumpStatementContext) Continue() antlr.TerminalNode {
	return s.GetToken(CPP14ParserContinue, 0)
}

func (s *JumpStatementContext) Return() antlr.TerminalNode {
	return s.GetToken(CPP14ParserReturn, 0)
}

func (s *JumpStatementContext) Goto() antlr.TerminalNode {
	return s.GetToken(CPP14ParserGoto, 0)
}

func (s *JumpStatementContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CPP14ParserIdentifier, 0)
}

func (s *JumpStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *JumpStatementContext) BracedInitList() IBracedInitListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBracedInitListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBracedInitListContext)
}

func (s *JumpStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JumpStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JumpStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterJumpStatement(s)
	}
}

func (s *JumpStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitJumpStatement(s)
	}
}

func (s *JumpStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitJumpStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) JumpStatement() (localctx IJumpStatementContext) {
	localctx = NewJumpStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, CPP14ParserRULE_jumpStatement)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(966)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CPP14ParserBreak:
		{
			p.SetState(957)
			p.Match(CPP14ParserBreak)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case CPP14ParserContinue:
		{
			p.SetState(958)
			p.Match(CPP14ParserContinue)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case CPP14ParserReturn:
		{
			p.SetState(959)
			p.Match(CPP14ParserReturn)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(962)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case CPP14ParserIntegerLiteral, CPP14ParserCharacterLiteral, CPP14ParserFloatingLiteral, CPP14ParserStringLiteral, CPP14ParserBooleanLiteral, CPP14ParserPointerLiteral, CPP14ParserUserDefinedLiteral, CPP14ParserAlignof, CPP14ParserAuto, CPP14ParserBool, CPP14ParserChar, CPP14ParserChar16, CPP14ParserChar32, CPP14ParserConst_cast, CPP14ParserDecltype, CPP14ParserDelete, CPP14ParserDouble, CPP14ParserDynamic_cast, CPP14ParserFloat, CPP14ParserInt, CPP14ParserLong, CPP14ParserNew, CPP14ParserNoexcept, CPP14ParserOperator, CPP14ParserReinterpret_cast, CPP14ParserShort, CPP14ParserSigned, CPP14ParserSizeof, CPP14ParserStatic_cast, CPP14ParserThis, CPP14ParserThrow, CPP14ParserTypeid_, CPP14ParserTypename_, CPP14ParserUnsigned, CPP14ParserVoid, CPP14ParserWchar, CPP14ParserLeftParen, CPP14ParserLeftBracket, CPP14ParserPlus, CPP14ParserMinus, CPP14ParserStar, CPP14ParserAnd, CPP14ParserOr, CPP14ParserTilde, CPP14ParserNot, CPP14ParserPlusPlus, CPP14ParserMinusMinus, CPP14ParserDoublecolon, CPP14ParserIdentifier:
			{
				p.SetState(960)
				p.Expression()
			}

		case CPP14ParserLeftBrace:
			{
				p.SetState(961)
				p.BracedInitList()
			}

		case CPP14ParserSemi:

		default:
		}

	case CPP14ParserGoto:
		{
			p.SetState(964)
			p.Match(CPP14ParserGoto)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(965)
			p.Match(CPP14ParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(968)
		p.Match(CPP14ParserSemi)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclarationStatementContext is an interface to support dynamic dispatch.
type IDeclarationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BlockDeclaration() IBlockDeclarationContext

	// IsDeclarationStatementContext differentiates from other interfaces.
	IsDeclarationStatementContext()
}

type DeclarationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclarationStatementContext() *DeclarationStatementContext {
	var p = new(DeclarationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_declarationStatement
	return p
}

func InitEmptyDeclarationStatementContext(p *DeclarationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_declarationStatement
}

func (*DeclarationStatementContext) IsDeclarationStatementContext() {}

func NewDeclarationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclarationStatementContext {
	var p = new(DeclarationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_declarationStatement

	return p
}

func (s *DeclarationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclarationStatementContext) BlockDeclaration() IBlockDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockDeclarationContext)
}

func (s *DeclarationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclarationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclarationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterDeclarationStatement(s)
	}
}

func (s *DeclarationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitDeclarationStatement(s)
	}
}

func (s *DeclarationStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitDeclarationStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) DeclarationStatement() (localctx IDeclarationStatementContext) {
	localctx = NewDeclarationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, CPP14ParserRULE_declarationStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(970)
		p.BlockDeclaration()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclarationseqContext is an interface to support dynamic dispatch.
type IDeclarationseqContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllDeclaration() []IDeclarationContext
	Declaration(i int) IDeclarationContext

	// IsDeclarationseqContext differentiates from other interfaces.
	IsDeclarationseqContext()
}

type DeclarationseqContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclarationseqContext() *DeclarationseqContext {
	var p = new(DeclarationseqContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_declarationseq
	return p
}

func InitEmptyDeclarationseqContext(p *DeclarationseqContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_declarationseq
}

func (*DeclarationseqContext) IsDeclarationseqContext() {}

func NewDeclarationseqContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclarationseqContext {
	var p = new(DeclarationseqContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_declarationseq

	return p
}

func (s *DeclarationseqContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclarationseqContext) AllDeclaration() []IDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeclarationContext); ok {
			tst[i] = t.(IDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *DeclarationseqContext) Declaration(i int) IDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *DeclarationseqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclarationseqContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclarationseqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterDeclarationseq(s)
	}
}

func (s *DeclarationseqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitDeclarationseq(s)
	}
}

func (s *DeclarationseqContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitDeclarationseq(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) Declarationseq() (localctx IDeclarationseqContext) {
	localctx = NewDeclarationseqContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, CPP14ParserRULE_declarationseq)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(973)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64((_la-10)) & ^0x3f) == 0 && ((int64(1)<<(_la-10))&1543754443169808157) != 0) || ((int64((_la-74)) & ^0x3f) == 0 && ((int64(1)<<(_la-74))&459384754220313597) != 0) {
		{
			p.SetState(972)
			p.Declaration()
		}

		p.SetState(975)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclarationContext is an interface to support dynamic dispatch.
type IDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BlockDeclaration() IBlockDeclarationContext
	FunctionDefinition() IFunctionDefinitionContext
	TemplateDeclaration() ITemplateDeclarationContext
	ExplicitInstantiation() IExplicitInstantiationContext
	ExplicitSpecialization() IExplicitSpecializationContext
	LinkageSpecification() ILinkageSpecificationContext
	NamespaceDefinition() INamespaceDefinitionContext
	EmptyDeclaration_() IEmptyDeclaration_Context
	AttributeDeclaration() IAttributeDeclarationContext

	// IsDeclarationContext differentiates from other interfaces.
	IsDeclarationContext()
}

type DeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclarationContext() *DeclarationContext {
	var p = new(DeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_declaration
	return p
}

func InitEmptyDeclarationContext(p *DeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_declaration
}

func (*DeclarationContext) IsDeclarationContext() {}

func NewDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclarationContext {
	var p = new(DeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_declaration

	return p
}

func (s *DeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclarationContext) BlockDeclaration() IBlockDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockDeclarationContext)
}

func (s *DeclarationContext) FunctionDefinition() IFunctionDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDefinitionContext)
}

func (s *DeclarationContext) TemplateDeclaration() ITemplateDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITemplateDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITemplateDeclarationContext)
}

func (s *DeclarationContext) ExplicitInstantiation() IExplicitInstantiationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplicitInstantiationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplicitInstantiationContext)
}

func (s *DeclarationContext) ExplicitSpecialization() IExplicitSpecializationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplicitSpecializationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplicitSpecializationContext)
}

func (s *DeclarationContext) LinkageSpecification() ILinkageSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILinkageSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILinkageSpecificationContext)
}

func (s *DeclarationContext) NamespaceDefinition() INamespaceDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceDefinitionContext)
}

func (s *DeclarationContext) EmptyDeclaration_() IEmptyDeclaration_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyDeclaration_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyDeclaration_Context)
}

func (s *DeclarationContext) AttributeDeclaration() IAttributeDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeDeclarationContext)
}

func (s *DeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterDeclaration(s)
	}
}

func (s *DeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitDeclaration(s)
	}
}

func (s *DeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) Declaration() (localctx IDeclarationContext) {
	localctx = NewDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, CPP14ParserRULE_declaration)
	p.SetState(986)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 96, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(977)
			p.BlockDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(978)
			p.FunctionDefinition()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(979)
			p.TemplateDeclaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(980)
			p.ExplicitInstantiation()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(981)
			p.ExplicitSpecialization()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(982)
			p.LinkageSpecification()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(983)
			p.NamespaceDefinition()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(984)
			p.EmptyDeclaration_()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(985)
			p.AttributeDeclaration()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBlockDeclarationContext is an interface to support dynamic dispatch.
type IBlockDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleDeclaration() ISimpleDeclarationContext
	AsmDefinition() IAsmDefinitionContext
	NamespaceAliasDefinition() INamespaceAliasDefinitionContext
	UsingDeclaration() IUsingDeclarationContext
	UsingDirective() IUsingDirectiveContext
	StaticAssertDeclaration() IStaticAssertDeclarationContext
	AliasDeclaration() IAliasDeclarationContext
	OpaqueEnumDeclaration() IOpaqueEnumDeclarationContext

	// IsBlockDeclarationContext differentiates from other interfaces.
	IsBlockDeclarationContext()
}

type BlockDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockDeclarationContext() *BlockDeclarationContext {
	var p = new(BlockDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_blockDeclaration
	return p
}

func InitEmptyBlockDeclarationContext(p *BlockDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_blockDeclaration
}

func (*BlockDeclarationContext) IsBlockDeclarationContext() {}

func NewBlockDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockDeclarationContext {
	var p = new(BlockDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_blockDeclaration

	return p
}

func (s *BlockDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockDeclarationContext) SimpleDeclaration() ISimpleDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleDeclarationContext)
}

func (s *BlockDeclarationContext) AsmDefinition() IAsmDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAsmDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAsmDefinitionContext)
}

func (s *BlockDeclarationContext) NamespaceAliasDefinition() INamespaceAliasDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceAliasDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceAliasDefinitionContext)
}

func (s *BlockDeclarationContext) UsingDeclaration() IUsingDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsingDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsingDeclarationContext)
}

func (s *BlockDeclarationContext) UsingDirective() IUsingDirectiveContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsingDirectiveContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsingDirectiveContext)
}

func (s *BlockDeclarationContext) StaticAssertDeclaration() IStaticAssertDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStaticAssertDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStaticAssertDeclarationContext)
}

func (s *BlockDeclarationContext) AliasDeclaration() IAliasDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasDeclarationContext)
}

func (s *BlockDeclarationContext) OpaqueEnumDeclaration() IOpaqueEnumDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpaqueEnumDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpaqueEnumDeclarationContext)
}

func (s *BlockDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterBlockDeclaration(s)
	}
}

func (s *BlockDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitBlockDeclaration(s)
	}
}

func (s *BlockDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitBlockDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) BlockDeclaration() (localctx IBlockDeclarationContext) {
	localctx = NewBlockDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, CPP14ParserRULE_blockDeclaration)
	p.SetState(996)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 97, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(988)
			p.SimpleDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(989)
			p.AsmDefinition()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(990)
			p.NamespaceAliasDefinition()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(991)
			p.UsingDeclaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(992)
			p.UsingDirective()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(993)
			p.StaticAssertDeclaration()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(994)
			p.AliasDeclaration()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(995)
			p.OpaqueEnumDeclaration()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAliasDeclarationContext is an interface to support dynamic dispatch.
type IAliasDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Using() antlr.TerminalNode
	Identifier() antlr.TerminalNode
	Assign() antlr.TerminalNode
	TheTypeId() ITheTypeIdContext
	Semi() antlr.TerminalNode
	AttributeSpecifierSeq() IAttributeSpecifierSeqContext

	// IsAliasDeclarationContext differentiates from other interfaces.
	IsAliasDeclarationContext()
}

type AliasDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAliasDeclarationContext() *AliasDeclarationContext {
	var p = new(AliasDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_aliasDeclaration
	return p
}

func InitEmptyAliasDeclarationContext(p *AliasDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_aliasDeclaration
}

func (*AliasDeclarationContext) IsAliasDeclarationContext() {}

func NewAliasDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AliasDeclarationContext {
	var p = new(AliasDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_aliasDeclaration

	return p
}

func (s *AliasDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *AliasDeclarationContext) Using() antlr.TerminalNode {
	return s.GetToken(CPP14ParserUsing, 0)
}

func (s *AliasDeclarationContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CPP14ParserIdentifier, 0)
}

func (s *AliasDeclarationContext) Assign() antlr.TerminalNode {
	return s.GetToken(CPP14ParserAssign, 0)
}

func (s *AliasDeclarationContext) TheTypeId() ITheTypeIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITheTypeIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITheTypeIdContext)
}

func (s *AliasDeclarationContext) Semi() antlr.TerminalNode {
	return s.GetToken(CPP14ParserSemi, 0)
}

func (s *AliasDeclarationContext) AttributeSpecifierSeq() IAttributeSpecifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSpecifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSpecifierSeqContext)
}

func (s *AliasDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AliasDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterAliasDeclaration(s)
	}
}

func (s *AliasDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitAliasDeclaration(s)
	}
}

func (s *AliasDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitAliasDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) AliasDeclaration() (localctx IAliasDeclarationContext) {
	localctx = NewAliasDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, CPP14ParserRULE_aliasDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(998)
		p.Match(CPP14ParserUsing)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(999)
		p.Match(CPP14ParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1001)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CPP14ParserAlignas || _la == CPP14ParserLeftBracket {
		{
			p.SetState(1000)
			p.AttributeSpecifierSeq()
		}

	}
	{
		p.SetState(1003)
		p.Match(CPP14ParserAssign)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1004)
		p.TheTypeId()
	}
	{
		p.SetState(1005)
		p.Match(CPP14ParserSemi)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleDeclarationContext is an interface to support dynamic dispatch.
type ISimpleDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Semi() antlr.TerminalNode
	DeclSpecifierSeq() IDeclSpecifierSeqContext
	InitDeclaratorList() IInitDeclaratorListContext
	AttributeSpecifierSeq() IAttributeSpecifierSeqContext

	// IsSimpleDeclarationContext differentiates from other interfaces.
	IsSimpleDeclarationContext()
}

type SimpleDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleDeclarationContext() *SimpleDeclarationContext {
	var p = new(SimpleDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_simpleDeclaration
	return p
}

func InitEmptySimpleDeclarationContext(p *SimpleDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_simpleDeclaration
}

func (*SimpleDeclarationContext) IsSimpleDeclarationContext() {}

func NewSimpleDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleDeclarationContext {
	var p = new(SimpleDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_simpleDeclaration

	return p
}

func (s *SimpleDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleDeclarationContext) Semi() antlr.TerminalNode {
	return s.GetToken(CPP14ParserSemi, 0)
}

func (s *SimpleDeclarationContext) DeclSpecifierSeq() IDeclSpecifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclSpecifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclSpecifierSeqContext)
}

func (s *SimpleDeclarationContext) InitDeclaratorList() IInitDeclaratorListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitDeclaratorListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitDeclaratorListContext)
}

func (s *SimpleDeclarationContext) AttributeSpecifierSeq() IAttributeSpecifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSpecifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSpecifierSeqContext)
}

func (s *SimpleDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterSimpleDeclaration(s)
	}
}

func (s *SimpleDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitSimpleDeclaration(s)
	}
}

func (s *SimpleDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitSimpleDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) SimpleDeclaration() (localctx ISimpleDeclarationContext) {
	localctx = NewSimpleDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, CPP14ParserRULE_simpleDeclaration)
	var _la int

	p.SetState(1021)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CPP14ParserAuto, CPP14ParserBool, CPP14ParserChar, CPP14ParserChar16, CPP14ParserChar32, CPP14ParserClass, CPP14ParserConst, CPP14ParserConstexpr, CPP14ParserDecltype, CPP14ParserDouble, CPP14ParserEnum, CPP14ParserExplicit, CPP14ParserExtern, CPP14ParserFloat, CPP14ParserFriend, CPP14ParserInline, CPP14ParserInt, CPP14ParserLong, CPP14ParserMutable, CPP14ParserOperator, CPP14ParserRegister, CPP14ParserShort, CPP14ParserSigned, CPP14ParserStatic, CPP14ParserStruct, CPP14ParserThread_local, CPP14ParserTypedef, CPP14ParserTypename_, CPP14ParserUnion, CPP14ParserUnsigned, CPP14ParserVirtual, CPP14ParserVoid, CPP14ParserVolatile, CPP14ParserWchar, CPP14ParserLeftParen, CPP14ParserStar, CPP14ParserAnd, CPP14ParserTilde, CPP14ParserAndAnd, CPP14ParserDoublecolon, CPP14ParserSemi, CPP14ParserEllipsis, CPP14ParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1008)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 99, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1007)
				p.DeclSpecifierSeq()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1011)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CPP14ParserDecltype || _la == CPP14ParserOperator || ((int64((_la-85)) & ^0x3f) == 0 && ((int64(1)<<(_la-85))&215512868999425) != 0) {
			{
				p.SetState(1010)
				p.InitDeclaratorList()
			}

		}
		{
			p.SetState(1013)
			p.Match(CPP14ParserSemi)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case CPP14ParserAlignas, CPP14ParserLeftBracket:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1014)
			p.AttributeSpecifierSeq()
		}
		p.SetState(1016)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 101, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1015)
				p.DeclSpecifierSeq()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1018)
			p.InitDeclaratorList()
		}
		{
			p.SetState(1019)
			p.Match(CPP14ParserSemi)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStaticAssertDeclarationContext is an interface to support dynamic dispatch.
type IStaticAssertDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Static_assert() antlr.TerminalNode
	LeftParen() antlr.TerminalNode
	ConstantExpression() IConstantExpressionContext
	Comma() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode
	RightParen() antlr.TerminalNode
	Semi() antlr.TerminalNode

	// IsStaticAssertDeclarationContext differentiates from other interfaces.
	IsStaticAssertDeclarationContext()
}

type StaticAssertDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStaticAssertDeclarationContext() *StaticAssertDeclarationContext {
	var p = new(StaticAssertDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_staticAssertDeclaration
	return p
}

func InitEmptyStaticAssertDeclarationContext(p *StaticAssertDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_staticAssertDeclaration
}

func (*StaticAssertDeclarationContext) IsStaticAssertDeclarationContext() {}

func NewStaticAssertDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StaticAssertDeclarationContext {
	var p = new(StaticAssertDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_staticAssertDeclaration

	return p
}

func (s *StaticAssertDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *StaticAssertDeclarationContext) Static_assert() antlr.TerminalNode {
	return s.GetToken(CPP14ParserStatic_assert, 0)
}

func (s *StaticAssertDeclarationContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CPP14ParserLeftParen, 0)
}

func (s *StaticAssertDeclarationContext) ConstantExpression() IConstantExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantExpressionContext)
}

func (s *StaticAssertDeclarationContext) Comma() antlr.TerminalNode {
	return s.GetToken(CPP14ParserComma, 0)
}

func (s *StaticAssertDeclarationContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(CPP14ParserStringLiteral, 0)
}

func (s *StaticAssertDeclarationContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CPP14ParserRightParen, 0)
}

func (s *StaticAssertDeclarationContext) Semi() antlr.TerminalNode {
	return s.GetToken(CPP14ParserSemi, 0)
}

func (s *StaticAssertDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StaticAssertDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StaticAssertDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterStaticAssertDeclaration(s)
	}
}

func (s *StaticAssertDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitStaticAssertDeclaration(s)
	}
}

func (s *StaticAssertDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitStaticAssertDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) StaticAssertDeclaration() (localctx IStaticAssertDeclarationContext) {
	localctx = NewStaticAssertDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, CPP14ParserRULE_staticAssertDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1023)
		p.Match(CPP14ParserStatic_assert)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1024)
		p.Match(CPP14ParserLeftParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1025)
		p.ConstantExpression()
	}
	{
		p.SetState(1026)
		p.Match(CPP14ParserComma)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1027)
		p.Match(CPP14ParserStringLiteral)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1028)
		p.Match(CPP14ParserRightParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1029)
		p.Match(CPP14ParserSemi)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEmptyDeclaration_Context is an interface to support dynamic dispatch.
type IEmptyDeclaration_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Semi() antlr.TerminalNode

	// IsEmptyDeclaration_Context differentiates from other interfaces.
	IsEmptyDeclaration_Context()
}

type EmptyDeclaration_Context struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmptyDeclaration_Context() *EmptyDeclaration_Context {
	var p = new(EmptyDeclaration_Context)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_emptyDeclaration_
	return p
}

func InitEmptyEmptyDeclaration_Context(p *EmptyDeclaration_Context) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_emptyDeclaration_
}

func (*EmptyDeclaration_Context) IsEmptyDeclaration_Context() {}

func NewEmptyDeclaration_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EmptyDeclaration_Context {
	var p = new(EmptyDeclaration_Context)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_emptyDeclaration_

	return p
}

func (s *EmptyDeclaration_Context) GetParser() antlr.Parser { return s.parser }

func (s *EmptyDeclaration_Context) Semi() antlr.TerminalNode {
	return s.GetToken(CPP14ParserSemi, 0)
}

func (s *EmptyDeclaration_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EmptyDeclaration_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EmptyDeclaration_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterEmptyDeclaration_(s)
	}
}

func (s *EmptyDeclaration_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitEmptyDeclaration_(s)
	}
}

func (s *EmptyDeclaration_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitEmptyDeclaration_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) EmptyDeclaration_() (localctx IEmptyDeclaration_Context) {
	localctx = NewEmptyDeclaration_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, CPP14ParserRULE_emptyDeclaration_)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1031)
		p.Match(CPP14ParserSemi)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeDeclarationContext is an interface to support dynamic dispatch.
type IAttributeDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AttributeSpecifierSeq() IAttributeSpecifierSeqContext
	Semi() antlr.TerminalNode

	// IsAttributeDeclarationContext differentiates from other interfaces.
	IsAttributeDeclarationContext()
}

type AttributeDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeDeclarationContext() *AttributeDeclarationContext {
	var p = new(AttributeDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_attributeDeclaration
	return p
}

func InitEmptyAttributeDeclarationContext(p *AttributeDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_attributeDeclaration
}

func (*AttributeDeclarationContext) IsAttributeDeclarationContext() {}

func NewAttributeDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeDeclarationContext {
	var p = new(AttributeDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_attributeDeclaration

	return p
}

func (s *AttributeDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeDeclarationContext) AttributeSpecifierSeq() IAttributeSpecifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSpecifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSpecifierSeqContext)
}

func (s *AttributeDeclarationContext) Semi() antlr.TerminalNode {
	return s.GetToken(CPP14ParserSemi, 0)
}

func (s *AttributeDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterAttributeDeclaration(s)
	}
}

func (s *AttributeDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitAttributeDeclaration(s)
	}
}

func (s *AttributeDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitAttributeDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) AttributeDeclaration() (localctx IAttributeDeclarationContext) {
	localctx = NewAttributeDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, CPP14ParserRULE_attributeDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1033)
		p.AttributeSpecifierSeq()
	}
	{
		p.SetState(1034)
		p.Match(CPP14ParserSemi)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclSpecifierContext is an interface to support dynamic dispatch.
type IDeclSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	StorageClassSpecifier() IStorageClassSpecifierContext
	TypeSpecifier() ITypeSpecifierContext
	FunctionSpecifier() IFunctionSpecifierContext
	Friend() antlr.TerminalNode
	Typedef() antlr.TerminalNode
	Constexpr() antlr.TerminalNode

	// IsDeclSpecifierContext differentiates from other interfaces.
	IsDeclSpecifierContext()
}

type DeclSpecifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclSpecifierContext() *DeclSpecifierContext {
	var p = new(DeclSpecifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_declSpecifier
	return p
}

func InitEmptyDeclSpecifierContext(p *DeclSpecifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_declSpecifier
}

func (*DeclSpecifierContext) IsDeclSpecifierContext() {}

func NewDeclSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclSpecifierContext {
	var p = new(DeclSpecifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_declSpecifier

	return p
}

func (s *DeclSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclSpecifierContext) StorageClassSpecifier() IStorageClassSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStorageClassSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStorageClassSpecifierContext)
}

func (s *DeclSpecifierContext) TypeSpecifier() ITypeSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSpecifierContext)
}

func (s *DeclSpecifierContext) FunctionSpecifier() IFunctionSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionSpecifierContext)
}

func (s *DeclSpecifierContext) Friend() antlr.TerminalNode {
	return s.GetToken(CPP14ParserFriend, 0)
}

func (s *DeclSpecifierContext) Typedef() antlr.TerminalNode {
	return s.GetToken(CPP14ParserTypedef, 0)
}

func (s *DeclSpecifierContext) Constexpr() antlr.TerminalNode {
	return s.GetToken(CPP14ParserConstexpr, 0)
}

func (s *DeclSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterDeclSpecifier(s)
	}
}

func (s *DeclSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitDeclSpecifier(s)
	}
}

func (s *DeclSpecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitDeclSpecifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) DeclSpecifier() (localctx IDeclSpecifierContext) {
	localctx = NewDeclSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, CPP14ParserRULE_declSpecifier)
	p.SetState(1042)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CPP14ParserExtern, CPP14ParserMutable, CPP14ParserRegister, CPP14ParserStatic, CPP14ParserThread_local:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1036)
			p.StorageClassSpecifier()
		}

	case CPP14ParserAuto, CPP14ParserBool, CPP14ParserChar, CPP14ParserChar16, CPP14ParserChar32, CPP14ParserClass, CPP14ParserConst, CPP14ParserDecltype, CPP14ParserDouble, CPP14ParserEnum, CPP14ParserFloat, CPP14ParserInt, CPP14ParserLong, CPP14ParserShort, CPP14ParserSigned, CPP14ParserStruct, CPP14ParserTypename_, CPP14ParserUnion, CPP14ParserUnsigned, CPP14ParserVoid, CPP14ParserVolatile, CPP14ParserWchar, CPP14ParserDoublecolon, CPP14ParserIdentifier:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1037)
			p.TypeSpecifier()
		}

	case CPP14ParserExplicit, CPP14ParserInline, CPP14ParserVirtual:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1038)
			p.FunctionSpecifier()
		}

	case CPP14ParserFriend:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1039)
			p.Match(CPP14ParserFriend)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case CPP14ParserTypedef:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1040)
			p.Match(CPP14ParserTypedef)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case CPP14ParserConstexpr:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1041)
			p.Match(CPP14ParserConstexpr)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclSpecifierSeqContext is an interface to support dynamic dispatch.
type IDeclSpecifierSeqContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllDeclSpecifier() []IDeclSpecifierContext
	DeclSpecifier(i int) IDeclSpecifierContext
	AttributeSpecifierSeq() IAttributeSpecifierSeqContext

	// IsDeclSpecifierSeqContext differentiates from other interfaces.
	IsDeclSpecifierSeqContext()
}

type DeclSpecifierSeqContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclSpecifierSeqContext() *DeclSpecifierSeqContext {
	var p = new(DeclSpecifierSeqContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_declSpecifierSeq
	return p
}

func InitEmptyDeclSpecifierSeqContext(p *DeclSpecifierSeqContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_declSpecifierSeq
}

func (*DeclSpecifierSeqContext) IsDeclSpecifierSeqContext() {}

func NewDeclSpecifierSeqContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclSpecifierSeqContext {
	var p = new(DeclSpecifierSeqContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_declSpecifierSeq

	return p
}

func (s *DeclSpecifierSeqContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclSpecifierSeqContext) AllDeclSpecifier() []IDeclSpecifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeclSpecifierContext); ok {
			len++
		}
	}

	tst := make([]IDeclSpecifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeclSpecifierContext); ok {
			tst[i] = t.(IDeclSpecifierContext)
			i++
		}
	}

	return tst
}

func (s *DeclSpecifierSeqContext) DeclSpecifier(i int) IDeclSpecifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclSpecifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclSpecifierContext)
}

func (s *DeclSpecifierSeqContext) AttributeSpecifierSeq() IAttributeSpecifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSpecifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSpecifierSeqContext)
}

func (s *DeclSpecifierSeqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclSpecifierSeqContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclSpecifierSeqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterDeclSpecifierSeq(s)
	}
}

func (s *DeclSpecifierSeqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitDeclSpecifierSeq(s)
	}
}

func (s *DeclSpecifierSeqContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitDeclSpecifierSeq(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) DeclSpecifierSeq() (localctx IDeclSpecifierSeqContext) {
	localctx = NewDeclSpecifierSeqContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, CPP14ParserRULE_declSpecifierSeq)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1045)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1 + 1
	for ok := true; ok; ok = _alt != 1 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1 + 1:
			{
				p.SetState(1044)
				p.DeclSpecifier()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(1047)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 104, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1050)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 105, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1049)
			p.AttributeSpecifierSeq()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStorageClassSpecifierContext is an interface to support dynamic dispatch.
type IStorageClassSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Register() antlr.TerminalNode
	Static() antlr.TerminalNode
	Thread_local() antlr.TerminalNode
	Extern() antlr.TerminalNode
	Mutable() antlr.TerminalNode

	// IsStorageClassSpecifierContext differentiates from other interfaces.
	IsStorageClassSpecifierContext()
}

type StorageClassSpecifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStorageClassSpecifierContext() *StorageClassSpecifierContext {
	var p = new(StorageClassSpecifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_storageClassSpecifier
	return p
}

func InitEmptyStorageClassSpecifierContext(p *StorageClassSpecifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_storageClassSpecifier
}

func (*StorageClassSpecifierContext) IsStorageClassSpecifierContext() {}

func NewStorageClassSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StorageClassSpecifierContext {
	var p = new(StorageClassSpecifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_storageClassSpecifier

	return p
}

func (s *StorageClassSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *StorageClassSpecifierContext) Register() antlr.TerminalNode {
	return s.GetToken(CPP14ParserRegister, 0)
}

func (s *StorageClassSpecifierContext) Static() antlr.TerminalNode {
	return s.GetToken(CPP14ParserStatic, 0)
}

func (s *StorageClassSpecifierContext) Thread_local() antlr.TerminalNode {
	return s.GetToken(CPP14ParserThread_local, 0)
}

func (s *StorageClassSpecifierContext) Extern() antlr.TerminalNode {
	return s.GetToken(CPP14ParserExtern, 0)
}

func (s *StorageClassSpecifierContext) Mutable() antlr.TerminalNode {
	return s.GetToken(CPP14ParserMutable, 0)
}

func (s *StorageClassSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StorageClassSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StorageClassSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterStorageClassSpecifier(s)
	}
}

func (s *StorageClassSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitStorageClassSpecifier(s)
	}
}

func (s *StorageClassSpecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitStorageClassSpecifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) StorageClassSpecifier() (localctx IStorageClassSpecifierContext) {
	localctx = NewStorageClassSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, CPP14ParserRULE_storageClassSpecifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1052)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-36)) & ^0x3f) == 0 && ((int64(1)<<(_la-36))&17316186113) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionSpecifierContext is an interface to support dynamic dispatch.
type IFunctionSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Inline() antlr.TerminalNode
	Virtual() antlr.TerminalNode
	Explicit() antlr.TerminalNode

	// IsFunctionSpecifierContext differentiates from other interfaces.
	IsFunctionSpecifierContext()
}

type FunctionSpecifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionSpecifierContext() *FunctionSpecifierContext {
	var p = new(FunctionSpecifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_functionSpecifier
	return p
}

func InitEmptyFunctionSpecifierContext(p *FunctionSpecifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_functionSpecifier
}

func (*FunctionSpecifierContext) IsFunctionSpecifierContext() {}

func NewFunctionSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionSpecifierContext {
	var p = new(FunctionSpecifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_functionSpecifier

	return p
}

func (s *FunctionSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionSpecifierContext) Inline() antlr.TerminalNode {
	return s.GetToken(CPP14ParserInline, 0)
}

func (s *FunctionSpecifierContext) Virtual() antlr.TerminalNode {
	return s.GetToken(CPP14ParserVirtual, 0)
}

func (s *FunctionSpecifierContext) Explicit() antlr.TerminalNode {
	return s.GetToken(CPP14ParserExplicit, 0)
}

func (s *FunctionSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterFunctionSpecifier(s)
	}
}

func (s *FunctionSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitFunctionSpecifier(s)
	}
}

func (s *FunctionSpecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitFunctionSpecifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) FunctionSpecifier() (localctx IFunctionSpecifierContext) {
	localctx = NewFunctionSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, CPP14ParserRULE_functionSpecifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1054)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-34)) & ^0x3f) == 0 && ((int64(1)<<(_la-34))&70368744178689) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypedefNameContext is an interface to support dynamic dispatch.
type ITypedefNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode

	// IsTypedefNameContext differentiates from other interfaces.
	IsTypedefNameContext()
}

type TypedefNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypedefNameContext() *TypedefNameContext {
	var p = new(TypedefNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_typedefName
	return p
}

func InitEmptyTypedefNameContext(p *TypedefNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_typedefName
}

func (*TypedefNameContext) IsTypedefNameContext() {}

func NewTypedefNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypedefNameContext {
	var p = new(TypedefNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_typedefName

	return p
}

func (s *TypedefNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TypedefNameContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CPP14ParserIdentifier, 0)
}

func (s *TypedefNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypedefNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypedefNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterTypedefName(s)
	}
}

func (s *TypedefNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitTypedefName(s)
	}
}

func (s *TypedefNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitTypedefName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) TypedefName() (localctx ITypedefNameContext) {
	localctx = NewTypedefNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, CPP14ParserRULE_typedefName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1056)
		p.Match(CPP14ParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeSpecifierContext is an interface to support dynamic dispatch.
type ITypeSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TrailingTypeSpecifier() ITrailingTypeSpecifierContext
	ClassSpecifier() IClassSpecifierContext
	EnumSpecifier() IEnumSpecifierContext

	// IsTypeSpecifierContext differentiates from other interfaces.
	IsTypeSpecifierContext()
}

type TypeSpecifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeSpecifierContext() *TypeSpecifierContext {
	var p = new(TypeSpecifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_typeSpecifier
	return p
}

func InitEmptyTypeSpecifierContext(p *TypeSpecifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_typeSpecifier
}

func (*TypeSpecifierContext) IsTypeSpecifierContext() {}

func NewTypeSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeSpecifierContext {
	var p = new(TypeSpecifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_typeSpecifier

	return p
}

func (s *TypeSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeSpecifierContext) TrailingTypeSpecifier() ITrailingTypeSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITrailingTypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITrailingTypeSpecifierContext)
}

func (s *TypeSpecifierContext) ClassSpecifier() IClassSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassSpecifierContext)
}

func (s *TypeSpecifierContext) EnumSpecifier() IEnumSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumSpecifierContext)
}

func (s *TypeSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterTypeSpecifier(s)
	}
}

func (s *TypeSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitTypeSpecifier(s)
	}
}

func (s *TypeSpecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitTypeSpecifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) TypeSpecifier() (localctx ITypeSpecifierContext) {
	localctx = NewTypeSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, CPP14ParserRULE_typeSpecifier)
	p.SetState(1061)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 106, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1058)
			p.TrailingTypeSpecifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1059)
			p.ClassSpecifier()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1060)
			p.EnumSpecifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITrailingTypeSpecifierContext is an interface to support dynamic dispatch.
type ITrailingTypeSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleTypeSpecifier() ISimpleTypeSpecifierContext
	ElaboratedTypeSpecifier() IElaboratedTypeSpecifierContext
	TypeNameSpecifier() ITypeNameSpecifierContext
	CvQualifier() ICvQualifierContext

	// IsTrailingTypeSpecifierContext differentiates from other interfaces.
	IsTrailingTypeSpecifierContext()
}

type TrailingTypeSpecifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTrailingTypeSpecifierContext() *TrailingTypeSpecifierContext {
	var p = new(TrailingTypeSpecifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_trailingTypeSpecifier
	return p
}

func InitEmptyTrailingTypeSpecifierContext(p *TrailingTypeSpecifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_trailingTypeSpecifier
}

func (*TrailingTypeSpecifierContext) IsTrailingTypeSpecifierContext() {}

func NewTrailingTypeSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TrailingTypeSpecifierContext {
	var p = new(TrailingTypeSpecifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_trailingTypeSpecifier

	return p
}

func (s *TrailingTypeSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TrailingTypeSpecifierContext) SimpleTypeSpecifier() ISimpleTypeSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleTypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleTypeSpecifierContext)
}

func (s *TrailingTypeSpecifierContext) ElaboratedTypeSpecifier() IElaboratedTypeSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElaboratedTypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElaboratedTypeSpecifierContext)
}

func (s *TrailingTypeSpecifierContext) TypeNameSpecifier() ITypeNameSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameSpecifierContext)
}

func (s *TrailingTypeSpecifierContext) CvQualifier() ICvQualifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICvQualifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICvQualifierContext)
}

func (s *TrailingTypeSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TrailingTypeSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TrailingTypeSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterTrailingTypeSpecifier(s)
	}
}

func (s *TrailingTypeSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitTrailingTypeSpecifier(s)
	}
}

func (s *TrailingTypeSpecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitTrailingTypeSpecifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) TrailingTypeSpecifier() (localctx ITrailingTypeSpecifierContext) {
	localctx = NewTrailingTypeSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, CPP14ParserRULE_trailingTypeSpecifier)
	p.SetState(1067)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CPP14ParserAuto, CPP14ParserBool, CPP14ParserChar, CPP14ParserChar16, CPP14ParserChar32, CPP14ParserDecltype, CPP14ParserDouble, CPP14ParserFloat, CPP14ParserInt, CPP14ParserLong, CPP14ParserShort, CPP14ParserSigned, CPP14ParserUnsigned, CPP14ParserVoid, CPP14ParserWchar, CPP14ParserDoublecolon, CPP14ParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1063)
			p.SimpleTypeSpecifier()
		}

	case CPP14ParserClass, CPP14ParserEnum, CPP14ParserStruct:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1064)
			p.ElaboratedTypeSpecifier()
		}

	case CPP14ParserTypename_:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1065)
			p.TypeNameSpecifier()
		}

	case CPP14ParserConst, CPP14ParserVolatile:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1066)
			p.CvQualifier()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeSpecifierSeqContext is an interface to support dynamic dispatch.
type ITypeSpecifierSeqContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTypeSpecifier() []ITypeSpecifierContext
	TypeSpecifier(i int) ITypeSpecifierContext
	AttributeSpecifierSeq() IAttributeSpecifierSeqContext

	// IsTypeSpecifierSeqContext differentiates from other interfaces.
	IsTypeSpecifierSeqContext()
}

type TypeSpecifierSeqContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeSpecifierSeqContext() *TypeSpecifierSeqContext {
	var p = new(TypeSpecifierSeqContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_typeSpecifierSeq
	return p
}

func InitEmptyTypeSpecifierSeqContext(p *TypeSpecifierSeqContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_typeSpecifierSeq
}

func (*TypeSpecifierSeqContext) IsTypeSpecifierSeqContext() {}

func NewTypeSpecifierSeqContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeSpecifierSeqContext {
	var p = new(TypeSpecifierSeqContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_typeSpecifierSeq

	return p
}

func (s *TypeSpecifierSeqContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeSpecifierSeqContext) AllTypeSpecifier() []ITypeSpecifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeSpecifierContext); ok {
			len++
		}
	}

	tst := make([]ITypeSpecifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeSpecifierContext); ok {
			tst[i] = t.(ITypeSpecifierContext)
			i++
		}
	}

	return tst
}

func (s *TypeSpecifierSeqContext) TypeSpecifier(i int) ITypeSpecifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSpecifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSpecifierContext)
}

func (s *TypeSpecifierSeqContext) AttributeSpecifierSeq() IAttributeSpecifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSpecifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSpecifierSeqContext)
}

func (s *TypeSpecifierSeqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeSpecifierSeqContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeSpecifierSeqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterTypeSpecifierSeq(s)
	}
}

func (s *TypeSpecifierSeqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitTypeSpecifierSeq(s)
	}
}

func (s *TypeSpecifierSeqContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitTypeSpecifierSeq(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) TypeSpecifierSeq() (localctx ITypeSpecifierSeqContext) {
	localctx = NewTypeSpecifierSeqContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, CPP14ParserRULE_typeSpecifierSeq)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1070)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1069)
				p.TypeSpecifier()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(1072)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 108, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1075)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 109, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1074)
			p.AttributeSpecifierSeq()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITrailingTypeSpecifierSeqContext is an interface to support dynamic dispatch.
type ITrailingTypeSpecifierSeqContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTrailingTypeSpecifier() []ITrailingTypeSpecifierContext
	TrailingTypeSpecifier(i int) ITrailingTypeSpecifierContext
	AttributeSpecifierSeq() IAttributeSpecifierSeqContext

	// IsTrailingTypeSpecifierSeqContext differentiates from other interfaces.
	IsTrailingTypeSpecifierSeqContext()
}

type TrailingTypeSpecifierSeqContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTrailingTypeSpecifierSeqContext() *TrailingTypeSpecifierSeqContext {
	var p = new(TrailingTypeSpecifierSeqContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_trailingTypeSpecifierSeq
	return p
}

func InitEmptyTrailingTypeSpecifierSeqContext(p *TrailingTypeSpecifierSeqContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_trailingTypeSpecifierSeq
}

func (*TrailingTypeSpecifierSeqContext) IsTrailingTypeSpecifierSeqContext() {}

func NewTrailingTypeSpecifierSeqContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TrailingTypeSpecifierSeqContext {
	var p = new(TrailingTypeSpecifierSeqContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_trailingTypeSpecifierSeq

	return p
}

func (s *TrailingTypeSpecifierSeqContext) GetParser() antlr.Parser { return s.parser }

func (s *TrailingTypeSpecifierSeqContext) AllTrailingTypeSpecifier() []ITrailingTypeSpecifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITrailingTypeSpecifierContext); ok {
			len++
		}
	}

	tst := make([]ITrailingTypeSpecifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITrailingTypeSpecifierContext); ok {
			tst[i] = t.(ITrailingTypeSpecifierContext)
			i++
		}
	}

	return tst
}

func (s *TrailingTypeSpecifierSeqContext) TrailingTypeSpecifier(i int) ITrailingTypeSpecifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITrailingTypeSpecifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITrailingTypeSpecifierContext)
}

func (s *TrailingTypeSpecifierSeqContext) AttributeSpecifierSeq() IAttributeSpecifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSpecifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSpecifierSeqContext)
}

func (s *TrailingTypeSpecifierSeqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TrailingTypeSpecifierSeqContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TrailingTypeSpecifierSeqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterTrailingTypeSpecifierSeq(s)
	}
}

func (s *TrailingTypeSpecifierSeqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitTrailingTypeSpecifierSeq(s)
	}
}

func (s *TrailingTypeSpecifierSeqContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitTrailingTypeSpecifierSeq(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) TrailingTypeSpecifierSeq() (localctx ITrailingTypeSpecifierSeqContext) {
	localctx = NewTrailingTypeSpecifierSeqContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, CPP14ParserRULE_trailingTypeSpecifierSeq)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1078)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1077)
				p.TrailingTypeSpecifier()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(1080)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 110, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1083)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 111, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1082)
			p.AttributeSpecifierSeq()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleTypeLengthModifierContext is an interface to support dynamic dispatch.
type ISimpleTypeLengthModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Short() antlr.TerminalNode
	Long() antlr.TerminalNode

	// IsSimpleTypeLengthModifierContext differentiates from other interfaces.
	IsSimpleTypeLengthModifierContext()
}

type SimpleTypeLengthModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleTypeLengthModifierContext() *SimpleTypeLengthModifierContext {
	var p = new(SimpleTypeLengthModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_simpleTypeLengthModifier
	return p
}

func InitEmptySimpleTypeLengthModifierContext(p *SimpleTypeLengthModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_simpleTypeLengthModifier
}

func (*SimpleTypeLengthModifierContext) IsSimpleTypeLengthModifierContext() {}

func NewSimpleTypeLengthModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleTypeLengthModifierContext {
	var p = new(SimpleTypeLengthModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_simpleTypeLengthModifier

	return p
}

func (s *SimpleTypeLengthModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleTypeLengthModifierContext) Short() antlr.TerminalNode {
	return s.GetToken(CPP14ParserShort, 0)
}

func (s *SimpleTypeLengthModifierContext) Long() antlr.TerminalNode {
	return s.GetToken(CPP14ParserLong, 0)
}

func (s *SimpleTypeLengthModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleTypeLengthModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleTypeLengthModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterSimpleTypeLengthModifier(s)
	}
}

func (s *SimpleTypeLengthModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitSimpleTypeLengthModifier(s)
	}
}

func (s *SimpleTypeLengthModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitSimpleTypeLengthModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) SimpleTypeLengthModifier() (localctx ISimpleTypeLengthModifierContext) {
	localctx = NewSimpleTypeLengthModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, CPP14ParserRULE_simpleTypeLengthModifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1085)
		_la = p.GetTokenStream().LA(1)

		if !(_la == CPP14ParserLong || _la == CPP14ParserShort) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleTypeSignednessModifierContext is an interface to support dynamic dispatch.
type ISimpleTypeSignednessModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Unsigned() antlr.TerminalNode
	Signed() antlr.TerminalNode

	// IsSimpleTypeSignednessModifierContext differentiates from other interfaces.
	IsSimpleTypeSignednessModifierContext()
}

type SimpleTypeSignednessModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleTypeSignednessModifierContext() *SimpleTypeSignednessModifierContext {
	var p = new(SimpleTypeSignednessModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_simpleTypeSignednessModifier
	return p
}

func InitEmptySimpleTypeSignednessModifierContext(p *SimpleTypeSignednessModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_simpleTypeSignednessModifier
}

func (*SimpleTypeSignednessModifierContext) IsSimpleTypeSignednessModifierContext() {}

func NewSimpleTypeSignednessModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleTypeSignednessModifierContext {
	var p = new(SimpleTypeSignednessModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_simpleTypeSignednessModifier

	return p
}

func (s *SimpleTypeSignednessModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleTypeSignednessModifierContext) Unsigned() antlr.TerminalNode {
	return s.GetToken(CPP14ParserUnsigned, 0)
}

func (s *SimpleTypeSignednessModifierContext) Signed() antlr.TerminalNode {
	return s.GetToken(CPP14ParserSigned, 0)
}

func (s *SimpleTypeSignednessModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleTypeSignednessModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleTypeSignednessModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterSimpleTypeSignednessModifier(s)
	}
}

func (s *SimpleTypeSignednessModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitSimpleTypeSignednessModifier(s)
	}
}

func (s *SimpleTypeSignednessModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitSimpleTypeSignednessModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) SimpleTypeSignednessModifier() (localctx ISimpleTypeSignednessModifierContext) {
	localctx = NewSimpleTypeSignednessModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, CPP14ParserRULE_simpleTypeSignednessModifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1087)
		_la = p.GetTokenStream().LA(1)

		if !(_la == CPP14ParserSigned || _la == CPP14ParserUnsigned) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleTypeSpecifierContext is an interface to support dynamic dispatch.
type ISimpleTypeSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TheTypeName() ITheTypeNameContext
	NestedNameSpecifier() INestedNameSpecifierContext
	Template() antlr.TerminalNode
	SimpleTemplateId() ISimpleTemplateIdContext
	Char() antlr.TerminalNode
	Char16() antlr.TerminalNode
	Char32() antlr.TerminalNode
	Wchar() antlr.TerminalNode
	Bool() antlr.TerminalNode
	Short() antlr.TerminalNode
	Int() antlr.TerminalNode
	Long() antlr.TerminalNode
	Float() antlr.TerminalNode
	Signed() antlr.TerminalNode
	Unsigned() antlr.TerminalNode
	Double() antlr.TerminalNode
	Void() antlr.TerminalNode
	Auto() antlr.TerminalNode
	DecltypeSpecifier() IDecltypeSpecifierContext

	// IsSimpleTypeSpecifierContext differentiates from other interfaces.
	IsSimpleTypeSpecifierContext()
}

type SimpleTypeSpecifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleTypeSpecifierContext() *SimpleTypeSpecifierContext {
	var p = new(SimpleTypeSpecifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_simpleTypeSpecifier
	return p
}

func InitEmptySimpleTypeSpecifierContext(p *SimpleTypeSpecifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_simpleTypeSpecifier
}

func (*SimpleTypeSpecifierContext) IsSimpleTypeSpecifierContext() {}

func NewSimpleTypeSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleTypeSpecifierContext {
	var p = new(SimpleTypeSpecifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_simpleTypeSpecifier

	return p
}

func (s *SimpleTypeSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleTypeSpecifierContext) TheTypeName() ITheTypeNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITheTypeNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITheTypeNameContext)
}

func (s *SimpleTypeSpecifierContext) NestedNameSpecifier() INestedNameSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedNameSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedNameSpecifierContext)
}

func (s *SimpleTypeSpecifierContext) Template() antlr.TerminalNode {
	return s.GetToken(CPP14ParserTemplate, 0)
}

func (s *SimpleTypeSpecifierContext) SimpleTemplateId() ISimpleTemplateIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleTemplateIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleTemplateIdContext)
}

func (s *SimpleTypeSpecifierContext) Char() antlr.TerminalNode {
	return s.GetToken(CPP14ParserChar, 0)
}

func (s *SimpleTypeSpecifierContext) Char16() antlr.TerminalNode {
	return s.GetToken(CPP14ParserChar16, 0)
}

func (s *SimpleTypeSpecifierContext) Char32() antlr.TerminalNode {
	return s.GetToken(CPP14ParserChar32, 0)
}

func (s *SimpleTypeSpecifierContext) Wchar() antlr.TerminalNode {
	return s.GetToken(CPP14ParserWchar, 0)
}

func (s *SimpleTypeSpecifierContext) Bool() antlr.TerminalNode {
	return s.GetToken(CPP14ParserBool, 0)
}

func (s *SimpleTypeSpecifierContext) Short() antlr.TerminalNode {
	return s.GetToken(CPP14ParserShort, 0)
}

func (s *SimpleTypeSpecifierContext) Int() antlr.TerminalNode {
	return s.GetToken(CPP14ParserInt, 0)
}

func (s *SimpleTypeSpecifierContext) Long() antlr.TerminalNode {
	return s.GetToken(CPP14ParserLong, 0)
}

func (s *SimpleTypeSpecifierContext) Float() antlr.TerminalNode {
	return s.GetToken(CPP14ParserFloat, 0)
}

func (s *SimpleTypeSpecifierContext) Signed() antlr.TerminalNode {
	return s.GetToken(CPP14ParserSigned, 0)
}

func (s *SimpleTypeSpecifierContext) Unsigned() antlr.TerminalNode {
	return s.GetToken(CPP14ParserUnsigned, 0)
}

func (s *SimpleTypeSpecifierContext) Double() antlr.TerminalNode {
	return s.GetToken(CPP14ParserDouble, 0)
}

func (s *SimpleTypeSpecifierContext) Void() antlr.TerminalNode {
	return s.GetToken(CPP14ParserVoid, 0)
}

func (s *SimpleTypeSpecifierContext) Auto() antlr.TerminalNode {
	return s.GetToken(CPP14ParserAuto, 0)
}

func (s *SimpleTypeSpecifierContext) DecltypeSpecifier() IDecltypeSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecltypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecltypeSpecifierContext)
}

func (s *SimpleTypeSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleTypeSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleTypeSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterSimpleTypeSpecifier(s)
	}
}

func (s *SimpleTypeSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitSimpleTypeSpecifier(s)
	}
}

func (s *SimpleTypeSpecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitSimpleTypeSpecifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) SimpleTypeSpecifier() (localctx ISimpleTypeSpecifierContext) {
	localctx = NewSimpleTypeSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, CPP14ParserRULE_simpleTypeSpecifier)
	p.SetState(1113)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 113, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1090)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 112, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1089)
				p.nestedNameSpecifier(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1092)
			p.TheTypeName()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1093)
			p.nestedNameSpecifier(0)
		}
		{
			p.SetState(1094)
			p.Match(CPP14ParserTemplate)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1095)
			p.SimpleTemplateId()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1097)
			p.Match(CPP14ParserChar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1098)
			p.Match(CPP14ParserChar16)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1099)
			p.Match(CPP14ParserChar32)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1100)
			p.Match(CPP14ParserWchar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1101)
			p.Match(CPP14ParserBool)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1102)
			p.Match(CPP14ParserShort)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1103)
			p.Match(CPP14ParserInt)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1104)
			p.Match(CPP14ParserLong)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1105)
			p.Match(CPP14ParserFloat)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1106)
			p.Match(CPP14ParserSigned)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1107)
			p.Match(CPP14ParserUnsigned)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1108)
			p.Match(CPP14ParserFloat)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1109)
			p.Match(CPP14ParserDouble)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1110)
			p.Match(CPP14ParserVoid)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1111)
			p.Match(CPP14ParserAuto)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1112)
			p.DecltypeSpecifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITheTypeNameContext is an interface to support dynamic dispatch.
type ITheTypeNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ClassName() IClassNameContext
	EnumName() IEnumNameContext
	TypedefName() ITypedefNameContext
	SimpleTemplateId() ISimpleTemplateIdContext

	// IsTheTypeNameContext differentiates from other interfaces.
	IsTheTypeNameContext()
}

type TheTypeNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTheTypeNameContext() *TheTypeNameContext {
	var p = new(TheTypeNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_theTypeName
	return p
}

func InitEmptyTheTypeNameContext(p *TheTypeNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_theTypeName
}

func (*TheTypeNameContext) IsTheTypeNameContext() {}

func NewTheTypeNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TheTypeNameContext {
	var p = new(TheTypeNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_theTypeName

	return p
}

func (s *TheTypeNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TheTypeNameContext) ClassName() IClassNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassNameContext)
}

func (s *TheTypeNameContext) EnumName() IEnumNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumNameContext)
}

func (s *TheTypeNameContext) TypedefName() ITypedefNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypedefNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypedefNameContext)
}

func (s *TheTypeNameContext) SimpleTemplateId() ISimpleTemplateIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleTemplateIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleTemplateIdContext)
}

func (s *TheTypeNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TheTypeNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TheTypeNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterTheTypeName(s)
	}
}

func (s *TheTypeNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitTheTypeName(s)
	}
}

func (s *TheTypeNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitTheTypeName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) TheTypeName() (localctx ITheTypeNameContext) {
	localctx = NewTheTypeNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, CPP14ParserRULE_theTypeName)
	p.SetState(1119)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 114, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1115)
			p.ClassName()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1116)
			p.EnumName()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1117)
			p.TypedefName()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1118)
			p.SimpleTemplateId()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDecltypeSpecifierContext is an interface to support dynamic dispatch.
type IDecltypeSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Decltype() antlr.TerminalNode
	LeftParen() antlr.TerminalNode
	RightParen() antlr.TerminalNode
	Expression() IExpressionContext
	Auto() antlr.TerminalNode

	// IsDecltypeSpecifierContext differentiates from other interfaces.
	IsDecltypeSpecifierContext()
}

type DecltypeSpecifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecltypeSpecifierContext() *DecltypeSpecifierContext {
	var p = new(DecltypeSpecifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_decltypeSpecifier
	return p
}

func InitEmptyDecltypeSpecifierContext(p *DecltypeSpecifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_decltypeSpecifier
}

func (*DecltypeSpecifierContext) IsDecltypeSpecifierContext() {}

func NewDecltypeSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecltypeSpecifierContext {
	var p = new(DecltypeSpecifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_decltypeSpecifier

	return p
}

func (s *DecltypeSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *DecltypeSpecifierContext) Decltype() antlr.TerminalNode {
	return s.GetToken(CPP14ParserDecltype, 0)
}

func (s *DecltypeSpecifierContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CPP14ParserLeftParen, 0)
}

func (s *DecltypeSpecifierContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CPP14ParserRightParen, 0)
}

func (s *DecltypeSpecifierContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DecltypeSpecifierContext) Auto() antlr.TerminalNode {
	return s.GetToken(CPP14ParserAuto, 0)
}

func (s *DecltypeSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecltypeSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecltypeSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterDecltypeSpecifier(s)
	}
}

func (s *DecltypeSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitDecltypeSpecifier(s)
	}
}

func (s *DecltypeSpecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitDecltypeSpecifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) DecltypeSpecifier() (localctx IDecltypeSpecifierContext) {
	localctx = NewDecltypeSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, CPP14ParserRULE_decltypeSpecifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1121)
		p.Match(CPP14ParserDecltype)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1122)
		p.Match(CPP14ParserLeftParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1125)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 115, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1123)
			p.Expression()
		}

	case 2:
		{
			p.SetState(1124)
			p.Match(CPP14ParserAuto)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(1127)
		p.Match(CPP14ParserRightParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElaboratedTypeSpecifierContext is an interface to support dynamic dispatch.
type IElaboratedTypeSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ClassKey() IClassKeyContext
	Identifier() antlr.TerminalNode
	SimpleTemplateId() ISimpleTemplateIdContext
	NestedNameSpecifier() INestedNameSpecifierContext
	AttributeSpecifierSeq() IAttributeSpecifierSeqContext
	Template() antlr.TerminalNode
	Enum() antlr.TerminalNode

	// IsElaboratedTypeSpecifierContext differentiates from other interfaces.
	IsElaboratedTypeSpecifierContext()
}

type ElaboratedTypeSpecifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElaboratedTypeSpecifierContext() *ElaboratedTypeSpecifierContext {
	var p = new(ElaboratedTypeSpecifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_elaboratedTypeSpecifier
	return p
}

func InitEmptyElaboratedTypeSpecifierContext(p *ElaboratedTypeSpecifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_elaboratedTypeSpecifier
}

func (*ElaboratedTypeSpecifierContext) IsElaboratedTypeSpecifierContext() {}

func NewElaboratedTypeSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElaboratedTypeSpecifierContext {
	var p = new(ElaboratedTypeSpecifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_elaboratedTypeSpecifier

	return p
}

func (s *ElaboratedTypeSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ElaboratedTypeSpecifierContext) ClassKey() IClassKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassKeyContext)
}

func (s *ElaboratedTypeSpecifierContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CPP14ParserIdentifier, 0)
}

func (s *ElaboratedTypeSpecifierContext) SimpleTemplateId() ISimpleTemplateIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleTemplateIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleTemplateIdContext)
}

func (s *ElaboratedTypeSpecifierContext) NestedNameSpecifier() INestedNameSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedNameSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedNameSpecifierContext)
}

func (s *ElaboratedTypeSpecifierContext) AttributeSpecifierSeq() IAttributeSpecifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSpecifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSpecifierSeqContext)
}

func (s *ElaboratedTypeSpecifierContext) Template() antlr.TerminalNode {
	return s.GetToken(CPP14ParserTemplate, 0)
}

func (s *ElaboratedTypeSpecifierContext) Enum() antlr.TerminalNode {
	return s.GetToken(CPP14ParserEnum, 0)
}

func (s *ElaboratedTypeSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElaboratedTypeSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElaboratedTypeSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterElaboratedTypeSpecifier(s)
	}
}

func (s *ElaboratedTypeSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitElaboratedTypeSpecifier(s)
	}
}

func (s *ElaboratedTypeSpecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitElaboratedTypeSpecifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) ElaboratedTypeSpecifier() (localctx IElaboratedTypeSpecifierContext) {
	localctx = NewElaboratedTypeSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, CPP14ParserRULE_elaboratedTypeSpecifier)
	var _la int

	p.SetState(1151)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CPP14ParserClass, CPP14ParserStruct:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1129)
			p.ClassKey()
		}
		p.SetState(1144)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 119, p.GetParserRuleContext()) {
		case 1:
			p.SetState(1131)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == CPP14ParserAlignas || _la == CPP14ParserLeftBracket {
				{
					p.SetState(1130)
					p.AttributeSpecifierSeq()
				}

			}
			p.SetState(1134)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 117, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(1133)
					p.nestedNameSpecifier(0)
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(1136)
				p.Match(CPP14ParserIdentifier)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 2:
			{
				p.SetState(1137)
				p.SimpleTemplateId()
			}

		case 3:
			{
				p.SetState(1138)
				p.nestedNameSpecifier(0)
			}
			p.SetState(1140)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == CPP14ParserTemplate {
				{
					p.SetState(1139)
					p.Match(CPP14ParserTemplate)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(1142)
				p.SimpleTemplateId()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case CPP14ParserEnum:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1146)
			p.Match(CPP14ParserEnum)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1148)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 120, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1147)
				p.nestedNameSpecifier(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1150)
			p.Match(CPP14ParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumNameContext is an interface to support dynamic dispatch.
type IEnumNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode

	// IsEnumNameContext differentiates from other interfaces.
	IsEnumNameContext()
}

type EnumNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumNameContext() *EnumNameContext {
	var p = new(EnumNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_enumName
	return p
}

func InitEmptyEnumNameContext(p *EnumNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_enumName
}

func (*EnumNameContext) IsEnumNameContext() {}

func NewEnumNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumNameContext {
	var p = new(EnumNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_enumName

	return p
}

func (s *EnumNameContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumNameContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CPP14ParserIdentifier, 0)
}

func (s *EnumNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterEnumName(s)
	}
}

func (s *EnumNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitEnumName(s)
	}
}

func (s *EnumNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitEnumName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) EnumName() (localctx IEnumNameContext) {
	localctx = NewEnumNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, CPP14ParserRULE_enumName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1153)
		p.Match(CPP14ParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumSpecifierContext is an interface to support dynamic dispatch.
type IEnumSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EnumHead() IEnumHeadContext
	LeftBrace() antlr.TerminalNode
	RightBrace() antlr.TerminalNode
	EnumeratorList() IEnumeratorListContext
	Comma() antlr.TerminalNode

	// IsEnumSpecifierContext differentiates from other interfaces.
	IsEnumSpecifierContext()
}

type EnumSpecifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumSpecifierContext() *EnumSpecifierContext {
	var p = new(EnumSpecifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_enumSpecifier
	return p
}

func InitEmptyEnumSpecifierContext(p *EnumSpecifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_enumSpecifier
}

func (*EnumSpecifierContext) IsEnumSpecifierContext() {}

func NewEnumSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumSpecifierContext {
	var p = new(EnumSpecifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_enumSpecifier

	return p
}

func (s *EnumSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumSpecifierContext) EnumHead() IEnumHeadContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumHeadContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumHeadContext)
}

func (s *EnumSpecifierContext) LeftBrace() antlr.TerminalNode {
	return s.GetToken(CPP14ParserLeftBrace, 0)
}

func (s *EnumSpecifierContext) RightBrace() antlr.TerminalNode {
	return s.GetToken(CPP14ParserRightBrace, 0)
}

func (s *EnumSpecifierContext) EnumeratorList() IEnumeratorListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumeratorListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumeratorListContext)
}

func (s *EnumSpecifierContext) Comma() antlr.TerminalNode {
	return s.GetToken(CPP14ParserComma, 0)
}

func (s *EnumSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterEnumSpecifier(s)
	}
}

func (s *EnumSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitEnumSpecifier(s)
	}
}

func (s *EnumSpecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitEnumSpecifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) EnumSpecifier() (localctx IEnumSpecifierContext) {
	localctx = NewEnumSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, CPP14ParserRULE_enumSpecifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1155)
		p.EnumHead()
	}
	{
		p.SetState(1156)
		p.Match(CPP14ParserLeftBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1161)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CPP14ParserIdentifier {
		{
			p.SetState(1157)
			p.EnumeratorList()
		}
		p.SetState(1159)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CPP14ParserComma {
			{
				p.SetState(1158)
				p.Match(CPP14ParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}
	{
		p.SetState(1163)
		p.Match(CPP14ParserRightBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumHeadContext is an interface to support dynamic dispatch.
type IEnumHeadContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Enumkey() IEnumkeyContext
	AttributeSpecifierSeq() IAttributeSpecifierSeqContext
	Identifier() antlr.TerminalNode
	Enumbase() IEnumbaseContext
	NestedNameSpecifier() INestedNameSpecifierContext

	// IsEnumHeadContext differentiates from other interfaces.
	IsEnumHeadContext()
}

type EnumHeadContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumHeadContext() *EnumHeadContext {
	var p = new(EnumHeadContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_enumHead
	return p
}

func InitEmptyEnumHeadContext(p *EnumHeadContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_enumHead
}

func (*EnumHeadContext) IsEnumHeadContext() {}

func NewEnumHeadContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumHeadContext {
	var p = new(EnumHeadContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_enumHead

	return p
}

func (s *EnumHeadContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumHeadContext) Enumkey() IEnumkeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumkeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumkeyContext)
}

func (s *EnumHeadContext) AttributeSpecifierSeq() IAttributeSpecifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSpecifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSpecifierSeqContext)
}

func (s *EnumHeadContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CPP14ParserIdentifier, 0)
}

func (s *EnumHeadContext) Enumbase() IEnumbaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumbaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumbaseContext)
}

func (s *EnumHeadContext) NestedNameSpecifier() INestedNameSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedNameSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedNameSpecifierContext)
}

func (s *EnumHeadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumHeadContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumHeadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterEnumHead(s)
	}
}

func (s *EnumHeadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitEnumHead(s)
	}
}

func (s *EnumHeadContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitEnumHead(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) EnumHead() (localctx IEnumHeadContext) {
	localctx = NewEnumHeadContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, CPP14ParserRULE_enumHead)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1165)
		p.Enumkey()
	}
	p.SetState(1167)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CPP14ParserAlignas || _la == CPP14ParserLeftBracket {
		{
			p.SetState(1166)
			p.AttributeSpecifierSeq()
		}

	}
	p.SetState(1173)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CPP14ParserDecltype || _la == CPP14ParserDoublecolon || _la == CPP14ParserIdentifier {
		p.SetState(1170)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 125, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1169)
				p.nestedNameSpecifier(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1172)
			p.Match(CPP14ParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1176)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CPP14ParserColon {
		{
			p.SetState(1175)
			p.Enumbase()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOpaqueEnumDeclarationContext is an interface to support dynamic dispatch.
type IOpaqueEnumDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Enumkey() IEnumkeyContext
	Identifier() antlr.TerminalNode
	Semi() antlr.TerminalNode
	AttributeSpecifierSeq() IAttributeSpecifierSeqContext
	Enumbase() IEnumbaseContext

	// IsOpaqueEnumDeclarationContext differentiates from other interfaces.
	IsOpaqueEnumDeclarationContext()
}

type OpaqueEnumDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpaqueEnumDeclarationContext() *OpaqueEnumDeclarationContext {
	var p = new(OpaqueEnumDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_opaqueEnumDeclaration
	return p
}

func InitEmptyOpaqueEnumDeclarationContext(p *OpaqueEnumDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_opaqueEnumDeclaration
}

func (*OpaqueEnumDeclarationContext) IsOpaqueEnumDeclarationContext() {}

func NewOpaqueEnumDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OpaqueEnumDeclarationContext {
	var p = new(OpaqueEnumDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_opaqueEnumDeclaration

	return p
}

func (s *OpaqueEnumDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *OpaqueEnumDeclarationContext) Enumkey() IEnumkeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumkeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumkeyContext)
}

func (s *OpaqueEnumDeclarationContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CPP14ParserIdentifier, 0)
}

func (s *OpaqueEnumDeclarationContext) Semi() antlr.TerminalNode {
	return s.GetToken(CPP14ParserSemi, 0)
}

func (s *OpaqueEnumDeclarationContext) AttributeSpecifierSeq() IAttributeSpecifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSpecifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSpecifierSeqContext)
}

func (s *OpaqueEnumDeclarationContext) Enumbase() IEnumbaseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumbaseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumbaseContext)
}

func (s *OpaqueEnumDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OpaqueEnumDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OpaqueEnumDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterOpaqueEnumDeclaration(s)
	}
}

func (s *OpaqueEnumDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitOpaqueEnumDeclaration(s)
	}
}

func (s *OpaqueEnumDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitOpaqueEnumDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) OpaqueEnumDeclaration() (localctx IOpaqueEnumDeclarationContext) {
	localctx = NewOpaqueEnumDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, CPP14ParserRULE_opaqueEnumDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1178)
		p.Enumkey()
	}
	p.SetState(1180)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CPP14ParserAlignas || _la == CPP14ParserLeftBracket {
		{
			p.SetState(1179)
			p.AttributeSpecifierSeq()
		}

	}
	{
		p.SetState(1182)
		p.Match(CPP14ParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1184)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CPP14ParserColon {
		{
			p.SetState(1183)
			p.Enumbase()
		}

	}
	{
		p.SetState(1186)
		p.Match(CPP14ParserSemi)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumkeyContext is an interface to support dynamic dispatch.
type IEnumkeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Enum() antlr.TerminalNode
	Class() antlr.TerminalNode
	Struct() antlr.TerminalNode

	// IsEnumkeyContext differentiates from other interfaces.
	IsEnumkeyContext()
}

type EnumkeyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumkeyContext() *EnumkeyContext {
	var p = new(EnumkeyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_enumkey
	return p
}

func InitEmptyEnumkeyContext(p *EnumkeyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_enumkey
}

func (*EnumkeyContext) IsEnumkeyContext() {}

func NewEnumkeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumkeyContext {
	var p = new(EnumkeyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_enumkey

	return p
}

func (s *EnumkeyContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumkeyContext) Enum() antlr.TerminalNode {
	return s.GetToken(CPP14ParserEnum, 0)
}

func (s *EnumkeyContext) Class() antlr.TerminalNode {
	return s.GetToken(CPP14ParserClass, 0)
}

func (s *EnumkeyContext) Struct() antlr.TerminalNode {
	return s.GetToken(CPP14ParserStruct, 0)
}

func (s *EnumkeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumkeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumkeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterEnumkey(s)
	}
}

func (s *EnumkeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitEnumkey(s)
	}
}

func (s *EnumkeyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitEnumkey(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) Enumkey() (localctx IEnumkeyContext) {
	localctx = NewEnumkeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, CPP14ParserRULE_enumkey)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1188)
		p.Match(CPP14ParserEnum)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1190)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CPP14ParserClass || _la == CPP14ParserStruct {
		{
			p.SetState(1189)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CPP14ParserClass || _la == CPP14ParserStruct) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumbaseContext is an interface to support dynamic dispatch.
type IEnumbaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Colon() antlr.TerminalNode
	TypeSpecifierSeq() ITypeSpecifierSeqContext

	// IsEnumbaseContext differentiates from other interfaces.
	IsEnumbaseContext()
}

type EnumbaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumbaseContext() *EnumbaseContext {
	var p = new(EnumbaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_enumbase
	return p
}

func InitEmptyEnumbaseContext(p *EnumbaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_enumbase
}

func (*EnumbaseContext) IsEnumbaseContext() {}

func NewEnumbaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumbaseContext {
	var p = new(EnumbaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_enumbase

	return p
}

func (s *EnumbaseContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumbaseContext) Colon() antlr.TerminalNode {
	return s.GetToken(CPP14ParserColon, 0)
}

func (s *EnumbaseContext) TypeSpecifierSeq() ITypeSpecifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSpecifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSpecifierSeqContext)
}

func (s *EnumbaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumbaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumbaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterEnumbase(s)
	}
}

func (s *EnumbaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitEnumbase(s)
	}
}

func (s *EnumbaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitEnumbase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) Enumbase() (localctx IEnumbaseContext) {
	localctx = NewEnumbaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, CPP14ParserRULE_enumbase)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1192)
		p.Match(CPP14ParserColon)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1193)
		p.TypeSpecifierSeq()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumeratorListContext is an interface to support dynamic dispatch.
type IEnumeratorListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllEnumeratorDefinition() []IEnumeratorDefinitionContext
	EnumeratorDefinition(i int) IEnumeratorDefinitionContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsEnumeratorListContext differentiates from other interfaces.
	IsEnumeratorListContext()
}

type EnumeratorListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumeratorListContext() *EnumeratorListContext {
	var p = new(EnumeratorListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_enumeratorList
	return p
}

func InitEmptyEnumeratorListContext(p *EnumeratorListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_enumeratorList
}

func (*EnumeratorListContext) IsEnumeratorListContext() {}

func NewEnumeratorListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumeratorListContext {
	var p = new(EnumeratorListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_enumeratorList

	return p
}

func (s *EnumeratorListContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumeratorListContext) AllEnumeratorDefinition() []IEnumeratorDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEnumeratorDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IEnumeratorDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEnumeratorDefinitionContext); ok {
			tst[i] = t.(IEnumeratorDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *EnumeratorListContext) EnumeratorDefinition(i int) IEnumeratorDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumeratorDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumeratorDefinitionContext)
}

func (s *EnumeratorListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(CPP14ParserComma)
}

func (s *EnumeratorListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(CPP14ParserComma, i)
}

func (s *EnumeratorListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumeratorListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumeratorListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterEnumeratorList(s)
	}
}

func (s *EnumeratorListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitEnumeratorList(s)
	}
}

func (s *EnumeratorListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitEnumeratorList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) EnumeratorList() (localctx IEnumeratorListContext) {
	localctx = NewEnumeratorListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, CPP14ParserRULE_enumeratorList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1195)
		p.EnumeratorDefinition()
	}
	p.SetState(1200)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 131, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1196)
				p.Match(CPP14ParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1197)
				p.EnumeratorDefinition()
			}

		}
		p.SetState(1202)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 131, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumeratorDefinitionContext is an interface to support dynamic dispatch.
type IEnumeratorDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Enumerator() IEnumeratorContext
	Assign() antlr.TerminalNode
	ConstantExpression() IConstantExpressionContext

	// IsEnumeratorDefinitionContext differentiates from other interfaces.
	IsEnumeratorDefinitionContext()
}

type EnumeratorDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumeratorDefinitionContext() *EnumeratorDefinitionContext {
	var p = new(EnumeratorDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_enumeratorDefinition
	return p
}

func InitEmptyEnumeratorDefinitionContext(p *EnumeratorDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_enumeratorDefinition
}

func (*EnumeratorDefinitionContext) IsEnumeratorDefinitionContext() {}

func NewEnumeratorDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumeratorDefinitionContext {
	var p = new(EnumeratorDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_enumeratorDefinition

	return p
}

func (s *EnumeratorDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumeratorDefinitionContext) Enumerator() IEnumeratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumeratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumeratorContext)
}

func (s *EnumeratorDefinitionContext) Assign() antlr.TerminalNode {
	return s.GetToken(CPP14ParserAssign, 0)
}

func (s *EnumeratorDefinitionContext) ConstantExpression() IConstantExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantExpressionContext)
}

func (s *EnumeratorDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumeratorDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumeratorDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterEnumeratorDefinition(s)
	}
}

func (s *EnumeratorDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitEnumeratorDefinition(s)
	}
}

func (s *EnumeratorDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitEnumeratorDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) EnumeratorDefinition() (localctx IEnumeratorDefinitionContext) {
	localctx = NewEnumeratorDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, CPP14ParserRULE_enumeratorDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1203)
		p.Enumerator()
	}
	p.SetState(1206)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CPP14ParserAssign {
		{
			p.SetState(1204)
			p.Match(CPP14ParserAssign)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1205)
			p.ConstantExpression()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumeratorContext is an interface to support dynamic dispatch.
type IEnumeratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode

	// IsEnumeratorContext differentiates from other interfaces.
	IsEnumeratorContext()
}

type EnumeratorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumeratorContext() *EnumeratorContext {
	var p = new(EnumeratorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_enumerator
	return p
}

func InitEmptyEnumeratorContext(p *EnumeratorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_enumerator
}

func (*EnumeratorContext) IsEnumeratorContext() {}

func NewEnumeratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumeratorContext {
	var p = new(EnumeratorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_enumerator

	return p
}

func (s *EnumeratorContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumeratorContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CPP14ParserIdentifier, 0)
}

func (s *EnumeratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumeratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumeratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterEnumerator(s)
	}
}

func (s *EnumeratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitEnumerator(s)
	}
}

func (s *EnumeratorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitEnumerator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) Enumerator() (localctx IEnumeratorContext) {
	localctx = NewEnumeratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, CPP14ParserRULE_enumerator)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1208)
		p.Match(CPP14ParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamespaceNameContext is an interface to support dynamic dispatch.
type INamespaceNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OriginalNamespaceName() IOriginalNamespaceNameContext
	NamespaceAlias() INamespaceAliasContext

	// IsNamespaceNameContext differentiates from other interfaces.
	IsNamespaceNameContext()
}

type NamespaceNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamespaceNameContext() *NamespaceNameContext {
	var p = new(NamespaceNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_namespaceName
	return p
}

func InitEmptyNamespaceNameContext(p *NamespaceNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_namespaceName
}

func (*NamespaceNameContext) IsNamespaceNameContext() {}

func NewNamespaceNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamespaceNameContext {
	var p = new(NamespaceNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_namespaceName

	return p
}

func (s *NamespaceNameContext) GetParser() antlr.Parser { return s.parser }

func (s *NamespaceNameContext) OriginalNamespaceName() IOriginalNamespaceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOriginalNamespaceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOriginalNamespaceNameContext)
}

func (s *NamespaceNameContext) NamespaceAlias() INamespaceAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceAliasContext)
}

func (s *NamespaceNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamespaceNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamespaceNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterNamespaceName(s)
	}
}

func (s *NamespaceNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitNamespaceName(s)
	}
}

func (s *NamespaceNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitNamespaceName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) NamespaceName() (localctx INamespaceNameContext) {
	localctx = NewNamespaceNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, CPP14ParserRULE_namespaceName)
	p.SetState(1212)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 133, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1210)
			p.OriginalNamespaceName()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1211)
			p.NamespaceAlias()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOriginalNamespaceNameContext is an interface to support dynamic dispatch.
type IOriginalNamespaceNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode

	// IsOriginalNamespaceNameContext differentiates from other interfaces.
	IsOriginalNamespaceNameContext()
}

type OriginalNamespaceNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOriginalNamespaceNameContext() *OriginalNamespaceNameContext {
	var p = new(OriginalNamespaceNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_originalNamespaceName
	return p
}

func InitEmptyOriginalNamespaceNameContext(p *OriginalNamespaceNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_originalNamespaceName
}

func (*OriginalNamespaceNameContext) IsOriginalNamespaceNameContext() {}

func NewOriginalNamespaceNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OriginalNamespaceNameContext {
	var p = new(OriginalNamespaceNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_originalNamespaceName

	return p
}

func (s *OriginalNamespaceNameContext) GetParser() antlr.Parser { return s.parser }

func (s *OriginalNamespaceNameContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CPP14ParserIdentifier, 0)
}

func (s *OriginalNamespaceNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OriginalNamespaceNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OriginalNamespaceNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterOriginalNamespaceName(s)
	}
}

func (s *OriginalNamespaceNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitOriginalNamespaceName(s)
	}
}

func (s *OriginalNamespaceNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitOriginalNamespaceName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) OriginalNamespaceName() (localctx IOriginalNamespaceNameContext) {
	localctx = NewOriginalNamespaceNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, CPP14ParserRULE_originalNamespaceName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1214)
		p.Match(CPP14ParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamespaceDefinitionContext is an interface to support dynamic dispatch.
type INamespaceDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetNamespaceBody returns the namespaceBody rule contexts.
	GetNamespaceBody() IDeclarationseqContext

	// SetNamespaceBody sets the namespaceBody rule contexts.
	SetNamespaceBody(IDeclarationseqContext)

	// Getter signatures
	Namespace() antlr.TerminalNode
	LeftBrace() antlr.TerminalNode
	RightBrace() antlr.TerminalNode
	Inline() antlr.TerminalNode
	Identifier() antlr.TerminalNode
	OriginalNamespaceName() IOriginalNamespaceNameContext
	Declarationseq() IDeclarationseqContext

	// IsNamespaceDefinitionContext differentiates from other interfaces.
	IsNamespaceDefinitionContext()
}

type NamespaceDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	namespaceBody IDeclarationseqContext
}

func NewEmptyNamespaceDefinitionContext() *NamespaceDefinitionContext {
	var p = new(NamespaceDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_namespaceDefinition
	return p
}

func InitEmptyNamespaceDefinitionContext(p *NamespaceDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_namespaceDefinition
}

func (*NamespaceDefinitionContext) IsNamespaceDefinitionContext() {}

func NewNamespaceDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamespaceDefinitionContext {
	var p = new(NamespaceDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_namespaceDefinition

	return p
}

func (s *NamespaceDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *NamespaceDefinitionContext) GetNamespaceBody() IDeclarationseqContext {
	return s.namespaceBody
}

func (s *NamespaceDefinitionContext) SetNamespaceBody(v IDeclarationseqContext) { s.namespaceBody = v }

func (s *NamespaceDefinitionContext) Namespace() antlr.TerminalNode {
	return s.GetToken(CPP14ParserNamespace, 0)
}

func (s *NamespaceDefinitionContext) LeftBrace() antlr.TerminalNode {
	return s.GetToken(CPP14ParserLeftBrace, 0)
}

func (s *NamespaceDefinitionContext) RightBrace() antlr.TerminalNode {
	return s.GetToken(CPP14ParserRightBrace, 0)
}

func (s *NamespaceDefinitionContext) Inline() antlr.TerminalNode {
	return s.GetToken(CPP14ParserInline, 0)
}

func (s *NamespaceDefinitionContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CPP14ParserIdentifier, 0)
}

func (s *NamespaceDefinitionContext) OriginalNamespaceName() IOriginalNamespaceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOriginalNamespaceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOriginalNamespaceNameContext)
}

func (s *NamespaceDefinitionContext) Declarationseq() IDeclarationseqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationseqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationseqContext)
}

func (s *NamespaceDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamespaceDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamespaceDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterNamespaceDefinition(s)
	}
}

func (s *NamespaceDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitNamespaceDefinition(s)
	}
}

func (s *NamespaceDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitNamespaceDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) NamespaceDefinition() (localctx INamespaceDefinitionContext) {
	localctx = NewNamespaceDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, CPP14ParserRULE_namespaceDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1217)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CPP14ParserInline {
		{
			p.SetState(1216)
			p.Match(CPP14ParserInline)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1219)
		p.Match(CPP14ParserNamespace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1222)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 135, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1220)
			p.Match(CPP14ParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 135, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(1221)
			p.OriginalNamespaceName()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1224)
		p.Match(CPP14ParserLeftBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1226)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64((_la-10)) & ^0x3f) == 0 && ((int64(1)<<(_la-10))&1543754443169808157) != 0) || ((int64((_la-74)) & ^0x3f) == 0 && ((int64(1)<<(_la-74))&459384754220313597) != 0) {
		{
			p.SetState(1225)

			var _x = p.Declarationseq()

			localctx.(*NamespaceDefinitionContext).namespaceBody = _x
		}

	}
	{
		p.SetState(1228)
		p.Match(CPP14ParserRightBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamespaceAliasContext is an interface to support dynamic dispatch.
type INamespaceAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode

	// IsNamespaceAliasContext differentiates from other interfaces.
	IsNamespaceAliasContext()
}

type NamespaceAliasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamespaceAliasContext() *NamespaceAliasContext {
	var p = new(NamespaceAliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_namespaceAlias
	return p
}

func InitEmptyNamespaceAliasContext(p *NamespaceAliasContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_namespaceAlias
}

func (*NamespaceAliasContext) IsNamespaceAliasContext() {}

func NewNamespaceAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamespaceAliasContext {
	var p = new(NamespaceAliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_namespaceAlias

	return p
}

func (s *NamespaceAliasContext) GetParser() antlr.Parser { return s.parser }

func (s *NamespaceAliasContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CPP14ParserIdentifier, 0)
}

func (s *NamespaceAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamespaceAliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamespaceAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterNamespaceAlias(s)
	}
}

func (s *NamespaceAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitNamespaceAlias(s)
	}
}

func (s *NamespaceAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitNamespaceAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) NamespaceAlias() (localctx INamespaceAliasContext) {
	localctx = NewNamespaceAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, CPP14ParserRULE_namespaceAlias)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1230)
		p.Match(CPP14ParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamespaceAliasDefinitionContext is an interface to support dynamic dispatch.
type INamespaceAliasDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Namespace() antlr.TerminalNode
	Identifier() antlr.TerminalNode
	Assign() antlr.TerminalNode
	Qualifiednamespacespecifier() IQualifiednamespacespecifierContext
	Semi() antlr.TerminalNode

	// IsNamespaceAliasDefinitionContext differentiates from other interfaces.
	IsNamespaceAliasDefinitionContext()
}

type NamespaceAliasDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamespaceAliasDefinitionContext() *NamespaceAliasDefinitionContext {
	var p = new(NamespaceAliasDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_namespaceAliasDefinition
	return p
}

func InitEmptyNamespaceAliasDefinitionContext(p *NamespaceAliasDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_namespaceAliasDefinition
}

func (*NamespaceAliasDefinitionContext) IsNamespaceAliasDefinitionContext() {}

func NewNamespaceAliasDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamespaceAliasDefinitionContext {
	var p = new(NamespaceAliasDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_namespaceAliasDefinition

	return p
}

func (s *NamespaceAliasDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *NamespaceAliasDefinitionContext) Namespace() antlr.TerminalNode {
	return s.GetToken(CPP14ParserNamespace, 0)
}

func (s *NamespaceAliasDefinitionContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CPP14ParserIdentifier, 0)
}

func (s *NamespaceAliasDefinitionContext) Assign() antlr.TerminalNode {
	return s.GetToken(CPP14ParserAssign, 0)
}

func (s *NamespaceAliasDefinitionContext) Qualifiednamespacespecifier() IQualifiednamespacespecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiednamespacespecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiednamespacespecifierContext)
}

func (s *NamespaceAliasDefinitionContext) Semi() antlr.TerminalNode {
	return s.GetToken(CPP14ParserSemi, 0)
}

func (s *NamespaceAliasDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamespaceAliasDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamespaceAliasDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterNamespaceAliasDefinition(s)
	}
}

func (s *NamespaceAliasDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitNamespaceAliasDefinition(s)
	}
}

func (s *NamespaceAliasDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitNamespaceAliasDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) NamespaceAliasDefinition() (localctx INamespaceAliasDefinitionContext) {
	localctx = NewNamespaceAliasDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, CPP14ParserRULE_namespaceAliasDefinition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1232)
		p.Match(CPP14ParserNamespace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1233)
		p.Match(CPP14ParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1234)
		p.Match(CPP14ParserAssign)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1235)
		p.Qualifiednamespacespecifier()
	}
	{
		p.SetState(1236)
		p.Match(CPP14ParserSemi)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQualifiednamespacespecifierContext is an interface to support dynamic dispatch.
type IQualifiednamespacespecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NamespaceName() INamespaceNameContext
	NestedNameSpecifier() INestedNameSpecifierContext

	// IsQualifiednamespacespecifierContext differentiates from other interfaces.
	IsQualifiednamespacespecifierContext()
}

type QualifiednamespacespecifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiednamespacespecifierContext() *QualifiednamespacespecifierContext {
	var p = new(QualifiednamespacespecifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_qualifiednamespacespecifier
	return p
}

func InitEmptyQualifiednamespacespecifierContext(p *QualifiednamespacespecifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_qualifiednamespacespecifier
}

func (*QualifiednamespacespecifierContext) IsQualifiednamespacespecifierContext() {}

func NewQualifiednamespacespecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiednamespacespecifierContext {
	var p = new(QualifiednamespacespecifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_qualifiednamespacespecifier

	return p
}

func (s *QualifiednamespacespecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiednamespacespecifierContext) NamespaceName() INamespaceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceNameContext)
}

func (s *QualifiednamespacespecifierContext) NestedNameSpecifier() INestedNameSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedNameSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedNameSpecifierContext)
}

func (s *QualifiednamespacespecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiednamespacespecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiednamespacespecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterQualifiednamespacespecifier(s)
	}
}

func (s *QualifiednamespacespecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitQualifiednamespacespecifier(s)
	}
}

func (s *QualifiednamespacespecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitQualifiednamespacespecifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) Qualifiednamespacespecifier() (localctx IQualifiednamespacespecifierContext) {
	localctx = NewQualifiednamespacespecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, CPP14ParserRULE_qualifiednamespacespecifier)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(1239)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 137, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1238)
			p.nestedNameSpecifier(0)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1241)
		p.NamespaceName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUsingDeclarationContext is an interface to support dynamic dispatch.
type IUsingDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Using() antlr.TerminalNode
	UnqualifiedId() IUnqualifiedIdContext
	Semi() antlr.TerminalNode
	NestedNameSpecifier() INestedNameSpecifierContext
	Doublecolon() antlr.TerminalNode
	Typename_() antlr.TerminalNode

	// IsUsingDeclarationContext differentiates from other interfaces.
	IsUsingDeclarationContext()
}

type UsingDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUsingDeclarationContext() *UsingDeclarationContext {
	var p = new(UsingDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_usingDeclaration
	return p
}

func InitEmptyUsingDeclarationContext(p *UsingDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_usingDeclaration
}

func (*UsingDeclarationContext) IsUsingDeclarationContext() {}

func NewUsingDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UsingDeclarationContext {
	var p = new(UsingDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_usingDeclaration

	return p
}

func (s *UsingDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *UsingDeclarationContext) Using() antlr.TerminalNode {
	return s.GetToken(CPP14ParserUsing, 0)
}

func (s *UsingDeclarationContext) UnqualifiedId() IUnqualifiedIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnqualifiedIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnqualifiedIdContext)
}

func (s *UsingDeclarationContext) Semi() antlr.TerminalNode {
	return s.GetToken(CPP14ParserSemi, 0)
}

func (s *UsingDeclarationContext) NestedNameSpecifier() INestedNameSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedNameSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedNameSpecifierContext)
}

func (s *UsingDeclarationContext) Doublecolon() antlr.TerminalNode {
	return s.GetToken(CPP14ParserDoublecolon, 0)
}

func (s *UsingDeclarationContext) Typename_() antlr.TerminalNode {
	return s.GetToken(CPP14ParserTypename_, 0)
}

func (s *UsingDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UsingDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UsingDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterUsingDeclaration(s)
	}
}

func (s *UsingDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitUsingDeclaration(s)
	}
}

func (s *UsingDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitUsingDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) UsingDeclaration() (localctx IUsingDeclarationContext) {
	localctx = NewUsingDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, CPP14ParserRULE_usingDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1243)
		p.Match(CPP14ParserUsing)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1249)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 139, p.GetParserRuleContext()) {
	case 1:
		p.SetState(1245)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CPP14ParserTypename_ {
			{
				p.SetState(1244)
				p.Match(CPP14ParserTypename_)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1247)
			p.nestedNameSpecifier(0)
		}

	case 2:
		{
			p.SetState(1248)
			p.Match(CPP14ParserDoublecolon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(1251)
		p.UnqualifiedId()
	}
	{
		p.SetState(1252)
		p.Match(CPP14ParserSemi)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUsingDirectiveContext is an interface to support dynamic dispatch.
type IUsingDirectiveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Using() antlr.TerminalNode
	Namespace() antlr.TerminalNode
	NamespaceName() INamespaceNameContext
	Semi() antlr.TerminalNode
	AttributeSpecifierSeq() IAttributeSpecifierSeqContext
	NestedNameSpecifier() INestedNameSpecifierContext

	// IsUsingDirectiveContext differentiates from other interfaces.
	IsUsingDirectiveContext()
}

type UsingDirectiveContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUsingDirectiveContext() *UsingDirectiveContext {
	var p = new(UsingDirectiveContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_usingDirective
	return p
}

func InitEmptyUsingDirectiveContext(p *UsingDirectiveContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_usingDirective
}

func (*UsingDirectiveContext) IsUsingDirectiveContext() {}

func NewUsingDirectiveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UsingDirectiveContext {
	var p = new(UsingDirectiveContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_usingDirective

	return p
}

func (s *UsingDirectiveContext) GetParser() antlr.Parser { return s.parser }

func (s *UsingDirectiveContext) Using() antlr.TerminalNode {
	return s.GetToken(CPP14ParserUsing, 0)
}

func (s *UsingDirectiveContext) Namespace() antlr.TerminalNode {
	return s.GetToken(CPP14ParserNamespace, 0)
}

func (s *UsingDirectiveContext) NamespaceName() INamespaceNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamespaceNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamespaceNameContext)
}

func (s *UsingDirectiveContext) Semi() antlr.TerminalNode {
	return s.GetToken(CPP14ParserSemi, 0)
}

func (s *UsingDirectiveContext) AttributeSpecifierSeq() IAttributeSpecifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSpecifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSpecifierSeqContext)
}

func (s *UsingDirectiveContext) NestedNameSpecifier() INestedNameSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedNameSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedNameSpecifierContext)
}

func (s *UsingDirectiveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UsingDirectiveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UsingDirectiveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterUsingDirective(s)
	}
}

func (s *UsingDirectiveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitUsingDirective(s)
	}
}

func (s *UsingDirectiveContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitUsingDirective(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) UsingDirective() (localctx IUsingDirectiveContext) {
	localctx = NewUsingDirectiveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, CPP14ParserRULE_usingDirective)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1255)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CPP14ParserAlignas || _la == CPP14ParserLeftBracket {
		{
			p.SetState(1254)
			p.AttributeSpecifierSeq()
		}

	}
	{
		p.SetState(1257)
		p.Match(CPP14ParserUsing)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1258)
		p.Match(CPP14ParserNamespace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1260)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 141, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1259)
			p.nestedNameSpecifier(0)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1262)
		p.NamespaceName()
	}
	{
		p.SetState(1263)
		p.Match(CPP14ParserSemi)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAsmDefinitionContext is an interface to support dynamic dispatch.
type IAsmDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Asm() antlr.TerminalNode
	LeftParen() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode
	RightParen() antlr.TerminalNode
	Semi() antlr.TerminalNode

	// IsAsmDefinitionContext differentiates from other interfaces.
	IsAsmDefinitionContext()
}

type AsmDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAsmDefinitionContext() *AsmDefinitionContext {
	var p = new(AsmDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_asmDefinition
	return p
}

func InitEmptyAsmDefinitionContext(p *AsmDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_asmDefinition
}

func (*AsmDefinitionContext) IsAsmDefinitionContext() {}

func NewAsmDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AsmDefinitionContext {
	var p = new(AsmDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_asmDefinition

	return p
}

func (s *AsmDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *AsmDefinitionContext) Asm() antlr.TerminalNode {
	return s.GetToken(CPP14ParserAsm, 0)
}

func (s *AsmDefinitionContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CPP14ParserLeftParen, 0)
}

func (s *AsmDefinitionContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(CPP14ParserStringLiteral, 0)
}

func (s *AsmDefinitionContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CPP14ParserRightParen, 0)
}

func (s *AsmDefinitionContext) Semi() antlr.TerminalNode {
	return s.GetToken(CPP14ParserSemi, 0)
}

func (s *AsmDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AsmDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AsmDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterAsmDefinition(s)
	}
}

func (s *AsmDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitAsmDefinition(s)
	}
}

func (s *AsmDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitAsmDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) AsmDefinition() (localctx IAsmDefinitionContext) {
	localctx = NewAsmDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, CPP14ParserRULE_asmDefinition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1265)
		p.Match(CPP14ParserAsm)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1266)
		p.Match(CPP14ParserLeftParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1267)
		p.Match(CPP14ParserStringLiteral)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1268)
		p.Match(CPP14ParserRightParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1269)
		p.Match(CPP14ParserSemi)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILinkageSpecificationContext is an interface to support dynamic dispatch.
type ILinkageSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Extern() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode
	LeftBrace() antlr.TerminalNode
	RightBrace() antlr.TerminalNode
	Declaration() IDeclarationContext
	Declarationseq() IDeclarationseqContext

	// IsLinkageSpecificationContext differentiates from other interfaces.
	IsLinkageSpecificationContext()
}

type LinkageSpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLinkageSpecificationContext() *LinkageSpecificationContext {
	var p = new(LinkageSpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_linkageSpecification
	return p
}

func InitEmptyLinkageSpecificationContext(p *LinkageSpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_linkageSpecification
}

func (*LinkageSpecificationContext) IsLinkageSpecificationContext() {}

func NewLinkageSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LinkageSpecificationContext {
	var p = new(LinkageSpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_linkageSpecification

	return p
}

func (s *LinkageSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *LinkageSpecificationContext) Extern() antlr.TerminalNode {
	return s.GetToken(CPP14ParserExtern, 0)
}

func (s *LinkageSpecificationContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(CPP14ParserStringLiteral, 0)
}

func (s *LinkageSpecificationContext) LeftBrace() antlr.TerminalNode {
	return s.GetToken(CPP14ParserLeftBrace, 0)
}

func (s *LinkageSpecificationContext) RightBrace() antlr.TerminalNode {
	return s.GetToken(CPP14ParserRightBrace, 0)
}

func (s *LinkageSpecificationContext) Declaration() IDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *LinkageSpecificationContext) Declarationseq() IDeclarationseqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationseqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationseqContext)
}

func (s *LinkageSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LinkageSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LinkageSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterLinkageSpecification(s)
	}
}

func (s *LinkageSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitLinkageSpecification(s)
	}
}

func (s *LinkageSpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitLinkageSpecification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) LinkageSpecification() (localctx ILinkageSpecificationContext) {
	localctx = NewLinkageSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, CPP14ParserRULE_linkageSpecification)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1271)
		p.Match(CPP14ParserExtern)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1272)
		p.Match(CPP14ParserStringLiteral)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1279)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CPP14ParserLeftBrace:
		{
			p.SetState(1273)
			p.Match(CPP14ParserLeftBrace)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1275)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64((_la-10)) & ^0x3f) == 0 && ((int64(1)<<(_la-10))&1543754443169808157) != 0) || ((int64((_la-74)) & ^0x3f) == 0 && ((int64(1)<<(_la-74))&459384754220313597) != 0) {
			{
				p.SetState(1274)
				p.Declarationseq()
			}

		}
		{
			p.SetState(1277)
			p.Match(CPP14ParserRightBrace)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case CPP14ParserAlignas, CPP14ParserAsm, CPP14ParserAuto, CPP14ParserBool, CPP14ParserChar, CPP14ParserChar16, CPP14ParserChar32, CPP14ParserClass, CPP14ParserConst, CPP14ParserConstexpr, CPP14ParserDecltype, CPP14ParserDouble, CPP14ParserEnum, CPP14ParserExplicit, CPP14ParserExtern, CPP14ParserFloat, CPP14ParserFriend, CPP14ParserInline, CPP14ParserInt, CPP14ParserLong, CPP14ParserMutable, CPP14ParserNamespace, CPP14ParserOperator, CPP14ParserRegister, CPP14ParserShort, CPP14ParserSigned, CPP14ParserStatic, CPP14ParserStatic_assert, CPP14ParserStruct, CPP14ParserTemplate, CPP14ParserThread_local, CPP14ParserTypedef, CPP14ParserTypename_, CPP14ParserUnion, CPP14ParserUnsigned, CPP14ParserUsing, CPP14ParserVirtual, CPP14ParserVoid, CPP14ParserVolatile, CPP14ParserWchar, CPP14ParserLeftParen, CPP14ParserLeftBracket, CPP14ParserStar, CPP14ParserAnd, CPP14ParserTilde, CPP14ParserAndAnd, CPP14ParserDoublecolon, CPP14ParserSemi, CPP14ParserEllipsis, CPP14ParserIdentifier:
		{
			p.SetState(1278)
			p.Declaration()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeSpecifierSeqContext is an interface to support dynamic dispatch.
type IAttributeSpecifierSeqContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAttributeSpecifier() []IAttributeSpecifierContext
	AttributeSpecifier(i int) IAttributeSpecifierContext

	// IsAttributeSpecifierSeqContext differentiates from other interfaces.
	IsAttributeSpecifierSeqContext()
}

type AttributeSpecifierSeqContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeSpecifierSeqContext() *AttributeSpecifierSeqContext {
	var p = new(AttributeSpecifierSeqContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_attributeSpecifierSeq
	return p
}

func InitEmptyAttributeSpecifierSeqContext(p *AttributeSpecifierSeqContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_attributeSpecifierSeq
}

func (*AttributeSpecifierSeqContext) IsAttributeSpecifierSeqContext() {}

func NewAttributeSpecifierSeqContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeSpecifierSeqContext {
	var p = new(AttributeSpecifierSeqContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_attributeSpecifierSeq

	return p
}

func (s *AttributeSpecifierSeqContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeSpecifierSeqContext) AllAttributeSpecifier() []IAttributeSpecifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAttributeSpecifierContext); ok {
			len++
		}
	}

	tst := make([]IAttributeSpecifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAttributeSpecifierContext); ok {
			tst[i] = t.(IAttributeSpecifierContext)
			i++
		}
	}

	return tst
}

func (s *AttributeSpecifierSeqContext) AttributeSpecifier(i int) IAttributeSpecifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSpecifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSpecifierContext)
}

func (s *AttributeSpecifierSeqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeSpecifierSeqContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeSpecifierSeqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterAttributeSpecifierSeq(s)
	}
}

func (s *AttributeSpecifierSeqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitAttributeSpecifierSeq(s)
	}
}

func (s *AttributeSpecifierSeqContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitAttributeSpecifierSeq(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) AttributeSpecifierSeq() (localctx IAttributeSpecifierSeqContext) {
	localctx = NewAttributeSpecifierSeqContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, CPP14ParserRULE_attributeSpecifierSeq)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1282)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1281)
				p.AttributeSpecifier()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(1284)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 144, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeSpecifierContext is an interface to support dynamic dispatch.
type IAttributeSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLeftBracket() []antlr.TerminalNode
	LeftBracket(i int) antlr.TerminalNode
	AllRightBracket() []antlr.TerminalNode
	RightBracket(i int) antlr.TerminalNode
	AttributeList() IAttributeListContext
	Alignmentspecifier() IAlignmentspecifierContext

	// IsAttributeSpecifierContext differentiates from other interfaces.
	IsAttributeSpecifierContext()
}

type AttributeSpecifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeSpecifierContext() *AttributeSpecifierContext {
	var p = new(AttributeSpecifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_attributeSpecifier
	return p
}

func InitEmptyAttributeSpecifierContext(p *AttributeSpecifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_attributeSpecifier
}

func (*AttributeSpecifierContext) IsAttributeSpecifierContext() {}

func NewAttributeSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeSpecifierContext {
	var p = new(AttributeSpecifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_attributeSpecifier

	return p
}

func (s *AttributeSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeSpecifierContext) AllLeftBracket() []antlr.TerminalNode {
	return s.GetTokens(CPP14ParserLeftBracket)
}

func (s *AttributeSpecifierContext) LeftBracket(i int) antlr.TerminalNode {
	return s.GetToken(CPP14ParserLeftBracket, i)
}

func (s *AttributeSpecifierContext) AllRightBracket() []antlr.TerminalNode {
	return s.GetTokens(CPP14ParserRightBracket)
}

func (s *AttributeSpecifierContext) RightBracket(i int) antlr.TerminalNode {
	return s.GetToken(CPP14ParserRightBracket, i)
}

func (s *AttributeSpecifierContext) AttributeList() IAttributeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeListContext)
}

func (s *AttributeSpecifierContext) Alignmentspecifier() IAlignmentspecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlignmentspecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlignmentspecifierContext)
}

func (s *AttributeSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterAttributeSpecifier(s)
	}
}

func (s *AttributeSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitAttributeSpecifier(s)
	}
}

func (s *AttributeSpecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitAttributeSpecifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) AttributeSpecifier() (localctx IAttributeSpecifierContext) {
	localctx = NewAttributeSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, CPP14ParserRULE_attributeSpecifier)
	var _la int

	p.SetState(1294)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CPP14ParserLeftBracket:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1286)
			p.Match(CPP14ParserLeftBracket)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1287)
			p.Match(CPP14ParserLeftBracket)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1289)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CPP14ParserIdentifier {
			{
				p.SetState(1288)
				p.AttributeList()
			}

		}
		{
			p.SetState(1291)
			p.Match(CPP14ParserRightBracket)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1292)
			p.Match(CPP14ParserRightBracket)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case CPP14ParserAlignas:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1293)
			p.Alignmentspecifier()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlignmentspecifierContext is an interface to support dynamic dispatch.
type IAlignmentspecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Alignas() antlr.TerminalNode
	LeftParen() antlr.TerminalNode
	RightParen() antlr.TerminalNode
	TheTypeId() ITheTypeIdContext
	ConstantExpression() IConstantExpressionContext
	Ellipsis() antlr.TerminalNode

	// IsAlignmentspecifierContext differentiates from other interfaces.
	IsAlignmentspecifierContext()
}

type AlignmentspecifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlignmentspecifierContext() *AlignmentspecifierContext {
	var p = new(AlignmentspecifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_alignmentspecifier
	return p
}

func InitEmptyAlignmentspecifierContext(p *AlignmentspecifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_alignmentspecifier
}

func (*AlignmentspecifierContext) IsAlignmentspecifierContext() {}

func NewAlignmentspecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlignmentspecifierContext {
	var p = new(AlignmentspecifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_alignmentspecifier

	return p
}

func (s *AlignmentspecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *AlignmentspecifierContext) Alignas() antlr.TerminalNode {
	return s.GetToken(CPP14ParserAlignas, 0)
}

func (s *AlignmentspecifierContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CPP14ParserLeftParen, 0)
}

func (s *AlignmentspecifierContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CPP14ParserRightParen, 0)
}

func (s *AlignmentspecifierContext) TheTypeId() ITheTypeIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITheTypeIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITheTypeIdContext)
}

func (s *AlignmentspecifierContext) ConstantExpression() IConstantExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantExpressionContext)
}

func (s *AlignmentspecifierContext) Ellipsis() antlr.TerminalNode {
	return s.GetToken(CPP14ParserEllipsis, 0)
}

func (s *AlignmentspecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlignmentspecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlignmentspecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterAlignmentspecifier(s)
	}
}

func (s *AlignmentspecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitAlignmentspecifier(s)
	}
}

func (s *AlignmentspecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitAlignmentspecifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) Alignmentspecifier() (localctx IAlignmentspecifierContext) {
	localctx = NewAlignmentspecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, CPP14ParserRULE_alignmentspecifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1296)
		p.Match(CPP14ParserAlignas)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1297)
		p.Match(CPP14ParserLeftParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1300)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 147, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1298)
			p.TheTypeId()
		}

	case 2:
		{
			p.SetState(1299)
			p.ConstantExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(1303)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CPP14ParserEllipsis {
		{
			p.SetState(1302)
			p.Match(CPP14ParserEllipsis)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1305)
		p.Match(CPP14ParserRightParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeListContext is an interface to support dynamic dispatch.
type IAttributeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAttribute() []IAttributeContext
	Attribute(i int) IAttributeContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode
	Ellipsis() antlr.TerminalNode

	// IsAttributeListContext differentiates from other interfaces.
	IsAttributeListContext()
}

type AttributeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeListContext() *AttributeListContext {
	var p = new(AttributeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_attributeList
	return p
}

func InitEmptyAttributeListContext(p *AttributeListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_attributeList
}

func (*AttributeListContext) IsAttributeListContext() {}

func NewAttributeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeListContext {
	var p = new(AttributeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_attributeList

	return p
}

func (s *AttributeListContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeListContext) AllAttribute() []IAttributeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAttributeContext); ok {
			len++
		}
	}

	tst := make([]IAttributeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAttributeContext); ok {
			tst[i] = t.(IAttributeContext)
			i++
		}
	}

	return tst
}

func (s *AttributeListContext) Attribute(i int) IAttributeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeContext)
}

func (s *AttributeListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(CPP14ParserComma)
}

func (s *AttributeListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(CPP14ParserComma, i)
}

func (s *AttributeListContext) Ellipsis() antlr.TerminalNode {
	return s.GetToken(CPP14ParserEllipsis, 0)
}

func (s *AttributeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterAttributeList(s)
	}
}

func (s *AttributeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitAttributeList(s)
	}
}

func (s *AttributeListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitAttributeList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) AttributeList() (localctx IAttributeListContext) {
	localctx = NewAttributeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, CPP14ParserRULE_attributeList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1307)
		p.Attribute()
	}
	p.SetState(1312)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CPP14ParserComma {
		{
			p.SetState(1308)
			p.Match(CPP14ParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1309)
			p.Attribute()
		}

		p.SetState(1314)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1316)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CPP14ParserEllipsis {
		{
			p.SetState(1315)
			p.Match(CPP14ParserEllipsis)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeContext is an interface to support dynamic dispatch.
type IAttributeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	AttributeNamespace() IAttributeNamespaceContext
	Doublecolon() antlr.TerminalNode
	AttributeArgumentClause() IAttributeArgumentClauseContext

	// IsAttributeContext differentiates from other interfaces.
	IsAttributeContext()
}

type AttributeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeContext() *AttributeContext {
	var p = new(AttributeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_attribute
	return p
}

func InitEmptyAttributeContext(p *AttributeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_attribute
}

func (*AttributeContext) IsAttributeContext() {}

func NewAttributeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeContext {
	var p = new(AttributeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_attribute

	return p
}

func (s *AttributeContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CPP14ParserIdentifier, 0)
}

func (s *AttributeContext) AttributeNamespace() IAttributeNamespaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeNamespaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeNamespaceContext)
}

func (s *AttributeContext) Doublecolon() antlr.TerminalNode {
	return s.GetToken(CPP14ParserDoublecolon, 0)
}

func (s *AttributeContext) AttributeArgumentClause() IAttributeArgumentClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeArgumentClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeArgumentClauseContext)
}

func (s *AttributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterAttribute(s)
	}
}

func (s *AttributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitAttribute(s)
	}
}

func (s *AttributeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitAttribute(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) Attribute() (localctx IAttributeContext) {
	localctx = NewAttributeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, CPP14ParserRULE_attribute)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1321)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 151, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1318)
			p.AttributeNamespace()
		}
		{
			p.SetState(1319)
			p.Match(CPP14ParserDoublecolon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1323)
		p.Match(CPP14ParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1325)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CPP14ParserLeftParen {
		{
			p.SetState(1324)
			p.AttributeArgumentClause()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeNamespaceContext is an interface to support dynamic dispatch.
type IAttributeNamespaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode

	// IsAttributeNamespaceContext differentiates from other interfaces.
	IsAttributeNamespaceContext()
}

type AttributeNamespaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeNamespaceContext() *AttributeNamespaceContext {
	var p = new(AttributeNamespaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_attributeNamespace
	return p
}

func InitEmptyAttributeNamespaceContext(p *AttributeNamespaceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_attributeNamespace
}

func (*AttributeNamespaceContext) IsAttributeNamespaceContext() {}

func NewAttributeNamespaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeNamespaceContext {
	var p = new(AttributeNamespaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_attributeNamespace

	return p
}

func (s *AttributeNamespaceContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeNamespaceContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CPP14ParserIdentifier, 0)
}

func (s *AttributeNamespaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeNamespaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeNamespaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterAttributeNamespace(s)
	}
}

func (s *AttributeNamespaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitAttributeNamespace(s)
	}
}

func (s *AttributeNamespaceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitAttributeNamespace(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) AttributeNamespace() (localctx IAttributeNamespaceContext) {
	localctx = NewAttributeNamespaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, CPP14ParserRULE_attributeNamespace)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1327)
		p.Match(CPP14ParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAttributeArgumentClauseContext is an interface to support dynamic dispatch.
type IAttributeArgumentClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LeftParen() antlr.TerminalNode
	RightParen() antlr.TerminalNode
	BalancedTokenSeq() IBalancedTokenSeqContext

	// IsAttributeArgumentClauseContext differentiates from other interfaces.
	IsAttributeArgumentClauseContext()
}

type AttributeArgumentClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttributeArgumentClauseContext() *AttributeArgumentClauseContext {
	var p = new(AttributeArgumentClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_attributeArgumentClause
	return p
}

func InitEmptyAttributeArgumentClauseContext(p *AttributeArgumentClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_attributeArgumentClause
}

func (*AttributeArgumentClauseContext) IsAttributeArgumentClauseContext() {}

func NewAttributeArgumentClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AttributeArgumentClauseContext {
	var p = new(AttributeArgumentClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_attributeArgumentClause

	return p
}

func (s *AttributeArgumentClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AttributeArgumentClauseContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CPP14ParserLeftParen, 0)
}

func (s *AttributeArgumentClauseContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CPP14ParserRightParen, 0)
}

func (s *AttributeArgumentClauseContext) BalancedTokenSeq() IBalancedTokenSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBalancedTokenSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBalancedTokenSeqContext)
}

func (s *AttributeArgumentClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AttributeArgumentClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AttributeArgumentClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterAttributeArgumentClause(s)
	}
}

func (s *AttributeArgumentClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitAttributeArgumentClause(s)
	}
}

func (s *AttributeArgumentClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitAttributeArgumentClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) AttributeArgumentClause() (localctx IAttributeArgumentClauseContext) {
	localctx = NewAttributeArgumentClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, CPP14ParserRULE_attributeArgumentClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1329)
		p.Match(CPP14ParserLeftParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1331)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-88080385) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&262143) != 0) {
		{
			p.SetState(1330)
			p.BalancedTokenSeq()
		}

	}
	{
		p.SetState(1333)
		p.Match(CPP14ParserRightParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBalancedTokenSeqContext is an interface to support dynamic dispatch.
type IBalancedTokenSeqContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllBalancedtoken() []IBalancedtokenContext
	Balancedtoken(i int) IBalancedtokenContext

	// IsBalancedTokenSeqContext differentiates from other interfaces.
	IsBalancedTokenSeqContext()
}

type BalancedTokenSeqContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBalancedTokenSeqContext() *BalancedTokenSeqContext {
	var p = new(BalancedTokenSeqContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_balancedTokenSeq
	return p
}

func InitEmptyBalancedTokenSeqContext(p *BalancedTokenSeqContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_balancedTokenSeq
}

func (*BalancedTokenSeqContext) IsBalancedTokenSeqContext() {}

func NewBalancedTokenSeqContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BalancedTokenSeqContext {
	var p = new(BalancedTokenSeqContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_balancedTokenSeq

	return p
}

func (s *BalancedTokenSeqContext) GetParser() antlr.Parser { return s.parser }

func (s *BalancedTokenSeqContext) AllBalancedtoken() []IBalancedtokenContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBalancedtokenContext); ok {
			len++
		}
	}

	tst := make([]IBalancedtokenContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBalancedtokenContext); ok {
			tst[i] = t.(IBalancedtokenContext)
			i++
		}
	}

	return tst
}

func (s *BalancedTokenSeqContext) Balancedtoken(i int) IBalancedtokenContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBalancedtokenContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBalancedtokenContext)
}

func (s *BalancedTokenSeqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BalancedTokenSeqContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BalancedTokenSeqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterBalancedTokenSeq(s)
	}
}

func (s *BalancedTokenSeqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitBalancedTokenSeq(s)
	}
}

func (s *BalancedTokenSeqContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitBalancedTokenSeq(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) BalancedTokenSeq() (localctx IBalancedTokenSeqContext) {
	localctx = NewBalancedTokenSeqContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, CPP14ParserRULE_balancedTokenSeq)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1336)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-2) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-88080385) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&262143) != 0) {
		{
			p.SetState(1335)
			p.Balancedtoken()
		}

		p.SetState(1338)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBalancedtokenContext is an interface to support dynamic dispatch.
type IBalancedtokenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLeftParen() []antlr.TerminalNode
	LeftParen(i int) antlr.TerminalNode
	BalancedTokenSeq() IBalancedTokenSeqContext
	AllRightParen() []antlr.TerminalNode
	RightParen(i int) antlr.TerminalNode
	AllLeftBracket() []antlr.TerminalNode
	LeftBracket(i int) antlr.TerminalNode
	AllRightBracket() []antlr.TerminalNode
	RightBracket(i int) antlr.TerminalNode
	AllLeftBrace() []antlr.TerminalNode
	LeftBrace(i int) antlr.TerminalNode
	AllRightBrace() []antlr.TerminalNode
	RightBrace(i int) antlr.TerminalNode

	// IsBalancedtokenContext differentiates from other interfaces.
	IsBalancedtokenContext()
}

type BalancedtokenContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBalancedtokenContext() *BalancedtokenContext {
	var p = new(BalancedtokenContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_balancedtoken
	return p
}

func InitEmptyBalancedtokenContext(p *BalancedtokenContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_balancedtoken
}

func (*BalancedtokenContext) IsBalancedtokenContext() {}

func NewBalancedtokenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BalancedtokenContext {
	var p = new(BalancedtokenContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_balancedtoken

	return p
}

func (s *BalancedtokenContext) GetParser() antlr.Parser { return s.parser }

func (s *BalancedtokenContext) AllLeftParen() []antlr.TerminalNode {
	return s.GetTokens(CPP14ParserLeftParen)
}

func (s *BalancedtokenContext) LeftParen(i int) antlr.TerminalNode {
	return s.GetToken(CPP14ParserLeftParen, i)
}

func (s *BalancedtokenContext) BalancedTokenSeq() IBalancedTokenSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBalancedTokenSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBalancedTokenSeqContext)
}

func (s *BalancedtokenContext) AllRightParen() []antlr.TerminalNode {
	return s.GetTokens(CPP14ParserRightParen)
}

func (s *BalancedtokenContext) RightParen(i int) antlr.TerminalNode {
	return s.GetToken(CPP14ParserRightParen, i)
}

func (s *BalancedtokenContext) AllLeftBracket() []antlr.TerminalNode {
	return s.GetTokens(CPP14ParserLeftBracket)
}

func (s *BalancedtokenContext) LeftBracket(i int) antlr.TerminalNode {
	return s.GetToken(CPP14ParserLeftBracket, i)
}

func (s *BalancedtokenContext) AllRightBracket() []antlr.TerminalNode {
	return s.GetTokens(CPP14ParserRightBracket)
}

func (s *BalancedtokenContext) RightBracket(i int) antlr.TerminalNode {
	return s.GetToken(CPP14ParserRightBracket, i)
}

func (s *BalancedtokenContext) AllLeftBrace() []antlr.TerminalNode {
	return s.GetTokens(CPP14ParserLeftBrace)
}

func (s *BalancedtokenContext) LeftBrace(i int) antlr.TerminalNode {
	return s.GetToken(CPP14ParserLeftBrace, i)
}

func (s *BalancedtokenContext) AllRightBrace() []antlr.TerminalNode {
	return s.GetTokens(CPP14ParserRightBrace)
}

func (s *BalancedtokenContext) RightBrace(i int) antlr.TerminalNode {
	return s.GetToken(CPP14ParserRightBrace, i)
}

func (s *BalancedtokenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BalancedtokenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BalancedtokenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterBalancedtoken(s)
	}
}

func (s *BalancedtokenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitBalancedtoken(s)
	}
}

func (s *BalancedtokenContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitBalancedtoken(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) Balancedtoken() (localctx IBalancedtokenContext) {
	localctx = NewBalancedtokenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, CPP14ParserRULE_balancedtoken)
	var _la int

	var _alt int

	p.SetState(1357)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CPP14ParserLeftParen:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1340)
			p.Match(CPP14ParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1341)
			p.BalancedTokenSeq()
		}
		{
			p.SetState(1342)
			p.Match(CPP14ParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case CPP14ParserLeftBracket:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1344)
			p.Match(CPP14ParserLeftBracket)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1345)
			p.BalancedTokenSeq()
		}
		{
			p.SetState(1346)
			p.Match(CPP14ParserRightBracket)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case CPP14ParserLeftBrace:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1348)
			p.Match(CPP14ParserLeftBrace)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1349)
			p.BalancedTokenSeq()
		}
		{
			p.SetState(1350)
			p.Match(CPP14ParserRightBrace)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case CPP14ParserIntegerLiteral, CPP14ParserCharacterLiteral, CPP14ParserFloatingLiteral, CPP14ParserStringLiteral, CPP14ParserBooleanLiteral, CPP14ParserPointerLiteral, CPP14ParserUserDefinedLiteral, CPP14ParserMultiLineMacro, CPP14ParserDirective, CPP14ParserAlignas, CPP14ParserAlignof, CPP14ParserAsm, CPP14ParserAuto, CPP14ParserBool, CPP14ParserBreak, CPP14ParserCase, CPP14ParserCatch, CPP14ParserChar, CPP14ParserChar16, CPP14ParserChar32, CPP14ParserClass, CPP14ParserConst, CPP14ParserConstexpr, CPP14ParserConst_cast, CPP14ParserContinue, CPP14ParserDecltype, CPP14ParserDefault, CPP14ParserDelete, CPP14ParserDo, CPP14ParserDouble, CPP14ParserDynamic_cast, CPP14ParserElse, CPP14ParserEnum, CPP14ParserExplicit, CPP14ParserExport, CPP14ParserExtern, CPP14ParserFalse_, CPP14ParserFinal, CPP14ParserFloat, CPP14ParserFor, CPP14ParserFriend, CPP14ParserGoto, CPP14ParserIf, CPP14ParserInline, CPP14ParserInt, CPP14ParserLong, CPP14ParserMutable, CPP14ParserNamespace, CPP14ParserNew, CPP14ParserNoexcept, CPP14ParserNullptr, CPP14ParserOperator, CPP14ParserOverride, CPP14ParserPrivate, CPP14ParserProtected, CPP14ParserPublic, CPP14ParserRegister, CPP14ParserReinterpret_cast, CPP14ParserReturn, CPP14ParserShort, CPP14ParserSigned, CPP14ParserSizeof, CPP14ParserStatic, CPP14ParserStatic_assert, CPP14ParserStatic_cast, CPP14ParserStruct, CPP14ParserSwitch, CPP14ParserTemplate, CPP14ParserThis, CPP14ParserThread_local, CPP14ParserThrow, CPP14ParserTrue_, CPP14ParserTry, CPP14ParserTypedef, CPP14ParserTypeid_, CPP14ParserTypename_, CPP14ParserUnion, CPP14ParserUnsigned, CPP14ParserUsing, CPP14ParserVirtual, CPP14ParserVoid, CPP14ParserVolatile, CPP14ParserWchar, CPP14ParserWhile, CPP14ParserPlus, CPP14ParserMinus, CPP14ParserStar, CPP14ParserDiv, CPP14ParserMod, CPP14ParserCaret, CPP14ParserAnd, CPP14ParserOr, CPP14ParserTilde, CPP14ParserNot, CPP14ParserAssign, CPP14ParserLess, CPP14ParserGreater, CPP14ParserPlusAssign, CPP14ParserMinusAssign, CPP14ParserStarAssign, CPP14ParserDivAssign, CPP14ParserModAssign, CPP14ParserXorAssign, CPP14ParserAndAssign, CPP14ParserOrAssign, CPP14ParserLeftShiftAssign, CPP14ParserRightShiftAssign, CPP14ParserEqual, CPP14ParserNotEqual, CPP14ParserLessEqual, CPP14ParserGreaterEqual, CPP14ParserAndAnd, CPP14ParserOrOr, CPP14ParserPlusPlus, CPP14ParserMinusMinus, CPP14ParserComma, CPP14ParserArrowStar, CPP14ParserArrow, CPP14ParserQuestion, CPP14ParserColon, CPP14ParserDoublecolon, CPP14ParserSemi, CPP14ParserDot, CPP14ParserDotStar, CPP14ParserEllipsis, CPP14ParserIdentifier, CPP14ParserDecimalLiteral, CPP14ParserOctalLiteral, CPP14ParserHexadecimalLiteral, CPP14ParserBinaryLiteral, CPP14ParserIntegersuffix, CPP14ParserUserDefinedIntegerLiteral, CPP14ParserUserDefinedFloatingLiteral, CPP14ParserUserDefinedStringLiteral, CPP14ParserUserDefinedCharacterLiteral, CPP14ParserWhitespace, CPP14ParserNewline, CPP14ParserBlockComment, CPP14ParserLineComment:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(1353)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(1352)
					_la = p.GetTokenStream().LA(1)

					if _la <= 0 || ((int64((_la-85)) & ^0x3f) == 0 && ((int64(1)<<(_la-85))&63) != 0) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(1355)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 155, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInitDeclaratorListContext is an interface to support dynamic dispatch.
type IInitDeclaratorListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllInitDeclarator() []IInitDeclaratorContext
	InitDeclarator(i int) IInitDeclaratorContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsInitDeclaratorListContext differentiates from other interfaces.
	IsInitDeclaratorListContext()
}

type InitDeclaratorListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitDeclaratorListContext() *InitDeclaratorListContext {
	var p = new(InitDeclaratorListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_initDeclaratorList
	return p
}

func InitEmptyInitDeclaratorListContext(p *InitDeclaratorListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_initDeclaratorList
}

func (*InitDeclaratorListContext) IsInitDeclaratorListContext() {}

func NewInitDeclaratorListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitDeclaratorListContext {
	var p = new(InitDeclaratorListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_initDeclaratorList

	return p
}

func (s *InitDeclaratorListContext) GetParser() antlr.Parser { return s.parser }

func (s *InitDeclaratorListContext) AllInitDeclarator() []IInitDeclaratorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInitDeclaratorContext); ok {
			len++
		}
	}

	tst := make([]IInitDeclaratorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInitDeclaratorContext); ok {
			tst[i] = t.(IInitDeclaratorContext)
			i++
		}
	}

	return tst
}

func (s *InitDeclaratorListContext) InitDeclarator(i int) IInitDeclaratorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitDeclaratorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitDeclaratorContext)
}

func (s *InitDeclaratorListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(CPP14ParserComma)
}

func (s *InitDeclaratorListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(CPP14ParserComma, i)
}

func (s *InitDeclaratorListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitDeclaratorListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitDeclaratorListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterInitDeclaratorList(s)
	}
}

func (s *InitDeclaratorListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitInitDeclaratorList(s)
	}
}

func (s *InitDeclaratorListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitInitDeclaratorList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) InitDeclaratorList() (localctx IInitDeclaratorListContext) {
	localctx = NewInitDeclaratorListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, CPP14ParserRULE_initDeclaratorList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1359)
		p.InitDeclarator()
	}
	p.SetState(1364)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CPP14ParserComma {
		{
			p.SetState(1360)
			p.Match(CPP14ParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1361)
			p.InitDeclarator()
		}

		p.SetState(1366)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInitDeclaratorContext is an interface to support dynamic dispatch.
type IInitDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Declarator() IDeclaratorContext
	Initializer() IInitializerContext

	// IsInitDeclaratorContext differentiates from other interfaces.
	IsInitDeclaratorContext()
}

type InitDeclaratorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitDeclaratorContext() *InitDeclaratorContext {
	var p = new(InitDeclaratorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_initDeclarator
	return p
}

func InitEmptyInitDeclaratorContext(p *InitDeclaratorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_initDeclarator
}

func (*InitDeclaratorContext) IsInitDeclaratorContext() {}

func NewInitDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitDeclaratorContext {
	var p = new(InitDeclaratorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_initDeclarator

	return p
}

func (s *InitDeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *InitDeclaratorContext) Declarator() IDeclaratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclaratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclaratorContext)
}

func (s *InitDeclaratorContext) Initializer() IInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitializerContext)
}

func (s *InitDeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitDeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitDeclaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterInitDeclarator(s)
	}
}

func (s *InitDeclaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitInitDeclarator(s)
	}
}

func (s *InitDeclaratorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitInitDeclarator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) InitDeclarator() (localctx IInitDeclaratorContext) {
	localctx = NewInitDeclaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, CPP14ParserRULE_initDeclarator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1367)
		p.Declarator()
	}
	p.SetState(1369)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-85)) & ^0x3f) == 0 && ((int64(1)<<(_la-85))&65553) != 0 {
		{
			p.SetState(1368)
			p.Initializer()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclaratorContext is an interface to support dynamic dispatch.
type IDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PointerDeclarator() IPointerDeclaratorContext
	NoPointerDeclarator() INoPointerDeclaratorContext
	ParametersAndQualifiers() IParametersAndQualifiersContext
	TrailingReturnType() ITrailingReturnTypeContext

	// IsDeclaratorContext differentiates from other interfaces.
	IsDeclaratorContext()
}

type DeclaratorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclaratorContext() *DeclaratorContext {
	var p = new(DeclaratorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_declarator
	return p
}

func InitEmptyDeclaratorContext(p *DeclaratorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_declarator
}

func (*DeclaratorContext) IsDeclaratorContext() {}

func NewDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclaratorContext {
	var p = new(DeclaratorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_declarator

	return p
}

func (s *DeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclaratorContext) PointerDeclarator() IPointerDeclaratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPointerDeclaratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPointerDeclaratorContext)
}

func (s *DeclaratorContext) NoPointerDeclarator() INoPointerDeclaratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INoPointerDeclaratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INoPointerDeclaratorContext)
}

func (s *DeclaratorContext) ParametersAndQualifiers() IParametersAndQualifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParametersAndQualifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParametersAndQualifiersContext)
}

func (s *DeclaratorContext) TrailingReturnType() ITrailingReturnTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITrailingReturnTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITrailingReturnTypeContext)
}

func (s *DeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterDeclarator(s)
	}
}

func (s *DeclaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitDeclarator(s)
	}
}

func (s *DeclaratorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitDeclarator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) Declarator() (localctx IDeclaratorContext) {
	localctx = NewDeclaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, CPP14ParserRULE_declarator)
	p.SetState(1376)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 159, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1371)
			p.PointerDeclarator()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1372)
			p.noPointerDeclarator(0)
		}
		{
			p.SetState(1373)
			p.ParametersAndQualifiers()
		}
		{
			p.SetState(1374)
			p.TrailingReturnType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPointerDeclaratorContext is an interface to support dynamic dispatch.
type IPointerDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NoPointerDeclarator() INoPointerDeclaratorContext
	AllPointerOperator() []IPointerOperatorContext
	PointerOperator(i int) IPointerOperatorContext
	AllConst() []antlr.TerminalNode
	Const(i int) antlr.TerminalNode

	// IsPointerDeclaratorContext differentiates from other interfaces.
	IsPointerDeclaratorContext()
}

type PointerDeclaratorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPointerDeclaratorContext() *PointerDeclaratorContext {
	var p = new(PointerDeclaratorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_pointerDeclarator
	return p
}

func InitEmptyPointerDeclaratorContext(p *PointerDeclaratorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_pointerDeclarator
}

func (*PointerDeclaratorContext) IsPointerDeclaratorContext() {}

func NewPointerDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PointerDeclaratorContext {
	var p = new(PointerDeclaratorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_pointerDeclarator

	return p
}

func (s *PointerDeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *PointerDeclaratorContext) NoPointerDeclarator() INoPointerDeclaratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INoPointerDeclaratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INoPointerDeclaratorContext)
}

func (s *PointerDeclaratorContext) AllPointerOperator() []IPointerOperatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPointerOperatorContext); ok {
			len++
		}
	}

	tst := make([]IPointerOperatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPointerOperatorContext); ok {
			tst[i] = t.(IPointerOperatorContext)
			i++
		}
	}

	return tst
}

func (s *PointerDeclaratorContext) PointerOperator(i int) IPointerOperatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPointerOperatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPointerOperatorContext)
}

func (s *PointerDeclaratorContext) AllConst() []antlr.TerminalNode {
	return s.GetTokens(CPP14ParserConst)
}

func (s *PointerDeclaratorContext) Const(i int) antlr.TerminalNode {
	return s.GetToken(CPP14ParserConst, i)
}

func (s *PointerDeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PointerDeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PointerDeclaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterPointerDeclarator(s)
	}
}

func (s *PointerDeclaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitPointerDeclarator(s)
	}
}

func (s *PointerDeclaratorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitPointerDeclarator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) PointerDeclarator() (localctx IPointerDeclaratorContext) {
	localctx = NewPointerDeclaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, CPP14ParserRULE_pointerDeclarator)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1384)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 161, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1378)
				p.PointerOperator()
			}
			p.SetState(1380)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == CPP14ParserConst {
				{
					p.SetState(1379)
					p.Match(CPP14ParserConst)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		}
		p.SetState(1386)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 161, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(1387)
		p.noPointerDeclarator(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INoPointerDeclaratorContext is an interface to support dynamic dispatch.
type INoPointerDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Declaratorid() IDeclaratoridContext
	AttributeSpecifierSeq() IAttributeSpecifierSeqContext
	LeftParen() antlr.TerminalNode
	PointerDeclarator() IPointerDeclaratorContext
	RightParen() antlr.TerminalNode
	NoPointerDeclarator() INoPointerDeclaratorContext
	ParametersAndQualifiers() IParametersAndQualifiersContext
	LeftBracket() antlr.TerminalNode
	RightBracket() antlr.TerminalNode
	ConstantExpression() IConstantExpressionContext

	// IsNoPointerDeclaratorContext differentiates from other interfaces.
	IsNoPointerDeclaratorContext()
}

type NoPointerDeclaratorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNoPointerDeclaratorContext() *NoPointerDeclaratorContext {
	var p = new(NoPointerDeclaratorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_noPointerDeclarator
	return p
}

func InitEmptyNoPointerDeclaratorContext(p *NoPointerDeclaratorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_noPointerDeclarator
}

func (*NoPointerDeclaratorContext) IsNoPointerDeclaratorContext() {}

func NewNoPointerDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NoPointerDeclaratorContext {
	var p = new(NoPointerDeclaratorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_noPointerDeclarator

	return p
}

func (s *NoPointerDeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *NoPointerDeclaratorContext) Declaratorid() IDeclaratoridContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclaratoridContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclaratoridContext)
}

func (s *NoPointerDeclaratorContext) AttributeSpecifierSeq() IAttributeSpecifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSpecifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSpecifierSeqContext)
}

func (s *NoPointerDeclaratorContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CPP14ParserLeftParen, 0)
}

func (s *NoPointerDeclaratorContext) PointerDeclarator() IPointerDeclaratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPointerDeclaratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPointerDeclaratorContext)
}

func (s *NoPointerDeclaratorContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CPP14ParserRightParen, 0)
}

func (s *NoPointerDeclaratorContext) NoPointerDeclarator() INoPointerDeclaratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INoPointerDeclaratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INoPointerDeclaratorContext)
}

func (s *NoPointerDeclaratorContext) ParametersAndQualifiers() IParametersAndQualifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParametersAndQualifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParametersAndQualifiersContext)
}

func (s *NoPointerDeclaratorContext) LeftBracket() antlr.TerminalNode {
	return s.GetToken(CPP14ParserLeftBracket, 0)
}

func (s *NoPointerDeclaratorContext) RightBracket() antlr.TerminalNode {
	return s.GetToken(CPP14ParserRightBracket, 0)
}

func (s *NoPointerDeclaratorContext) ConstantExpression() IConstantExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantExpressionContext)
}

func (s *NoPointerDeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NoPointerDeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NoPointerDeclaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterNoPointerDeclarator(s)
	}
}

func (s *NoPointerDeclaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitNoPointerDeclarator(s)
	}
}

func (s *NoPointerDeclaratorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitNoPointerDeclarator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) NoPointerDeclarator() (localctx INoPointerDeclaratorContext) {
	return p.noPointerDeclarator(0)
}

func (p *CPP14Parser) noPointerDeclarator(_p int) (localctx INoPointerDeclaratorContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewNoPointerDeclaratorContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx INoPointerDeclaratorContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 230
	p.EnterRecursionRule(localctx, 230, CPP14ParserRULE_noPointerDeclarator, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1398)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CPP14ParserDecltype, CPP14ParserOperator, CPP14ParserTilde, CPP14ParserDoublecolon, CPP14ParserEllipsis, CPP14ParserIdentifier:
		{
			p.SetState(1390)
			p.Declaratorid()
		}
		p.SetState(1392)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 162, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1391)
				p.AttributeSpecifierSeq()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case CPP14ParserLeftParen:
		{
			p.SetState(1394)
			p.Match(CPP14ParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1395)
			p.PointerDeclarator()
		}
		{
			p.SetState(1396)
			p.Match(CPP14ParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1414)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 167, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewNoPointerDeclaratorContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, CPP14ParserRULE_noPointerDeclarator)
			p.SetState(1400)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				goto errorExit
			}
			p.SetState(1410)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case CPP14ParserLeftParen:
				{
					p.SetState(1401)
					p.ParametersAndQualifiers()
				}

			case CPP14ParserLeftBracket:
				{
					p.SetState(1402)
					p.Match(CPP14ParserLeftBracket)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(1404)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8364979464334764286) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&4719772474384133137) != 0) || _la == CPP14ParserIdentifier {
					{
						p.SetState(1403)
						p.ConstantExpression()
					}

				}
				{
					p.SetState(1406)
					p.Match(CPP14ParserRightBracket)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(1408)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 165, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(1407)
						p.AttributeSpecifierSeq()
					}

				} else if p.HasError() { // JIM
					goto errorExit
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(1416)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 167, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParametersAndQualifiersContext is an interface to support dynamic dispatch.
type IParametersAndQualifiersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LeftParen() antlr.TerminalNode
	RightParen() antlr.TerminalNode
	ParameterDeclarationClause() IParameterDeclarationClauseContext
	Cvqualifierseq() ICvqualifierseqContext
	Refqualifier() IRefqualifierContext
	ExceptionSpecification() IExceptionSpecificationContext
	AttributeSpecifierSeq() IAttributeSpecifierSeqContext

	// IsParametersAndQualifiersContext differentiates from other interfaces.
	IsParametersAndQualifiersContext()
}

type ParametersAndQualifiersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParametersAndQualifiersContext() *ParametersAndQualifiersContext {
	var p = new(ParametersAndQualifiersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_parametersAndQualifiers
	return p
}

func InitEmptyParametersAndQualifiersContext(p *ParametersAndQualifiersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_parametersAndQualifiers
}

func (*ParametersAndQualifiersContext) IsParametersAndQualifiersContext() {}

func NewParametersAndQualifiersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParametersAndQualifiersContext {
	var p = new(ParametersAndQualifiersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_parametersAndQualifiers

	return p
}

func (s *ParametersAndQualifiersContext) GetParser() antlr.Parser { return s.parser }

func (s *ParametersAndQualifiersContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CPP14ParserLeftParen, 0)
}

func (s *ParametersAndQualifiersContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CPP14ParserRightParen, 0)
}

func (s *ParametersAndQualifiersContext) ParameterDeclarationClause() IParameterDeclarationClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterDeclarationClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterDeclarationClauseContext)
}

func (s *ParametersAndQualifiersContext) Cvqualifierseq() ICvqualifierseqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICvqualifierseqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICvqualifierseqContext)
}

func (s *ParametersAndQualifiersContext) Refqualifier() IRefqualifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRefqualifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRefqualifierContext)
}

func (s *ParametersAndQualifiersContext) ExceptionSpecification() IExceptionSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExceptionSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExceptionSpecificationContext)
}

func (s *ParametersAndQualifiersContext) AttributeSpecifierSeq() IAttributeSpecifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSpecifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSpecifierSeqContext)
}

func (s *ParametersAndQualifiersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParametersAndQualifiersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParametersAndQualifiersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterParametersAndQualifiers(s)
	}
}

func (s *ParametersAndQualifiersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitParametersAndQualifiers(s)
	}
}

func (s *ParametersAndQualifiersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitParametersAndQualifiers(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) ParametersAndQualifiers() (localctx IParametersAndQualifiersContext) {
	localctx = NewParametersAndQualifiersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, CPP14ParserRULE_parametersAndQualifiers)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1417)
		p.Match(CPP14ParserLeftParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1419)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64((_la-10)) & ^0x3f) == 0 && ((int64(1)<<(_la-10))&1237504995584196377) != 0) || ((int64((_la-74)) & ^0x3f) == 0 && ((int64(1)<<(_la-74))&297237575406461917) != 0) {
		{
			p.SetState(1418)
			p.ParameterDeclarationClause()
		}

	}
	{
		p.SetState(1421)
		p.Match(CPP14ParserRightParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1423)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 169, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1422)
			p.Cvqualifierseq()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1426)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 170, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1425)
			p.Refqualifier()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1429)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 171, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1428)
			p.ExceptionSpecification()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1432)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 172, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1431)
			p.AttributeSpecifierSeq()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITrailingReturnTypeContext is an interface to support dynamic dispatch.
type ITrailingReturnTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Arrow() antlr.TerminalNode
	TrailingTypeSpecifierSeq() ITrailingTypeSpecifierSeqContext
	AbstractDeclarator() IAbstractDeclaratorContext

	// IsTrailingReturnTypeContext differentiates from other interfaces.
	IsTrailingReturnTypeContext()
}

type TrailingReturnTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTrailingReturnTypeContext() *TrailingReturnTypeContext {
	var p = new(TrailingReturnTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_trailingReturnType
	return p
}

func InitEmptyTrailingReturnTypeContext(p *TrailingReturnTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_trailingReturnType
}

func (*TrailingReturnTypeContext) IsTrailingReturnTypeContext() {}

func NewTrailingReturnTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TrailingReturnTypeContext {
	var p = new(TrailingReturnTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_trailingReturnType

	return p
}

func (s *TrailingReturnTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TrailingReturnTypeContext) Arrow() antlr.TerminalNode {
	return s.GetToken(CPP14ParserArrow, 0)
}

func (s *TrailingReturnTypeContext) TrailingTypeSpecifierSeq() ITrailingTypeSpecifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITrailingTypeSpecifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITrailingTypeSpecifierSeqContext)
}

func (s *TrailingReturnTypeContext) AbstractDeclarator() IAbstractDeclaratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAbstractDeclaratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAbstractDeclaratorContext)
}

func (s *TrailingReturnTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TrailingReturnTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TrailingReturnTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterTrailingReturnType(s)
	}
}

func (s *TrailingReturnTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitTrailingReturnType(s)
	}
}

func (s *TrailingReturnTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitTrailingReturnType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) TrailingReturnType() (localctx ITrailingReturnTypeContext) {
	localctx = NewTrailingReturnTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, CPP14ParserRULE_trailingReturnType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1434)
		p.Match(CPP14ParserArrow)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1435)
		p.TrailingTypeSpecifierSeq()
	}
	p.SetState(1437)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 173, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1436)
			p.AbstractDeclarator()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPointerOperatorContext is an interface to support dynamic dispatch.
type IPointerOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	And() antlr.TerminalNode
	AndAnd() antlr.TerminalNode
	AttributeSpecifierSeq() IAttributeSpecifierSeqContext
	Star() antlr.TerminalNode
	NestedNameSpecifier() INestedNameSpecifierContext
	Cvqualifierseq() ICvqualifierseqContext

	// IsPointerOperatorContext differentiates from other interfaces.
	IsPointerOperatorContext()
}

type PointerOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPointerOperatorContext() *PointerOperatorContext {
	var p = new(PointerOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_pointerOperator
	return p
}

func InitEmptyPointerOperatorContext(p *PointerOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_pointerOperator
}

func (*PointerOperatorContext) IsPointerOperatorContext() {}

func NewPointerOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PointerOperatorContext {
	var p = new(PointerOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_pointerOperator

	return p
}

func (s *PointerOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *PointerOperatorContext) And() antlr.TerminalNode {
	return s.GetToken(CPP14ParserAnd, 0)
}

func (s *PointerOperatorContext) AndAnd() antlr.TerminalNode {
	return s.GetToken(CPP14ParserAndAnd, 0)
}

func (s *PointerOperatorContext) AttributeSpecifierSeq() IAttributeSpecifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSpecifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSpecifierSeqContext)
}

func (s *PointerOperatorContext) Star() antlr.TerminalNode {
	return s.GetToken(CPP14ParserStar, 0)
}

func (s *PointerOperatorContext) NestedNameSpecifier() INestedNameSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedNameSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedNameSpecifierContext)
}

func (s *PointerOperatorContext) Cvqualifierseq() ICvqualifierseqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICvqualifierseqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICvqualifierseqContext)
}

func (s *PointerOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PointerOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PointerOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterPointerOperator(s)
	}
}

func (s *PointerOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitPointerOperator(s)
	}
}

func (s *PointerOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitPointerOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) PointerOperator() (localctx IPointerOperatorContext) {
	localctx = NewPointerOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, CPP14ParserRULE_pointerOperator)
	var _la int

	p.SetState(1453)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CPP14ParserAnd, CPP14ParserAndAnd:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1439)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CPP14ParserAnd || _la == CPP14ParserAndAnd) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1441)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 174, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1440)
				p.AttributeSpecifierSeq()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case CPP14ParserDecltype, CPP14ParserStar, CPP14ParserDoublecolon, CPP14ParserIdentifier:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1444)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CPP14ParserDecltype || _la == CPP14ParserDoublecolon || _la == CPP14ParserIdentifier {
			{
				p.SetState(1443)
				p.nestedNameSpecifier(0)
			}

		}
		{
			p.SetState(1446)
			p.Match(CPP14ParserStar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1448)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 176, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1447)
				p.AttributeSpecifierSeq()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1451)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 177, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1450)
				p.Cvqualifierseq()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICvqualifierseqContext is an interface to support dynamic dispatch.
type ICvqualifierseqContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCvQualifier() []ICvQualifierContext
	CvQualifier(i int) ICvQualifierContext

	// IsCvqualifierseqContext differentiates from other interfaces.
	IsCvqualifierseqContext()
}

type CvqualifierseqContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCvqualifierseqContext() *CvqualifierseqContext {
	var p = new(CvqualifierseqContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_cvqualifierseq
	return p
}

func InitEmptyCvqualifierseqContext(p *CvqualifierseqContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_cvqualifierseq
}

func (*CvqualifierseqContext) IsCvqualifierseqContext() {}

func NewCvqualifierseqContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CvqualifierseqContext {
	var p = new(CvqualifierseqContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_cvqualifierseq

	return p
}

func (s *CvqualifierseqContext) GetParser() antlr.Parser { return s.parser }

func (s *CvqualifierseqContext) AllCvQualifier() []ICvQualifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICvQualifierContext); ok {
			len++
		}
	}

	tst := make([]ICvQualifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICvQualifierContext); ok {
			tst[i] = t.(ICvQualifierContext)
			i++
		}
	}

	return tst
}

func (s *CvqualifierseqContext) CvQualifier(i int) ICvQualifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICvQualifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICvQualifierContext)
}

func (s *CvqualifierseqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CvqualifierseqContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CvqualifierseqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterCvqualifierseq(s)
	}
}

func (s *CvqualifierseqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitCvqualifierseq(s)
	}
}

func (s *CvqualifierseqContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitCvqualifierseq(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) Cvqualifierseq() (localctx ICvqualifierseqContext) {
	localctx = NewCvqualifierseqContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, CPP14ParserRULE_cvqualifierseq)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1456)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1455)
				p.CvQualifier()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(1458)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 179, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICvQualifierContext is an interface to support dynamic dispatch.
type ICvQualifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Const() antlr.TerminalNode
	Volatile() antlr.TerminalNode

	// IsCvQualifierContext differentiates from other interfaces.
	IsCvQualifierContext()
}

type CvQualifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCvQualifierContext() *CvQualifierContext {
	var p = new(CvQualifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_cvQualifier
	return p
}

func InitEmptyCvQualifierContext(p *CvQualifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_cvQualifier
}

func (*CvQualifierContext) IsCvQualifierContext() {}

func NewCvQualifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CvQualifierContext {
	var p = new(CvQualifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_cvQualifier

	return p
}

func (s *CvQualifierContext) GetParser() antlr.Parser { return s.parser }

func (s *CvQualifierContext) Const() antlr.TerminalNode {
	return s.GetToken(CPP14ParserConst, 0)
}

func (s *CvQualifierContext) Volatile() antlr.TerminalNode {
	return s.GetToken(CPP14ParserVolatile, 0)
}

func (s *CvQualifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CvQualifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CvQualifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterCvQualifier(s)
	}
}

func (s *CvQualifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitCvQualifier(s)
	}
}

func (s *CvQualifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitCvQualifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) CvQualifier() (localctx ICvQualifierContext) {
	localctx = NewCvQualifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, CPP14ParserRULE_cvQualifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1460)
		_la = p.GetTokenStream().LA(1)

		if !(_la == CPP14ParserConst || _la == CPP14ParserVolatile) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRefqualifierContext is an interface to support dynamic dispatch.
type IRefqualifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	And() antlr.TerminalNode
	AndAnd() antlr.TerminalNode

	// IsRefqualifierContext differentiates from other interfaces.
	IsRefqualifierContext()
}

type RefqualifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRefqualifierContext() *RefqualifierContext {
	var p = new(RefqualifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_refqualifier
	return p
}

func InitEmptyRefqualifierContext(p *RefqualifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_refqualifier
}

func (*RefqualifierContext) IsRefqualifierContext() {}

func NewRefqualifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RefqualifierContext {
	var p = new(RefqualifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_refqualifier

	return p
}

func (s *RefqualifierContext) GetParser() antlr.Parser { return s.parser }

func (s *RefqualifierContext) And() antlr.TerminalNode {
	return s.GetToken(CPP14ParserAnd, 0)
}

func (s *RefqualifierContext) AndAnd() antlr.TerminalNode {
	return s.GetToken(CPP14ParserAndAnd, 0)
}

func (s *RefqualifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefqualifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RefqualifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterRefqualifier(s)
	}
}

func (s *RefqualifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitRefqualifier(s)
	}
}

func (s *RefqualifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitRefqualifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) Refqualifier() (localctx IRefqualifierContext) {
	localctx = NewRefqualifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, CPP14ParserRULE_refqualifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1462)
		_la = p.GetTokenStream().LA(1)

		if !(_la == CPP14ParserAnd || _la == CPP14ParserAndAnd) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeclaratoridContext is an interface to support dynamic dispatch.
type IDeclaratoridContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdExpression() IIdExpressionContext
	Ellipsis() antlr.TerminalNode

	// IsDeclaratoridContext differentiates from other interfaces.
	IsDeclaratoridContext()
}

type DeclaratoridContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclaratoridContext() *DeclaratoridContext {
	var p = new(DeclaratoridContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_declaratorid
	return p
}

func InitEmptyDeclaratoridContext(p *DeclaratoridContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_declaratorid
}

func (*DeclaratoridContext) IsDeclaratoridContext() {}

func NewDeclaratoridContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclaratoridContext {
	var p = new(DeclaratoridContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_declaratorid

	return p
}

func (s *DeclaratoridContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclaratoridContext) IdExpression() IIdExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdExpressionContext)
}

func (s *DeclaratoridContext) Ellipsis() antlr.TerminalNode {
	return s.GetToken(CPP14ParserEllipsis, 0)
}

func (s *DeclaratoridContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclaratoridContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclaratoridContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterDeclaratorid(s)
	}
}

func (s *DeclaratoridContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitDeclaratorid(s)
	}
}

func (s *DeclaratoridContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitDeclaratorid(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) Declaratorid() (localctx IDeclaratoridContext) {
	localctx = NewDeclaratoridContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, CPP14ParserRULE_declaratorid)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1465)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CPP14ParserEllipsis {
		{
			p.SetState(1464)
			p.Match(CPP14ParserEllipsis)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1467)
		p.IdExpression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITheTypeIdContext is an interface to support dynamic dispatch.
type ITheTypeIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeSpecifierSeq() ITypeSpecifierSeqContext
	AbstractDeclarator() IAbstractDeclaratorContext

	// IsTheTypeIdContext differentiates from other interfaces.
	IsTheTypeIdContext()
}

type TheTypeIdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTheTypeIdContext() *TheTypeIdContext {
	var p = new(TheTypeIdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_theTypeId
	return p
}

func InitEmptyTheTypeIdContext(p *TheTypeIdContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_theTypeId
}

func (*TheTypeIdContext) IsTheTypeIdContext() {}

func NewTheTypeIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TheTypeIdContext {
	var p = new(TheTypeIdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_theTypeId

	return p
}

func (s *TheTypeIdContext) GetParser() antlr.Parser { return s.parser }

func (s *TheTypeIdContext) TypeSpecifierSeq() ITypeSpecifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSpecifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSpecifierSeqContext)
}

func (s *TheTypeIdContext) AbstractDeclarator() IAbstractDeclaratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAbstractDeclaratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAbstractDeclaratorContext)
}

func (s *TheTypeIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TheTypeIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TheTypeIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterTheTypeId(s)
	}
}

func (s *TheTypeIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitTheTypeId(s)
	}
}

func (s *TheTypeIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitTheTypeId(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) TheTypeId() (localctx ITheTypeIdContext) {
	localctx = NewTheTypeIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, CPP14ParserRULE_theTypeId)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1469)
		p.TypeSpecifierSeq()
	}
	p.SetState(1471)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 181, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1470)
			p.AbstractDeclarator()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAbstractDeclaratorContext is an interface to support dynamic dispatch.
type IAbstractDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PointerAbstractDeclarator() IPointerAbstractDeclaratorContext
	ParametersAndQualifiers() IParametersAndQualifiersContext
	TrailingReturnType() ITrailingReturnTypeContext
	NoPointerAbstractDeclarator() INoPointerAbstractDeclaratorContext
	AbstractPackDeclarator() IAbstractPackDeclaratorContext

	// IsAbstractDeclaratorContext differentiates from other interfaces.
	IsAbstractDeclaratorContext()
}

type AbstractDeclaratorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAbstractDeclaratorContext() *AbstractDeclaratorContext {
	var p = new(AbstractDeclaratorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_abstractDeclarator
	return p
}

func InitEmptyAbstractDeclaratorContext(p *AbstractDeclaratorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_abstractDeclarator
}

func (*AbstractDeclaratorContext) IsAbstractDeclaratorContext() {}

func NewAbstractDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AbstractDeclaratorContext {
	var p = new(AbstractDeclaratorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_abstractDeclarator

	return p
}

func (s *AbstractDeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *AbstractDeclaratorContext) PointerAbstractDeclarator() IPointerAbstractDeclaratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPointerAbstractDeclaratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPointerAbstractDeclaratorContext)
}

func (s *AbstractDeclaratorContext) ParametersAndQualifiers() IParametersAndQualifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParametersAndQualifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParametersAndQualifiersContext)
}

func (s *AbstractDeclaratorContext) TrailingReturnType() ITrailingReturnTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITrailingReturnTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITrailingReturnTypeContext)
}

func (s *AbstractDeclaratorContext) NoPointerAbstractDeclarator() INoPointerAbstractDeclaratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INoPointerAbstractDeclaratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INoPointerAbstractDeclaratorContext)
}

func (s *AbstractDeclaratorContext) AbstractPackDeclarator() IAbstractPackDeclaratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAbstractPackDeclaratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAbstractPackDeclaratorContext)
}

func (s *AbstractDeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AbstractDeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AbstractDeclaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterAbstractDeclarator(s)
	}
}

func (s *AbstractDeclaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitAbstractDeclarator(s)
	}
}

func (s *AbstractDeclaratorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitAbstractDeclarator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) AbstractDeclarator() (localctx IAbstractDeclaratorContext) {
	localctx = NewAbstractDeclaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, CPP14ParserRULE_abstractDeclarator)
	p.SetState(1481)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 183, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1473)
			p.PointerAbstractDeclarator()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1475)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 182, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1474)
				p.noPointerAbstractDeclarator(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1477)
			p.ParametersAndQualifiers()
		}
		{
			p.SetState(1478)
			p.TrailingReturnType()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1480)
			p.AbstractPackDeclarator()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPointerAbstractDeclaratorContext is an interface to support dynamic dispatch.
type IPointerAbstractDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NoPointerAbstractDeclarator() INoPointerAbstractDeclaratorContext
	AllPointerOperator() []IPointerOperatorContext
	PointerOperator(i int) IPointerOperatorContext

	// IsPointerAbstractDeclaratorContext differentiates from other interfaces.
	IsPointerAbstractDeclaratorContext()
}

type PointerAbstractDeclaratorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPointerAbstractDeclaratorContext() *PointerAbstractDeclaratorContext {
	var p = new(PointerAbstractDeclaratorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_pointerAbstractDeclarator
	return p
}

func InitEmptyPointerAbstractDeclaratorContext(p *PointerAbstractDeclaratorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_pointerAbstractDeclarator
}

func (*PointerAbstractDeclaratorContext) IsPointerAbstractDeclaratorContext() {}

func NewPointerAbstractDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PointerAbstractDeclaratorContext {
	var p = new(PointerAbstractDeclaratorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_pointerAbstractDeclarator

	return p
}

func (s *PointerAbstractDeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *PointerAbstractDeclaratorContext) NoPointerAbstractDeclarator() INoPointerAbstractDeclaratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INoPointerAbstractDeclaratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INoPointerAbstractDeclaratorContext)
}

func (s *PointerAbstractDeclaratorContext) AllPointerOperator() []IPointerOperatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPointerOperatorContext); ok {
			len++
		}
	}

	tst := make([]IPointerOperatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPointerOperatorContext); ok {
			tst[i] = t.(IPointerOperatorContext)
			i++
		}
	}

	return tst
}

func (s *PointerAbstractDeclaratorContext) PointerOperator(i int) IPointerOperatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPointerOperatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPointerOperatorContext)
}

func (s *PointerAbstractDeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PointerAbstractDeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PointerAbstractDeclaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterPointerAbstractDeclarator(s)
	}
}

func (s *PointerAbstractDeclaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitPointerAbstractDeclarator(s)
	}
}

func (s *PointerAbstractDeclaratorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitPointerAbstractDeclarator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) PointerAbstractDeclarator() (localctx IPointerAbstractDeclaratorContext) {
	localctx = NewPointerAbstractDeclaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, CPP14ParserRULE_pointerAbstractDeclarator)
	var _alt int

	p.SetState(1492)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CPP14ParserLeftParen, CPP14ParserLeftBracket:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1483)
			p.noPointerAbstractDeclarator(0)
		}

	case CPP14ParserDecltype, CPP14ParserStar, CPP14ParserAnd, CPP14ParserAndAnd, CPP14ParserDoublecolon, CPP14ParserIdentifier:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1485)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(1484)
					p.PointerOperator()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(1487)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 184, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(1490)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 185, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1489)
				p.noPointerAbstractDeclarator(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INoPointerAbstractDeclaratorContext is an interface to support dynamic dispatch.
type INoPointerAbstractDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ParametersAndQualifiers() IParametersAndQualifiersContext
	LeftBracket() antlr.TerminalNode
	RightBracket() antlr.TerminalNode
	ConstantExpression() IConstantExpressionContext
	AttributeSpecifierSeq() IAttributeSpecifierSeqContext
	LeftParen() antlr.TerminalNode
	PointerAbstractDeclarator() IPointerAbstractDeclaratorContext
	RightParen() antlr.TerminalNode
	AllNoPointerAbstractDeclarator() []INoPointerAbstractDeclaratorContext
	NoPointerAbstractDeclarator(i int) INoPointerAbstractDeclaratorContext

	// IsNoPointerAbstractDeclaratorContext differentiates from other interfaces.
	IsNoPointerAbstractDeclaratorContext()
}

type NoPointerAbstractDeclaratorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNoPointerAbstractDeclaratorContext() *NoPointerAbstractDeclaratorContext {
	var p = new(NoPointerAbstractDeclaratorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_noPointerAbstractDeclarator
	return p
}

func InitEmptyNoPointerAbstractDeclaratorContext(p *NoPointerAbstractDeclaratorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_noPointerAbstractDeclarator
}

func (*NoPointerAbstractDeclaratorContext) IsNoPointerAbstractDeclaratorContext() {}

func NewNoPointerAbstractDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NoPointerAbstractDeclaratorContext {
	var p = new(NoPointerAbstractDeclaratorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_noPointerAbstractDeclarator

	return p
}

func (s *NoPointerAbstractDeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *NoPointerAbstractDeclaratorContext) ParametersAndQualifiers() IParametersAndQualifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParametersAndQualifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParametersAndQualifiersContext)
}

func (s *NoPointerAbstractDeclaratorContext) LeftBracket() antlr.TerminalNode {
	return s.GetToken(CPP14ParserLeftBracket, 0)
}

func (s *NoPointerAbstractDeclaratorContext) RightBracket() antlr.TerminalNode {
	return s.GetToken(CPP14ParserRightBracket, 0)
}

func (s *NoPointerAbstractDeclaratorContext) ConstantExpression() IConstantExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantExpressionContext)
}

func (s *NoPointerAbstractDeclaratorContext) AttributeSpecifierSeq() IAttributeSpecifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSpecifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSpecifierSeqContext)
}

func (s *NoPointerAbstractDeclaratorContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CPP14ParserLeftParen, 0)
}

func (s *NoPointerAbstractDeclaratorContext) PointerAbstractDeclarator() IPointerAbstractDeclaratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPointerAbstractDeclaratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPointerAbstractDeclaratorContext)
}

func (s *NoPointerAbstractDeclaratorContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CPP14ParserRightParen, 0)
}

func (s *NoPointerAbstractDeclaratorContext) AllNoPointerAbstractDeclarator() []INoPointerAbstractDeclaratorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INoPointerAbstractDeclaratorContext); ok {
			len++
		}
	}

	tst := make([]INoPointerAbstractDeclaratorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INoPointerAbstractDeclaratorContext); ok {
			tst[i] = t.(INoPointerAbstractDeclaratorContext)
			i++
		}
	}

	return tst
}

func (s *NoPointerAbstractDeclaratorContext) NoPointerAbstractDeclarator(i int) INoPointerAbstractDeclaratorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INoPointerAbstractDeclaratorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INoPointerAbstractDeclaratorContext)
}

func (s *NoPointerAbstractDeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NoPointerAbstractDeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NoPointerAbstractDeclaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterNoPointerAbstractDeclarator(s)
	}
}

func (s *NoPointerAbstractDeclaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitNoPointerAbstractDeclarator(s)
	}
}

func (s *NoPointerAbstractDeclaratorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitNoPointerAbstractDeclarator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) NoPointerAbstractDeclarator() (localctx INoPointerAbstractDeclaratorContext) {
	return p.noPointerAbstractDeclarator(0)
}

func (p *CPP14Parser) noPointerAbstractDeclarator(_p int) (localctx INoPointerAbstractDeclaratorContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewNoPointerAbstractDeclaratorContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx INoPointerAbstractDeclaratorContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 252
	p.EnterRecursionRule(localctx, 252, CPP14ParserRULE_noPointerAbstractDeclarator, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1508)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 189, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1495)
			p.ParametersAndQualifiers()
		}

	case 2:
		{
			p.SetState(1496)
			p.Match(CPP14ParserLeftBracket)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1498)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8364979464334764286) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&4719772474384133137) != 0) || _la == CPP14ParserIdentifier {
			{
				p.SetState(1497)
				p.ConstantExpression()
			}

		}
		{
			p.SetState(1500)
			p.Match(CPP14ParserRightBracket)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1502)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 188, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1501)
				p.AttributeSpecifierSeq()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		{
			p.SetState(1504)
			p.Match(CPP14ParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1505)
			p.PointerAbstractDeclarator()
		}
		{
			p.SetState(1506)
			p.Match(CPP14ParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1525)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 193, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewNoPointerAbstractDeclaratorContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, CPP14ParserRULE_noPointerAbstractDeclarator)
			p.SetState(1510)

			if !(p.Precpred(p.GetParserRuleContext(), 4)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
				goto errorExit
			}
			p.SetState(1521)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 192, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(1511)
					p.ParametersAndQualifiers()
				}

			case 2:
				{
					p.SetState(1512)
					p.noPointerAbstractDeclarator(0)
				}
				{
					p.SetState(1513)
					p.Match(CPP14ParserLeftBracket)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(1515)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8364979464334764286) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&4719772474384133137) != 0) || _la == CPP14ParserIdentifier {
					{
						p.SetState(1514)
						p.ConstantExpression()
					}

				}
				{
					p.SetState(1517)
					p.Match(CPP14ParserRightBracket)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(1519)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 191, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(1518)
						p.AttributeSpecifierSeq()
					}

				} else if p.HasError() { // JIM
					goto errorExit
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(1527)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 193, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAbstractPackDeclaratorContext is an interface to support dynamic dispatch.
type IAbstractPackDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NoPointerAbstractPackDeclarator() INoPointerAbstractPackDeclaratorContext
	AllPointerOperator() []IPointerOperatorContext
	PointerOperator(i int) IPointerOperatorContext

	// IsAbstractPackDeclaratorContext differentiates from other interfaces.
	IsAbstractPackDeclaratorContext()
}

type AbstractPackDeclaratorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAbstractPackDeclaratorContext() *AbstractPackDeclaratorContext {
	var p = new(AbstractPackDeclaratorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_abstractPackDeclarator
	return p
}

func InitEmptyAbstractPackDeclaratorContext(p *AbstractPackDeclaratorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_abstractPackDeclarator
}

func (*AbstractPackDeclaratorContext) IsAbstractPackDeclaratorContext() {}

func NewAbstractPackDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AbstractPackDeclaratorContext {
	var p = new(AbstractPackDeclaratorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_abstractPackDeclarator

	return p
}

func (s *AbstractPackDeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *AbstractPackDeclaratorContext) NoPointerAbstractPackDeclarator() INoPointerAbstractPackDeclaratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INoPointerAbstractPackDeclaratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INoPointerAbstractPackDeclaratorContext)
}

func (s *AbstractPackDeclaratorContext) AllPointerOperator() []IPointerOperatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPointerOperatorContext); ok {
			len++
		}
	}

	tst := make([]IPointerOperatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPointerOperatorContext); ok {
			tst[i] = t.(IPointerOperatorContext)
			i++
		}
	}

	return tst
}

func (s *AbstractPackDeclaratorContext) PointerOperator(i int) IPointerOperatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPointerOperatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPointerOperatorContext)
}

func (s *AbstractPackDeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AbstractPackDeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AbstractPackDeclaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterAbstractPackDeclarator(s)
	}
}

func (s *AbstractPackDeclaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitAbstractPackDeclarator(s)
	}
}

func (s *AbstractPackDeclaratorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitAbstractPackDeclarator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) AbstractPackDeclarator() (localctx IAbstractPackDeclaratorContext) {
	localctx = NewAbstractPackDeclaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, CPP14ParserRULE_abstractPackDeclarator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1531)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CPP14ParserDecltype || ((int64((_la-93)) & ^0x3f) == 0 && ((int64(1)<<(_la-93))&566969237521) != 0) {
		{
			p.SetState(1528)
			p.PointerOperator()
		}

		p.SetState(1533)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1534)
		p.noPointerAbstractPackDeclarator(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INoPointerAbstractPackDeclaratorContext is an interface to support dynamic dispatch.
type INoPointerAbstractPackDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Ellipsis() antlr.TerminalNode
	NoPointerAbstractPackDeclarator() INoPointerAbstractPackDeclaratorContext
	ParametersAndQualifiers() IParametersAndQualifiersContext
	LeftBracket() antlr.TerminalNode
	RightBracket() antlr.TerminalNode
	ConstantExpression() IConstantExpressionContext
	AttributeSpecifierSeq() IAttributeSpecifierSeqContext

	// IsNoPointerAbstractPackDeclaratorContext differentiates from other interfaces.
	IsNoPointerAbstractPackDeclaratorContext()
}

type NoPointerAbstractPackDeclaratorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNoPointerAbstractPackDeclaratorContext() *NoPointerAbstractPackDeclaratorContext {
	var p = new(NoPointerAbstractPackDeclaratorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_noPointerAbstractPackDeclarator
	return p
}

func InitEmptyNoPointerAbstractPackDeclaratorContext(p *NoPointerAbstractPackDeclaratorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_noPointerAbstractPackDeclarator
}

func (*NoPointerAbstractPackDeclaratorContext) IsNoPointerAbstractPackDeclaratorContext() {}

func NewNoPointerAbstractPackDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NoPointerAbstractPackDeclaratorContext {
	var p = new(NoPointerAbstractPackDeclaratorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_noPointerAbstractPackDeclarator

	return p
}

func (s *NoPointerAbstractPackDeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *NoPointerAbstractPackDeclaratorContext) Ellipsis() antlr.TerminalNode {
	return s.GetToken(CPP14ParserEllipsis, 0)
}

func (s *NoPointerAbstractPackDeclaratorContext) NoPointerAbstractPackDeclarator() INoPointerAbstractPackDeclaratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INoPointerAbstractPackDeclaratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INoPointerAbstractPackDeclaratorContext)
}

func (s *NoPointerAbstractPackDeclaratorContext) ParametersAndQualifiers() IParametersAndQualifiersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParametersAndQualifiersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParametersAndQualifiersContext)
}

func (s *NoPointerAbstractPackDeclaratorContext) LeftBracket() antlr.TerminalNode {
	return s.GetToken(CPP14ParserLeftBracket, 0)
}

func (s *NoPointerAbstractPackDeclaratorContext) RightBracket() antlr.TerminalNode {
	return s.GetToken(CPP14ParserRightBracket, 0)
}

func (s *NoPointerAbstractPackDeclaratorContext) ConstantExpression() IConstantExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantExpressionContext)
}

func (s *NoPointerAbstractPackDeclaratorContext) AttributeSpecifierSeq() IAttributeSpecifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSpecifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSpecifierSeqContext)
}

func (s *NoPointerAbstractPackDeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NoPointerAbstractPackDeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NoPointerAbstractPackDeclaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterNoPointerAbstractPackDeclarator(s)
	}
}

func (s *NoPointerAbstractPackDeclaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitNoPointerAbstractPackDeclarator(s)
	}
}

func (s *NoPointerAbstractPackDeclaratorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitNoPointerAbstractPackDeclarator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) NoPointerAbstractPackDeclarator() (localctx INoPointerAbstractPackDeclaratorContext) {
	return p.noPointerAbstractPackDeclarator(0)
}

func (p *CPP14Parser) noPointerAbstractPackDeclarator(_p int) (localctx INoPointerAbstractPackDeclaratorContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewNoPointerAbstractPackDeclaratorContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx INoPointerAbstractPackDeclaratorContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 256
	p.EnterRecursionRule(localctx, 256, CPP14ParserRULE_noPointerAbstractPackDeclarator, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1537)
		p.Match(CPP14ParserEllipsis)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1553)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 198, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewNoPointerAbstractPackDeclaratorContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, CPP14ParserRULE_noPointerAbstractPackDeclarator)
			p.SetState(1539)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				goto errorExit
			}
			p.SetState(1549)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case CPP14ParserLeftParen:
				{
					p.SetState(1540)
					p.ParametersAndQualifiers()
				}

			case CPP14ParserLeftBracket:
				{
					p.SetState(1541)
					p.Match(CPP14ParserLeftBracket)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(1543)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8364979464334764286) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&4719772474384133137) != 0) || _la == CPP14ParserIdentifier {
					{
						p.SetState(1542)
						p.ConstantExpression()
					}

				}
				{
					p.SetState(1545)
					p.Match(CPP14ParserRightBracket)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(1547)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 196, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(1546)
						p.AttributeSpecifierSeq()
					}

				} else if p.HasError() { // JIM
					goto errorExit
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(1555)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 198, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParameterDeclarationClauseContext is an interface to support dynamic dispatch.
type IParameterDeclarationClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ParameterDeclarationList() IParameterDeclarationListContext
	Ellipsis() antlr.TerminalNode
	Comma() antlr.TerminalNode

	// IsParameterDeclarationClauseContext differentiates from other interfaces.
	IsParameterDeclarationClauseContext()
}

type ParameterDeclarationClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterDeclarationClauseContext() *ParameterDeclarationClauseContext {
	var p = new(ParameterDeclarationClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_parameterDeclarationClause
	return p
}

func InitEmptyParameterDeclarationClauseContext(p *ParameterDeclarationClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_parameterDeclarationClause
}

func (*ParameterDeclarationClauseContext) IsParameterDeclarationClauseContext() {}

func NewParameterDeclarationClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterDeclarationClauseContext {
	var p = new(ParameterDeclarationClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_parameterDeclarationClause

	return p
}

func (s *ParameterDeclarationClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterDeclarationClauseContext) ParameterDeclarationList() IParameterDeclarationListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterDeclarationListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterDeclarationListContext)
}

func (s *ParameterDeclarationClauseContext) Ellipsis() antlr.TerminalNode {
	return s.GetToken(CPP14ParserEllipsis, 0)
}

func (s *ParameterDeclarationClauseContext) Comma() antlr.TerminalNode {
	return s.GetToken(CPP14ParserComma, 0)
}

func (s *ParameterDeclarationClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterDeclarationClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterDeclarationClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterParameterDeclarationClause(s)
	}
}

func (s *ParameterDeclarationClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitParameterDeclarationClause(s)
	}
}

func (s *ParameterDeclarationClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitParameterDeclarationClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) ParameterDeclarationClause() (localctx IParameterDeclarationClauseContext) {
	localctx = NewParameterDeclarationClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, CPP14ParserRULE_parameterDeclarationClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1556)
		p.ParameterDeclarationList()
	}
	p.SetState(1561)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CPP14ParserComma || _la == CPP14ParserEllipsis {
		p.SetState(1558)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CPP14ParserComma {
			{
				p.SetState(1557)
				p.Match(CPP14ParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1560)
			p.Match(CPP14ParserEllipsis)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParameterDeclarationListContext is an interface to support dynamic dispatch.
type IParameterDeclarationListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllParameterDeclaration() []IParameterDeclarationContext
	ParameterDeclaration(i int) IParameterDeclarationContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsParameterDeclarationListContext differentiates from other interfaces.
	IsParameterDeclarationListContext()
}

type ParameterDeclarationListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterDeclarationListContext() *ParameterDeclarationListContext {
	var p = new(ParameterDeclarationListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_parameterDeclarationList
	return p
}

func InitEmptyParameterDeclarationListContext(p *ParameterDeclarationListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_parameterDeclarationList
}

func (*ParameterDeclarationListContext) IsParameterDeclarationListContext() {}

func NewParameterDeclarationListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterDeclarationListContext {
	var p = new(ParameterDeclarationListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_parameterDeclarationList

	return p
}

func (s *ParameterDeclarationListContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterDeclarationListContext) AllParameterDeclaration() []IParameterDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParameterDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IParameterDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParameterDeclarationContext); ok {
			tst[i] = t.(IParameterDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *ParameterDeclarationListContext) ParameterDeclaration(i int) IParameterDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterDeclarationContext)
}

func (s *ParameterDeclarationListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(CPP14ParserComma)
}

func (s *ParameterDeclarationListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(CPP14ParserComma, i)
}

func (s *ParameterDeclarationListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterDeclarationListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterDeclarationListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterParameterDeclarationList(s)
	}
}

func (s *ParameterDeclarationListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitParameterDeclarationList(s)
	}
}

func (s *ParameterDeclarationListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitParameterDeclarationList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) ParameterDeclarationList() (localctx IParameterDeclarationListContext) {
	localctx = NewParameterDeclarationListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, CPP14ParserRULE_parameterDeclarationList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1563)
		p.ParameterDeclaration()
	}
	p.SetState(1568)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 201, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1564)
				p.Match(CPP14ParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1565)
				p.ParameterDeclaration()
			}

		}
		p.SetState(1570)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 201, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParameterDeclarationContext is an interface to support dynamic dispatch.
type IParameterDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DeclSpecifierSeq() IDeclSpecifierSeqContext
	Declarator() IDeclaratorContext
	AttributeSpecifierSeq() IAttributeSpecifierSeqContext
	Assign() antlr.TerminalNode
	InitializerClause() IInitializerClauseContext
	AbstractDeclarator() IAbstractDeclaratorContext

	// IsParameterDeclarationContext differentiates from other interfaces.
	IsParameterDeclarationContext()
}

type ParameterDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterDeclarationContext() *ParameterDeclarationContext {
	var p = new(ParameterDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_parameterDeclaration
	return p
}

func InitEmptyParameterDeclarationContext(p *ParameterDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_parameterDeclaration
}

func (*ParameterDeclarationContext) IsParameterDeclarationContext() {}

func NewParameterDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterDeclarationContext {
	var p = new(ParameterDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_parameterDeclaration

	return p
}

func (s *ParameterDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterDeclarationContext) DeclSpecifierSeq() IDeclSpecifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclSpecifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclSpecifierSeqContext)
}

func (s *ParameterDeclarationContext) Declarator() IDeclaratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclaratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclaratorContext)
}

func (s *ParameterDeclarationContext) AttributeSpecifierSeq() IAttributeSpecifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSpecifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSpecifierSeqContext)
}

func (s *ParameterDeclarationContext) Assign() antlr.TerminalNode {
	return s.GetToken(CPP14ParserAssign, 0)
}

func (s *ParameterDeclarationContext) InitializerClause() IInitializerClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitializerClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitializerClauseContext)
}

func (s *ParameterDeclarationContext) AbstractDeclarator() IAbstractDeclaratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAbstractDeclaratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAbstractDeclaratorContext)
}

func (s *ParameterDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterParameterDeclaration(s)
	}
}

func (s *ParameterDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitParameterDeclaration(s)
	}
}

func (s *ParameterDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitParameterDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) ParameterDeclaration() (localctx IParameterDeclarationContext) {
	localctx = NewParameterDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, CPP14ParserRULE_parameterDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1572)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CPP14ParserAlignas || _la == CPP14ParserLeftBracket {
		{
			p.SetState(1571)
			p.AttributeSpecifierSeq()
		}

	}
	{
		p.SetState(1574)
		p.DeclSpecifierSeq()
	}
	p.SetState(1579)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 204, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1575)
			p.Declarator()
		}

	case 2:
		p.SetState(1577)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 203, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1576)
				p.AbstractDeclarator()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(1583)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CPP14ParserAssign {
		{
			p.SetState(1581)
			p.Match(CPP14ParserAssign)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1582)
			p.InitializerClause()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionDefinitionContext is an interface to support dynamic dispatch.
type IFunctionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Declarator() IDeclaratorContext
	FunctionBody() IFunctionBodyContext
	AttributeSpecifierSeq() IAttributeSpecifierSeqContext
	DeclSpecifierSeq() IDeclSpecifierSeqContext
	VirtualSpecifierSeq() IVirtualSpecifierSeqContext

	// IsFunctionDefinitionContext differentiates from other interfaces.
	IsFunctionDefinitionContext()
}

type FunctionDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionDefinitionContext() *FunctionDefinitionContext {
	var p = new(FunctionDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_functionDefinition
	return p
}

func InitEmptyFunctionDefinitionContext(p *FunctionDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_functionDefinition
}

func (*FunctionDefinitionContext) IsFunctionDefinitionContext() {}

func NewFunctionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionDefinitionContext {
	var p = new(FunctionDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_functionDefinition

	return p
}

func (s *FunctionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionDefinitionContext) Declarator() IDeclaratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclaratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclaratorContext)
}

func (s *FunctionDefinitionContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *FunctionDefinitionContext) AttributeSpecifierSeq() IAttributeSpecifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSpecifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSpecifierSeqContext)
}

func (s *FunctionDefinitionContext) DeclSpecifierSeq() IDeclSpecifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclSpecifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclSpecifierSeqContext)
}

func (s *FunctionDefinitionContext) VirtualSpecifierSeq() IVirtualSpecifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVirtualSpecifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVirtualSpecifierSeqContext)
}

func (s *FunctionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterFunctionDefinition(s)
	}
}

func (s *FunctionDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitFunctionDefinition(s)
	}
}

func (s *FunctionDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitFunctionDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) FunctionDefinition() (localctx IFunctionDefinitionContext) {
	localctx = NewFunctionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, CPP14ParserRULE_functionDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1586)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CPP14ParserAlignas || _la == CPP14ParserLeftBracket {
		{
			p.SetState(1585)
			p.AttributeSpecifierSeq()
		}

	}
	p.SetState(1589)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 207, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1588)
			p.DeclSpecifierSeq()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1591)
		p.Declarator()
	}
	p.SetState(1593)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CPP14ParserFinal || _la == CPP14ParserOverride {
		{
			p.SetState(1592)
			p.VirtualSpecifierSeq()
		}

	}
	{
		p.SetState(1595)
		p.FunctionBody()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionBodyContext is an interface to support dynamic dispatch.
type IFunctionBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CompoundStatement() ICompoundStatementContext
	ConstructorInitializer() IConstructorInitializerContext
	FunctionTryBlock() IFunctionTryBlockContext
	Assign() antlr.TerminalNode
	Semi() antlr.TerminalNode
	Default() antlr.TerminalNode
	Delete() antlr.TerminalNode

	// IsFunctionBodyContext differentiates from other interfaces.
	IsFunctionBodyContext()
}

type FunctionBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionBodyContext() *FunctionBodyContext {
	var p = new(FunctionBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_functionBody
	return p
}

func InitEmptyFunctionBodyContext(p *FunctionBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_functionBody
}

func (*FunctionBodyContext) IsFunctionBodyContext() {}

func NewFunctionBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionBodyContext {
	var p = new(FunctionBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_functionBody

	return p
}

func (s *FunctionBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionBodyContext) CompoundStatement() ICompoundStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementContext)
}

func (s *FunctionBodyContext) ConstructorInitializer() IConstructorInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstructorInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstructorInitializerContext)
}

func (s *FunctionBodyContext) FunctionTryBlock() IFunctionTryBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionTryBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionTryBlockContext)
}

func (s *FunctionBodyContext) Assign() antlr.TerminalNode {
	return s.GetToken(CPP14ParserAssign, 0)
}

func (s *FunctionBodyContext) Semi() antlr.TerminalNode {
	return s.GetToken(CPP14ParserSemi, 0)
}

func (s *FunctionBodyContext) Default() antlr.TerminalNode {
	return s.GetToken(CPP14ParserDefault, 0)
}

func (s *FunctionBodyContext) Delete() antlr.TerminalNode {
	return s.GetToken(CPP14ParserDelete, 0)
}

func (s *FunctionBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterFunctionBody(s)
	}
}

func (s *FunctionBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitFunctionBody(s)
	}
}

func (s *FunctionBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitFunctionBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) FunctionBody() (localctx IFunctionBodyContext) {
	localctx = NewFunctionBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, CPP14ParserRULE_functionBody)
	var _la int

	p.SetState(1605)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CPP14ParserLeftBrace, CPP14ParserColon:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1598)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CPP14ParserColon {
			{
				p.SetState(1597)
				p.ConstructorInitializer()
			}

		}
		{
			p.SetState(1600)
			p.CompoundStatement()
		}

	case CPP14ParserTry:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1601)
			p.FunctionTryBlock()
		}

	case CPP14ParserAssign:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1602)
			p.Match(CPP14ParserAssign)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1603)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CPP14ParserDefault || _la == CPP14ParserDelete) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1604)
			p.Match(CPP14ParserSemi)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInitializerContext is an interface to support dynamic dispatch.
type IInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BraceOrEqualInitializer() IBraceOrEqualInitializerContext
	LeftParen() antlr.TerminalNode
	ExpressionList() IExpressionListContext
	RightParen() antlr.TerminalNode

	// IsInitializerContext differentiates from other interfaces.
	IsInitializerContext()
}

type InitializerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitializerContext() *InitializerContext {
	var p = new(InitializerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_initializer
	return p
}

func InitEmptyInitializerContext(p *InitializerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_initializer
}

func (*InitializerContext) IsInitializerContext() {}

func NewInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitializerContext {
	var p = new(InitializerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_initializer

	return p
}

func (s *InitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *InitializerContext) BraceOrEqualInitializer() IBraceOrEqualInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBraceOrEqualInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBraceOrEqualInitializerContext)
}

func (s *InitializerContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CPP14ParserLeftParen, 0)
}

func (s *InitializerContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *InitializerContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CPP14ParserRightParen, 0)
}

func (s *InitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterInitializer(s)
	}
}

func (s *InitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitInitializer(s)
	}
}

func (s *InitializerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitInitializer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) Initializer() (localctx IInitializerContext) {
	localctx = NewInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, CPP14ParserRULE_initializer)
	p.SetState(1612)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CPP14ParserLeftBrace, CPP14ParserAssign:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1607)
			p.BraceOrEqualInitializer()
		}

	case CPP14ParserLeftParen:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1608)
			p.Match(CPP14ParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1609)
			p.ExpressionList()
		}
		{
			p.SetState(1610)
			p.Match(CPP14ParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBraceOrEqualInitializerContext is an interface to support dynamic dispatch.
type IBraceOrEqualInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Assign() antlr.TerminalNode
	InitializerClause() IInitializerClauseContext
	BracedInitList() IBracedInitListContext

	// IsBraceOrEqualInitializerContext differentiates from other interfaces.
	IsBraceOrEqualInitializerContext()
}

type BraceOrEqualInitializerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBraceOrEqualInitializerContext() *BraceOrEqualInitializerContext {
	var p = new(BraceOrEqualInitializerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_braceOrEqualInitializer
	return p
}

func InitEmptyBraceOrEqualInitializerContext(p *BraceOrEqualInitializerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_braceOrEqualInitializer
}

func (*BraceOrEqualInitializerContext) IsBraceOrEqualInitializerContext() {}

func NewBraceOrEqualInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BraceOrEqualInitializerContext {
	var p = new(BraceOrEqualInitializerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_braceOrEqualInitializer

	return p
}

func (s *BraceOrEqualInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *BraceOrEqualInitializerContext) Assign() antlr.TerminalNode {
	return s.GetToken(CPP14ParserAssign, 0)
}

func (s *BraceOrEqualInitializerContext) InitializerClause() IInitializerClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitializerClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitializerClauseContext)
}

func (s *BraceOrEqualInitializerContext) BracedInitList() IBracedInitListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBracedInitListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBracedInitListContext)
}

func (s *BraceOrEqualInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BraceOrEqualInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BraceOrEqualInitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterBraceOrEqualInitializer(s)
	}
}

func (s *BraceOrEqualInitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitBraceOrEqualInitializer(s)
	}
}

func (s *BraceOrEqualInitializerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitBraceOrEqualInitializer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) BraceOrEqualInitializer() (localctx IBraceOrEqualInitializerContext) {
	localctx = NewBraceOrEqualInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, CPP14ParserRULE_braceOrEqualInitializer)
	p.SetState(1617)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CPP14ParserAssign:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1614)
			p.Match(CPP14ParserAssign)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1615)
			p.InitializerClause()
		}

	case CPP14ParserLeftBrace:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1616)
			p.BracedInitList()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInitializerClauseContext is an interface to support dynamic dispatch.
type IInitializerClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AssignmentExpression() IAssignmentExpressionContext
	BracedInitList() IBracedInitListContext

	// IsInitializerClauseContext differentiates from other interfaces.
	IsInitializerClauseContext()
}

type InitializerClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitializerClauseContext() *InitializerClauseContext {
	var p = new(InitializerClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_initializerClause
	return p
}

func InitEmptyInitializerClauseContext(p *InitializerClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_initializerClause
}

func (*InitializerClauseContext) IsInitializerClauseContext() {}

func NewInitializerClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitializerClauseContext {
	var p = new(InitializerClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_initializerClause

	return p
}

func (s *InitializerClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *InitializerClauseContext) AssignmentExpression() IAssignmentExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentExpressionContext)
}

func (s *InitializerClauseContext) BracedInitList() IBracedInitListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBracedInitListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBracedInitListContext)
}

func (s *InitializerClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitializerClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitializerClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterInitializerClause(s)
	}
}

func (s *InitializerClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitInitializerClause(s)
	}
}

func (s *InitializerClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitInitializerClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) InitializerClause() (localctx IInitializerClauseContext) {
	localctx = NewInitializerClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, CPP14ParserRULE_initializerClause)
	p.SetState(1621)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CPP14ParserIntegerLiteral, CPP14ParserCharacterLiteral, CPP14ParserFloatingLiteral, CPP14ParserStringLiteral, CPP14ParserBooleanLiteral, CPP14ParserPointerLiteral, CPP14ParserUserDefinedLiteral, CPP14ParserAlignof, CPP14ParserAuto, CPP14ParserBool, CPP14ParserChar, CPP14ParserChar16, CPP14ParserChar32, CPP14ParserConst_cast, CPP14ParserDecltype, CPP14ParserDelete, CPP14ParserDouble, CPP14ParserDynamic_cast, CPP14ParserFloat, CPP14ParserInt, CPP14ParserLong, CPP14ParserNew, CPP14ParserNoexcept, CPP14ParserOperator, CPP14ParserReinterpret_cast, CPP14ParserShort, CPP14ParserSigned, CPP14ParserSizeof, CPP14ParserStatic_cast, CPP14ParserThis, CPP14ParserThrow, CPP14ParserTypeid_, CPP14ParserTypename_, CPP14ParserUnsigned, CPP14ParserVoid, CPP14ParserWchar, CPP14ParserLeftParen, CPP14ParserLeftBracket, CPP14ParserPlus, CPP14ParserMinus, CPP14ParserStar, CPP14ParserAnd, CPP14ParserOr, CPP14ParserTilde, CPP14ParserNot, CPP14ParserPlusPlus, CPP14ParserMinusMinus, CPP14ParserDoublecolon, CPP14ParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1619)
			p.AssignmentExpression()
		}

	case CPP14ParserLeftBrace:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1620)
			p.BracedInitList()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInitializerListContext is an interface to support dynamic dispatch.
type IInitializerListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllInitializerClause() []IInitializerClauseContext
	InitializerClause(i int) IInitializerClauseContext
	AllEllipsis() []antlr.TerminalNode
	Ellipsis(i int) antlr.TerminalNode
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsInitializerListContext differentiates from other interfaces.
	IsInitializerListContext()
}

type InitializerListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitializerListContext() *InitializerListContext {
	var p = new(InitializerListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_initializerList
	return p
}

func InitEmptyInitializerListContext(p *InitializerListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_initializerList
}

func (*InitializerListContext) IsInitializerListContext() {}

func NewInitializerListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitializerListContext {
	var p = new(InitializerListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_initializerList

	return p
}

func (s *InitializerListContext) GetParser() antlr.Parser { return s.parser }

func (s *InitializerListContext) AllInitializerClause() []IInitializerClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInitializerClauseContext); ok {
			len++
		}
	}

	tst := make([]IInitializerClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInitializerClauseContext); ok {
			tst[i] = t.(IInitializerClauseContext)
			i++
		}
	}

	return tst
}

func (s *InitializerListContext) InitializerClause(i int) IInitializerClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitializerClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitializerClauseContext)
}

func (s *InitializerListContext) AllEllipsis() []antlr.TerminalNode {
	return s.GetTokens(CPP14ParserEllipsis)
}

func (s *InitializerListContext) Ellipsis(i int) antlr.TerminalNode {
	return s.GetToken(CPP14ParserEllipsis, i)
}

func (s *InitializerListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(CPP14ParserComma)
}

func (s *InitializerListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(CPP14ParserComma, i)
}

func (s *InitializerListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitializerListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitializerListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterInitializerList(s)
	}
}

func (s *InitializerListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitInitializerList(s)
	}
}

func (s *InitializerListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitInitializerList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) InitializerList() (localctx IInitializerListContext) {
	localctx = NewInitializerListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, CPP14ParserRULE_initializerList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1623)
		p.InitializerClause()
	}
	p.SetState(1625)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CPP14ParserEllipsis {
		{
			p.SetState(1624)
			p.Match(CPP14ParserEllipsis)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1634)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 216, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1627)
				p.Match(CPP14ParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1628)
				p.InitializerClause()
			}
			p.SetState(1630)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == CPP14ParserEllipsis {
				{
					p.SetState(1629)
					p.Match(CPP14ParserEllipsis)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		}
		p.SetState(1636)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 216, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBracedInitListContext is an interface to support dynamic dispatch.
type IBracedInitListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LeftBrace() antlr.TerminalNode
	RightBrace() antlr.TerminalNode
	InitializerList() IInitializerListContext
	Comma() antlr.TerminalNode

	// IsBracedInitListContext differentiates from other interfaces.
	IsBracedInitListContext()
}

type BracedInitListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBracedInitListContext() *BracedInitListContext {
	var p = new(BracedInitListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_bracedInitList
	return p
}

func InitEmptyBracedInitListContext(p *BracedInitListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_bracedInitList
}

func (*BracedInitListContext) IsBracedInitListContext() {}

func NewBracedInitListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BracedInitListContext {
	var p = new(BracedInitListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_bracedInitList

	return p
}

func (s *BracedInitListContext) GetParser() antlr.Parser { return s.parser }

func (s *BracedInitListContext) LeftBrace() antlr.TerminalNode {
	return s.GetToken(CPP14ParserLeftBrace, 0)
}

func (s *BracedInitListContext) RightBrace() antlr.TerminalNode {
	return s.GetToken(CPP14ParserRightBrace, 0)
}

func (s *BracedInitListContext) InitializerList() IInitializerListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitializerListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitializerListContext)
}

func (s *BracedInitListContext) Comma() antlr.TerminalNode {
	return s.GetToken(CPP14ParserComma, 0)
}

func (s *BracedInitListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BracedInitListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BracedInitListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterBracedInitList(s)
	}
}

func (s *BracedInitListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitBracedInitList(s)
	}
}

func (s *BracedInitListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitBracedInitList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) BracedInitList() (localctx IBracedInitListContext) {
	localctx = NewBracedInitListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, CPP14ParserRULE_bracedInitList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1637)
		p.Match(CPP14ParserLeftBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1642)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8364979464334764286) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&4719772474400910417) != 0) || _la == CPP14ParserIdentifier {
		{
			p.SetState(1638)
			p.InitializerList()
		}
		p.SetState(1640)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CPP14ParserComma {
			{
				p.SetState(1639)
				p.Match(CPP14ParserComma)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}
	{
		p.SetState(1644)
		p.Match(CPP14ParserRightBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassNameContext is an interface to support dynamic dispatch.
type IClassNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode
	SimpleTemplateId() ISimpleTemplateIdContext

	// IsClassNameContext differentiates from other interfaces.
	IsClassNameContext()
}

type ClassNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassNameContext() *ClassNameContext {
	var p = new(ClassNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_className
	return p
}

func InitEmptyClassNameContext(p *ClassNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_className
}

func (*ClassNameContext) IsClassNameContext() {}

func NewClassNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassNameContext {
	var p = new(ClassNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_className

	return p
}

func (s *ClassNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassNameContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CPP14ParserIdentifier, 0)
}

func (s *ClassNameContext) SimpleTemplateId() ISimpleTemplateIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleTemplateIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleTemplateIdContext)
}

func (s *ClassNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterClassName(s)
	}
}

func (s *ClassNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitClassName(s)
	}
}

func (s *ClassNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitClassName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) ClassName() (localctx IClassNameContext) {
	localctx = NewClassNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, CPP14ParserRULE_className)
	p.SetState(1648)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 219, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1646)
			p.Match(CPP14ParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1647)
			p.SimpleTemplateId()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassSpecifierContext is an interface to support dynamic dispatch.
type IClassSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ClassHead() IClassHeadContext
	LeftBrace() antlr.TerminalNode
	RightBrace() antlr.TerminalNode
	MemberSpecification() IMemberSpecificationContext

	// IsClassSpecifierContext differentiates from other interfaces.
	IsClassSpecifierContext()
}

type ClassSpecifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassSpecifierContext() *ClassSpecifierContext {
	var p = new(ClassSpecifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_classSpecifier
	return p
}

func InitEmptyClassSpecifierContext(p *ClassSpecifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_classSpecifier
}

func (*ClassSpecifierContext) IsClassSpecifierContext() {}

func NewClassSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassSpecifierContext {
	var p = new(ClassSpecifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_classSpecifier

	return p
}

func (s *ClassSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassSpecifierContext) ClassHead() IClassHeadContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassHeadContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassHeadContext)
}

func (s *ClassSpecifierContext) LeftBrace() antlr.TerminalNode {
	return s.GetToken(CPP14ParserLeftBrace, 0)
}

func (s *ClassSpecifierContext) RightBrace() antlr.TerminalNode {
	return s.GetToken(CPP14ParserRightBrace, 0)
}

func (s *ClassSpecifierContext) MemberSpecification() IMemberSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMemberSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMemberSpecificationContext)
}

func (s *ClassSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterClassSpecifier(s)
	}
}

func (s *ClassSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitClassSpecifier(s)
	}
}

func (s *ClassSpecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitClassSpecifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) ClassSpecifier() (localctx IClassSpecifierContext) {
	localctx = NewClassSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, CPP14ParserRULE_classSpecifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1650)
		p.ClassHead()
	}
	{
		p.SetState(1651)
		p.Match(CPP14ParserLeftBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1653)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64((_la-10)) & ^0x3f) == 0 && ((int64(1)<<(_la-10))&1543877313594212121) != 0) || ((int64((_la-74)) & ^0x3f) == 0 && ((int64(1)<<(_la-74))&463888353847684093) != 0) {
		{
			p.SetState(1652)
			p.MemberSpecification()
		}

	}
	{
		p.SetState(1655)
		p.Match(CPP14ParserRightBrace)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassHeadContext is an interface to support dynamic dispatch.
type IClassHeadContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ClassKey() IClassKeyContext
	AttributeSpecifierSeq() IAttributeSpecifierSeqContext
	ClassHeadName() IClassHeadNameContext
	BaseClause() IBaseClauseContext
	ClassVirtSpecifier() IClassVirtSpecifierContext
	Union() antlr.TerminalNode

	// IsClassHeadContext differentiates from other interfaces.
	IsClassHeadContext()
}

type ClassHeadContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassHeadContext() *ClassHeadContext {
	var p = new(ClassHeadContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_classHead
	return p
}

func InitEmptyClassHeadContext(p *ClassHeadContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_classHead
}

func (*ClassHeadContext) IsClassHeadContext() {}

func NewClassHeadContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassHeadContext {
	var p = new(ClassHeadContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_classHead

	return p
}

func (s *ClassHeadContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassHeadContext) ClassKey() IClassKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassKeyContext)
}

func (s *ClassHeadContext) AttributeSpecifierSeq() IAttributeSpecifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSpecifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSpecifierSeqContext)
}

func (s *ClassHeadContext) ClassHeadName() IClassHeadNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassHeadNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassHeadNameContext)
}

func (s *ClassHeadContext) BaseClause() IBaseClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseClauseContext)
}

func (s *ClassHeadContext) ClassVirtSpecifier() IClassVirtSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassVirtSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassVirtSpecifierContext)
}

func (s *ClassHeadContext) Union() antlr.TerminalNode {
	return s.GetToken(CPP14ParserUnion, 0)
}

func (s *ClassHeadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassHeadContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassHeadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterClassHead(s)
	}
}

func (s *ClassHeadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitClassHead(s)
	}
}

func (s *ClassHeadContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitClassHead(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) ClassHead() (localctx IClassHeadContext) {
	localctx = NewClassHeadContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, CPP14ParserRULE_classHead)
	var _la int

	p.SetState(1680)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CPP14ParserClass, CPP14ParserStruct:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1657)
			p.ClassKey()
		}
		p.SetState(1659)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CPP14ParserAlignas || _la == CPP14ParserLeftBracket {
			{
				p.SetState(1658)
				p.AttributeSpecifierSeq()
			}

		}
		p.SetState(1665)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CPP14ParserDecltype || _la == CPP14ParserDoublecolon || _la == CPP14ParserIdentifier {
			{
				p.SetState(1661)
				p.ClassHeadName()
			}
			p.SetState(1663)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == CPP14ParserFinal {
				{
					p.SetState(1662)
					p.ClassVirtSpecifier()
				}

			}

		}
		p.SetState(1668)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CPP14ParserColon {
			{
				p.SetState(1667)
				p.BaseClause()
			}

		}

	case CPP14ParserUnion:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1670)
			p.Match(CPP14ParserUnion)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1672)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CPP14ParserAlignas || _la == CPP14ParserLeftBracket {
			{
				p.SetState(1671)
				p.AttributeSpecifierSeq()
			}

		}
		p.SetState(1678)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CPP14ParserDecltype || _la == CPP14ParserDoublecolon || _la == CPP14ParserIdentifier {
			{
				p.SetState(1674)
				p.ClassHeadName()
			}
			p.SetState(1676)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == CPP14ParserFinal {
				{
					p.SetState(1675)
					p.ClassVirtSpecifier()
				}

			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassHeadNameContext is an interface to support dynamic dispatch.
type IClassHeadNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ClassName() IClassNameContext
	NestedNameSpecifier() INestedNameSpecifierContext

	// IsClassHeadNameContext differentiates from other interfaces.
	IsClassHeadNameContext()
}

type ClassHeadNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassHeadNameContext() *ClassHeadNameContext {
	var p = new(ClassHeadNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_classHeadName
	return p
}

func InitEmptyClassHeadNameContext(p *ClassHeadNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_classHeadName
}

func (*ClassHeadNameContext) IsClassHeadNameContext() {}

func NewClassHeadNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassHeadNameContext {
	var p = new(ClassHeadNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_classHeadName

	return p
}

func (s *ClassHeadNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassHeadNameContext) ClassName() IClassNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassNameContext)
}

func (s *ClassHeadNameContext) NestedNameSpecifier() INestedNameSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedNameSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedNameSpecifierContext)
}

func (s *ClassHeadNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassHeadNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassHeadNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterClassHeadName(s)
	}
}

func (s *ClassHeadNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitClassHeadName(s)
	}
}

func (s *ClassHeadNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitClassHeadName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) ClassHeadName() (localctx IClassHeadNameContext) {
	localctx = NewClassHeadNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, CPP14ParserRULE_classHeadName)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(1683)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 229, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1682)
			p.nestedNameSpecifier(0)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1685)
		p.ClassName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassVirtSpecifierContext is an interface to support dynamic dispatch.
type IClassVirtSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Final() antlr.TerminalNode

	// IsClassVirtSpecifierContext differentiates from other interfaces.
	IsClassVirtSpecifierContext()
}

type ClassVirtSpecifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassVirtSpecifierContext() *ClassVirtSpecifierContext {
	var p = new(ClassVirtSpecifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_classVirtSpecifier
	return p
}

func InitEmptyClassVirtSpecifierContext(p *ClassVirtSpecifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_classVirtSpecifier
}

func (*ClassVirtSpecifierContext) IsClassVirtSpecifierContext() {}

func NewClassVirtSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassVirtSpecifierContext {
	var p = new(ClassVirtSpecifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_classVirtSpecifier

	return p
}

func (s *ClassVirtSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassVirtSpecifierContext) Final() antlr.TerminalNode {
	return s.GetToken(CPP14ParserFinal, 0)
}

func (s *ClassVirtSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassVirtSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassVirtSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterClassVirtSpecifier(s)
	}
}

func (s *ClassVirtSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitClassVirtSpecifier(s)
	}
}

func (s *ClassVirtSpecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitClassVirtSpecifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) ClassVirtSpecifier() (localctx IClassVirtSpecifierContext) {
	localctx = NewClassVirtSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, CPP14ParserRULE_classVirtSpecifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1687)
		p.Match(CPP14ParserFinal)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassKeyContext is an interface to support dynamic dispatch.
type IClassKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Class() antlr.TerminalNode
	Struct() antlr.TerminalNode

	// IsClassKeyContext differentiates from other interfaces.
	IsClassKeyContext()
}

type ClassKeyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassKeyContext() *ClassKeyContext {
	var p = new(ClassKeyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_classKey
	return p
}

func InitEmptyClassKeyContext(p *ClassKeyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_classKey
}

func (*ClassKeyContext) IsClassKeyContext() {}

func NewClassKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassKeyContext {
	var p = new(ClassKeyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_classKey

	return p
}

func (s *ClassKeyContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassKeyContext) Class() antlr.TerminalNode {
	return s.GetToken(CPP14ParserClass, 0)
}

func (s *ClassKeyContext) Struct() antlr.TerminalNode {
	return s.GetToken(CPP14ParserStruct, 0)
}

func (s *ClassKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassKeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterClassKey(s)
	}
}

func (s *ClassKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitClassKey(s)
	}
}

func (s *ClassKeyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitClassKey(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) ClassKey() (localctx IClassKeyContext) {
	localctx = NewClassKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, CPP14ParserRULE_classKey)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1689)
		_la = p.GetTokenStream().LA(1)

		if !(_la == CPP14ParserClass || _la == CPP14ParserStruct) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMemberSpecificationContext is an interface to support dynamic dispatch.
type IMemberSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMemberdeclaration() []IMemberdeclarationContext
	Memberdeclaration(i int) IMemberdeclarationContext
	AllAccessSpecifier() []IAccessSpecifierContext
	AccessSpecifier(i int) IAccessSpecifierContext
	AllColon() []antlr.TerminalNode
	Colon(i int) antlr.TerminalNode

	// IsMemberSpecificationContext differentiates from other interfaces.
	IsMemberSpecificationContext()
}

type MemberSpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMemberSpecificationContext() *MemberSpecificationContext {
	var p = new(MemberSpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_memberSpecification
	return p
}

func InitEmptyMemberSpecificationContext(p *MemberSpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_memberSpecification
}

func (*MemberSpecificationContext) IsMemberSpecificationContext() {}

func NewMemberSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MemberSpecificationContext {
	var p = new(MemberSpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_memberSpecification

	return p
}

func (s *MemberSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *MemberSpecificationContext) AllMemberdeclaration() []IMemberdeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMemberdeclarationContext); ok {
			len++
		}
	}

	tst := make([]IMemberdeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMemberdeclarationContext); ok {
			tst[i] = t.(IMemberdeclarationContext)
			i++
		}
	}

	return tst
}

func (s *MemberSpecificationContext) Memberdeclaration(i int) IMemberdeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMemberdeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMemberdeclarationContext)
}

func (s *MemberSpecificationContext) AllAccessSpecifier() []IAccessSpecifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAccessSpecifierContext); ok {
			len++
		}
	}

	tst := make([]IAccessSpecifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAccessSpecifierContext); ok {
			tst[i] = t.(IAccessSpecifierContext)
			i++
		}
	}

	return tst
}

func (s *MemberSpecificationContext) AccessSpecifier(i int) IAccessSpecifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessSpecifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessSpecifierContext)
}

func (s *MemberSpecificationContext) AllColon() []antlr.TerminalNode {
	return s.GetTokens(CPP14ParserColon)
}

func (s *MemberSpecificationContext) Colon(i int) antlr.TerminalNode {
	return s.GetToken(CPP14ParserColon, i)
}

func (s *MemberSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MemberSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterMemberSpecification(s)
	}
}

func (s *MemberSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitMemberSpecification(s)
	}
}

func (s *MemberSpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitMemberSpecification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) MemberSpecification() (localctx IMemberSpecificationContext) {
	localctx = NewMemberSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, CPP14ParserRULE_memberSpecification)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1695)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64((_la-10)) & ^0x3f) == 0 && ((int64(1)<<(_la-10))&1543877313594212121) != 0) || ((int64((_la-74)) & ^0x3f) == 0 && ((int64(1)<<(_la-74))&463888353847684093) != 0) {
		p.SetState(1695)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case CPP14ParserAlignas, CPP14ParserAuto, CPP14ParserBool, CPP14ParserChar, CPP14ParserChar16, CPP14ParserChar32, CPP14ParserClass, CPP14ParserConst, CPP14ParserConstexpr, CPP14ParserDecltype, CPP14ParserDouble, CPP14ParserEnum, CPP14ParserExplicit, CPP14ParserExtern, CPP14ParserFloat, CPP14ParserFriend, CPP14ParserInline, CPP14ParserInt, CPP14ParserLong, CPP14ParserMutable, CPP14ParserOperator, CPP14ParserRegister, CPP14ParserShort, CPP14ParserSigned, CPP14ParserStatic, CPP14ParserStatic_assert, CPP14ParserStruct, CPP14ParserTemplate, CPP14ParserThread_local, CPP14ParserTypedef, CPP14ParserTypename_, CPP14ParserUnion, CPP14ParserUnsigned, CPP14ParserUsing, CPP14ParserVirtual, CPP14ParserVoid, CPP14ParserVolatile, CPP14ParserWchar, CPP14ParserLeftParen, CPP14ParserLeftBracket, CPP14ParserStar, CPP14ParserAnd, CPP14ParserTilde, CPP14ParserAndAnd, CPP14ParserColon, CPP14ParserDoublecolon, CPP14ParserSemi, CPP14ParserEllipsis, CPP14ParserIdentifier:
			{
				p.SetState(1691)
				p.Memberdeclaration()
			}

		case CPP14ParserPrivate, CPP14ParserProtected, CPP14ParserPublic:
			{
				p.SetState(1692)
				p.AccessSpecifier()
			}
			{
				p.SetState(1693)
				p.Match(CPP14ParserColon)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(1697)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMemberdeclarationContext is an interface to support dynamic dispatch.
type IMemberdeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Semi() antlr.TerminalNode
	AttributeSpecifierSeq() IAttributeSpecifierSeqContext
	DeclSpecifierSeq() IDeclSpecifierSeqContext
	MemberDeclaratorList() IMemberDeclaratorListContext
	FunctionDefinition() IFunctionDefinitionContext
	UsingDeclaration() IUsingDeclarationContext
	StaticAssertDeclaration() IStaticAssertDeclarationContext
	TemplateDeclaration() ITemplateDeclarationContext
	AliasDeclaration() IAliasDeclarationContext
	EmptyDeclaration_() IEmptyDeclaration_Context

	// IsMemberdeclarationContext differentiates from other interfaces.
	IsMemberdeclarationContext()
}

type MemberdeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMemberdeclarationContext() *MemberdeclarationContext {
	var p = new(MemberdeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_memberdeclaration
	return p
}

func InitEmptyMemberdeclarationContext(p *MemberdeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_memberdeclaration
}

func (*MemberdeclarationContext) IsMemberdeclarationContext() {}

func NewMemberdeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MemberdeclarationContext {
	var p = new(MemberdeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_memberdeclaration

	return p
}

func (s *MemberdeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *MemberdeclarationContext) Semi() antlr.TerminalNode {
	return s.GetToken(CPP14ParserSemi, 0)
}

func (s *MemberdeclarationContext) AttributeSpecifierSeq() IAttributeSpecifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSpecifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSpecifierSeqContext)
}

func (s *MemberdeclarationContext) DeclSpecifierSeq() IDeclSpecifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclSpecifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclSpecifierSeqContext)
}

func (s *MemberdeclarationContext) MemberDeclaratorList() IMemberDeclaratorListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMemberDeclaratorListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMemberDeclaratorListContext)
}

func (s *MemberdeclarationContext) FunctionDefinition() IFunctionDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDefinitionContext)
}

func (s *MemberdeclarationContext) UsingDeclaration() IUsingDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsingDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsingDeclarationContext)
}

func (s *MemberdeclarationContext) StaticAssertDeclaration() IStaticAssertDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStaticAssertDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStaticAssertDeclarationContext)
}

func (s *MemberdeclarationContext) TemplateDeclaration() ITemplateDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITemplateDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITemplateDeclarationContext)
}

func (s *MemberdeclarationContext) AliasDeclaration() IAliasDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasDeclarationContext)
}

func (s *MemberdeclarationContext) EmptyDeclaration_() IEmptyDeclaration_Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyDeclaration_Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyDeclaration_Context)
}

func (s *MemberdeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberdeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MemberdeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterMemberdeclaration(s)
	}
}

func (s *MemberdeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitMemberdeclaration(s)
	}
}

func (s *MemberdeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitMemberdeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) Memberdeclaration() (localctx IMemberdeclarationContext) {
	localctx = NewMemberdeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, CPP14ParserRULE_memberdeclaration)
	var _la int

	p.SetState(1715)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 235, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1700)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 232, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1699)
				p.AttributeSpecifierSeq()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1703)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 233, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1702)
				p.DeclSpecifierSeq()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1706)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4503599694480384) != 0) || ((int64((_la-85)) & ^0x3f) == 0 && ((int64(1)<<(_la-85))&217711892254981) != 0) {
			{
				p.SetState(1705)
				p.MemberDeclaratorList()
			}

		}
		{
			p.SetState(1708)
			p.Match(CPP14ParserSemi)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1709)
			p.FunctionDefinition()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1710)
			p.UsingDeclaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1711)
			p.StaticAssertDeclaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1712)
			p.TemplateDeclaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1713)
			p.AliasDeclaration()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1714)
			p.EmptyDeclaration_()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMemberDeclaratorListContext is an interface to support dynamic dispatch.
type IMemberDeclaratorListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMemberDeclarator() []IMemberDeclaratorContext
	MemberDeclarator(i int) IMemberDeclaratorContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsMemberDeclaratorListContext differentiates from other interfaces.
	IsMemberDeclaratorListContext()
}

type MemberDeclaratorListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMemberDeclaratorListContext() *MemberDeclaratorListContext {
	var p = new(MemberDeclaratorListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_memberDeclaratorList
	return p
}

func InitEmptyMemberDeclaratorListContext(p *MemberDeclaratorListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_memberDeclaratorList
}

func (*MemberDeclaratorListContext) IsMemberDeclaratorListContext() {}

func NewMemberDeclaratorListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MemberDeclaratorListContext {
	var p = new(MemberDeclaratorListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_memberDeclaratorList

	return p
}

func (s *MemberDeclaratorListContext) GetParser() antlr.Parser { return s.parser }

func (s *MemberDeclaratorListContext) AllMemberDeclarator() []IMemberDeclaratorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMemberDeclaratorContext); ok {
			len++
		}
	}

	tst := make([]IMemberDeclaratorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMemberDeclaratorContext); ok {
			tst[i] = t.(IMemberDeclaratorContext)
			i++
		}
	}

	return tst
}

func (s *MemberDeclaratorListContext) MemberDeclarator(i int) IMemberDeclaratorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMemberDeclaratorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMemberDeclaratorContext)
}

func (s *MemberDeclaratorListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(CPP14ParserComma)
}

func (s *MemberDeclaratorListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(CPP14ParserComma, i)
}

func (s *MemberDeclaratorListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberDeclaratorListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MemberDeclaratorListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterMemberDeclaratorList(s)
	}
}

func (s *MemberDeclaratorListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitMemberDeclaratorList(s)
	}
}

func (s *MemberDeclaratorListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitMemberDeclaratorList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) MemberDeclaratorList() (localctx IMemberDeclaratorListContext) {
	localctx = NewMemberDeclaratorListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, CPP14ParserRULE_memberDeclaratorList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1717)
		p.MemberDeclarator()
	}
	p.SetState(1722)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CPP14ParserComma {
		{
			p.SetState(1718)
			p.Match(CPP14ParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1719)
			p.MemberDeclarator()
		}

		p.SetState(1724)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMemberDeclaratorContext is an interface to support dynamic dispatch.
type IMemberDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Declarator() IDeclaratorContext
	VirtualSpecifierSeq() IVirtualSpecifierSeqContext
	PureSpecifier() IPureSpecifierContext
	BraceOrEqualInitializer() IBraceOrEqualInitializerContext
	Colon() antlr.TerminalNode
	ConstantExpression() IConstantExpressionContext
	Identifier() antlr.TerminalNode
	AttributeSpecifierSeq() IAttributeSpecifierSeqContext

	// IsMemberDeclaratorContext differentiates from other interfaces.
	IsMemberDeclaratorContext()
}

type MemberDeclaratorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMemberDeclaratorContext() *MemberDeclaratorContext {
	var p = new(MemberDeclaratorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_memberDeclarator
	return p
}

func InitEmptyMemberDeclaratorContext(p *MemberDeclaratorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_memberDeclarator
}

func (*MemberDeclaratorContext) IsMemberDeclaratorContext() {}

func NewMemberDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MemberDeclaratorContext {
	var p = new(MemberDeclaratorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_memberDeclarator

	return p
}

func (s *MemberDeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *MemberDeclaratorContext) Declarator() IDeclaratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclaratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclaratorContext)
}

func (s *MemberDeclaratorContext) VirtualSpecifierSeq() IVirtualSpecifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVirtualSpecifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVirtualSpecifierSeqContext)
}

func (s *MemberDeclaratorContext) PureSpecifier() IPureSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPureSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPureSpecifierContext)
}

func (s *MemberDeclaratorContext) BraceOrEqualInitializer() IBraceOrEqualInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBraceOrEqualInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBraceOrEqualInitializerContext)
}

func (s *MemberDeclaratorContext) Colon() antlr.TerminalNode {
	return s.GetToken(CPP14ParserColon, 0)
}

func (s *MemberDeclaratorContext) ConstantExpression() IConstantExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantExpressionContext)
}

func (s *MemberDeclaratorContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CPP14ParserIdentifier, 0)
}

func (s *MemberDeclaratorContext) AttributeSpecifierSeq() IAttributeSpecifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSpecifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSpecifierSeqContext)
}

func (s *MemberDeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberDeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MemberDeclaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterMemberDeclarator(s)
	}
}

func (s *MemberDeclaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitMemberDeclarator(s)
	}
}

func (s *MemberDeclaratorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitMemberDeclarator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) MemberDeclarator() (localctx IMemberDeclaratorContext) {
	localctx = NewMemberDeclaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, CPP14ParserRULE_memberDeclarator)
	var _la int

	p.SetState(1745)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 240, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1725)
			p.Declarator()
		}
		p.SetState(1734)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 237, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1726)
				p.VirtualSpecifierSeq()
			}

		case 2:
			p.SetState(1727)

			if !(p.IsPureSpecifierAllowed()) {
				p.SetError(antlr.NewFailedPredicateException(p, " p.IsPureSpecifierAllowed() ", ""))
				goto errorExit
			}
			{
				p.SetState(1728)
				p.PureSpecifier()
			}

		case 3:
			p.SetState(1729)

			if !(p.IsPureSpecifierAllowed()) {
				p.SetError(antlr.NewFailedPredicateException(p, " p.IsPureSpecifierAllowed() ", ""))
				goto errorExit
			}
			{
				p.SetState(1730)
				p.VirtualSpecifierSeq()
			}
			{
				p.SetState(1731)
				p.PureSpecifier()
			}

		case 4:
			{
				p.SetState(1733)
				p.BraceOrEqualInitializer()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1736)
			p.Declarator()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(1738)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CPP14ParserIdentifier {
			{
				p.SetState(1737)
				p.Match(CPP14ParserIdentifier)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1741)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CPP14ParserAlignas || _la == CPP14ParserLeftBracket {
			{
				p.SetState(1740)
				p.AttributeSpecifierSeq()
			}

		}
		{
			p.SetState(1743)
			p.Match(CPP14ParserColon)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1744)
			p.ConstantExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVirtualSpecifierSeqContext is an interface to support dynamic dispatch.
type IVirtualSpecifierSeqContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllVirtualSpecifier() []IVirtualSpecifierContext
	VirtualSpecifier(i int) IVirtualSpecifierContext

	// IsVirtualSpecifierSeqContext differentiates from other interfaces.
	IsVirtualSpecifierSeqContext()
}

type VirtualSpecifierSeqContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVirtualSpecifierSeqContext() *VirtualSpecifierSeqContext {
	var p = new(VirtualSpecifierSeqContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_virtualSpecifierSeq
	return p
}

func InitEmptyVirtualSpecifierSeqContext(p *VirtualSpecifierSeqContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_virtualSpecifierSeq
}

func (*VirtualSpecifierSeqContext) IsVirtualSpecifierSeqContext() {}

func NewVirtualSpecifierSeqContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VirtualSpecifierSeqContext {
	var p = new(VirtualSpecifierSeqContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_virtualSpecifierSeq

	return p
}

func (s *VirtualSpecifierSeqContext) GetParser() antlr.Parser { return s.parser }

func (s *VirtualSpecifierSeqContext) AllVirtualSpecifier() []IVirtualSpecifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVirtualSpecifierContext); ok {
			len++
		}
	}

	tst := make([]IVirtualSpecifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVirtualSpecifierContext); ok {
			tst[i] = t.(IVirtualSpecifierContext)
			i++
		}
	}

	return tst
}

func (s *VirtualSpecifierSeqContext) VirtualSpecifier(i int) IVirtualSpecifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVirtualSpecifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVirtualSpecifierContext)
}

func (s *VirtualSpecifierSeqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VirtualSpecifierSeqContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VirtualSpecifierSeqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterVirtualSpecifierSeq(s)
	}
}

func (s *VirtualSpecifierSeqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitVirtualSpecifierSeq(s)
	}
}

func (s *VirtualSpecifierSeqContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitVirtualSpecifierSeq(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) VirtualSpecifierSeq() (localctx IVirtualSpecifierSeqContext) {
	localctx = NewVirtualSpecifierSeqContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, CPP14ParserRULE_virtualSpecifierSeq)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1748)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == CPP14ParserFinal || _la == CPP14ParserOverride {
		{
			p.SetState(1747)
			p.VirtualSpecifier()
		}

		p.SetState(1750)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVirtualSpecifierContext is an interface to support dynamic dispatch.
type IVirtualSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Override() antlr.TerminalNode
	Final() antlr.TerminalNode

	// IsVirtualSpecifierContext differentiates from other interfaces.
	IsVirtualSpecifierContext()
}

type VirtualSpecifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVirtualSpecifierContext() *VirtualSpecifierContext {
	var p = new(VirtualSpecifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_virtualSpecifier
	return p
}

func InitEmptyVirtualSpecifierContext(p *VirtualSpecifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_virtualSpecifier
}

func (*VirtualSpecifierContext) IsVirtualSpecifierContext() {}

func NewVirtualSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VirtualSpecifierContext {
	var p = new(VirtualSpecifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_virtualSpecifier

	return p
}

func (s *VirtualSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *VirtualSpecifierContext) Override() antlr.TerminalNode {
	return s.GetToken(CPP14ParserOverride, 0)
}

func (s *VirtualSpecifierContext) Final() antlr.TerminalNode {
	return s.GetToken(CPP14ParserFinal, 0)
}

func (s *VirtualSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VirtualSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VirtualSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterVirtualSpecifier(s)
	}
}

func (s *VirtualSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitVirtualSpecifier(s)
	}
}

func (s *VirtualSpecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitVirtualSpecifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) VirtualSpecifier() (localctx IVirtualSpecifierContext) {
	localctx = NewVirtualSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, CPP14ParserRULE_virtualSpecifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1752)
		_la = p.GetTokenStream().LA(1)

		if !(_la == CPP14ParserFinal || _la == CPP14ParserOverride) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPureSpecifierContext is an interface to support dynamic dispatch.
type IPureSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Assign() antlr.TerminalNode
	IntegerLiteral() antlr.TerminalNode

	// IsPureSpecifierContext differentiates from other interfaces.
	IsPureSpecifierContext()
}

type PureSpecifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPureSpecifierContext() *PureSpecifierContext {
	var p = new(PureSpecifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_pureSpecifier
	return p
}

func InitEmptyPureSpecifierContext(p *PureSpecifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_pureSpecifier
}

func (*PureSpecifierContext) IsPureSpecifierContext() {}

func NewPureSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PureSpecifierContext {
	var p = new(PureSpecifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_pureSpecifier

	return p
}

func (s *PureSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *PureSpecifierContext) Assign() antlr.TerminalNode {
	return s.GetToken(CPP14ParserAssign, 0)
}

func (s *PureSpecifierContext) IntegerLiteral() antlr.TerminalNode {
	return s.GetToken(CPP14ParserIntegerLiteral, 0)
}

func (s *PureSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PureSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PureSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterPureSpecifier(s)
	}
}

func (s *PureSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitPureSpecifier(s)
	}
}

func (s *PureSpecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitPureSpecifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) PureSpecifier() (localctx IPureSpecifierContext) {
	localctx = NewPureSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, CPP14ParserRULE_pureSpecifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1754)
		p.Match(CPP14ParserAssign)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1755)
		p.Match(CPP14ParserIntegerLiteral)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBaseClauseContext is an interface to support dynamic dispatch.
type IBaseClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Colon() antlr.TerminalNode
	BaseSpecifierList() IBaseSpecifierListContext

	// IsBaseClauseContext differentiates from other interfaces.
	IsBaseClauseContext()
}

type BaseClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBaseClauseContext() *BaseClauseContext {
	var p = new(BaseClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_baseClause
	return p
}

func InitEmptyBaseClauseContext(p *BaseClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_baseClause
}

func (*BaseClauseContext) IsBaseClauseContext() {}

func NewBaseClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BaseClauseContext {
	var p = new(BaseClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_baseClause

	return p
}

func (s *BaseClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *BaseClauseContext) Colon() antlr.TerminalNode {
	return s.GetToken(CPP14ParserColon, 0)
}

func (s *BaseClauseContext) BaseSpecifierList() IBaseSpecifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseSpecifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseSpecifierListContext)
}

func (s *BaseClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BaseClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BaseClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterBaseClause(s)
	}
}

func (s *BaseClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitBaseClause(s)
	}
}

func (s *BaseClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitBaseClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) BaseClause() (localctx IBaseClauseContext) {
	localctx = NewBaseClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, CPP14ParserRULE_baseClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1757)
		p.Match(CPP14ParserColon)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1758)
		p.BaseSpecifierList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBaseSpecifierListContext is an interface to support dynamic dispatch.
type IBaseSpecifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllBaseSpecifier() []IBaseSpecifierContext
	BaseSpecifier(i int) IBaseSpecifierContext
	AllEllipsis() []antlr.TerminalNode
	Ellipsis(i int) antlr.TerminalNode
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsBaseSpecifierListContext differentiates from other interfaces.
	IsBaseSpecifierListContext()
}

type BaseSpecifierListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBaseSpecifierListContext() *BaseSpecifierListContext {
	var p = new(BaseSpecifierListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_baseSpecifierList
	return p
}

func InitEmptyBaseSpecifierListContext(p *BaseSpecifierListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_baseSpecifierList
}

func (*BaseSpecifierListContext) IsBaseSpecifierListContext() {}

func NewBaseSpecifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BaseSpecifierListContext {
	var p = new(BaseSpecifierListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_baseSpecifierList

	return p
}

func (s *BaseSpecifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *BaseSpecifierListContext) AllBaseSpecifier() []IBaseSpecifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBaseSpecifierContext); ok {
			len++
		}
	}

	tst := make([]IBaseSpecifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBaseSpecifierContext); ok {
			tst[i] = t.(IBaseSpecifierContext)
			i++
		}
	}

	return tst
}

func (s *BaseSpecifierListContext) BaseSpecifier(i int) IBaseSpecifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseSpecifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseSpecifierContext)
}

func (s *BaseSpecifierListContext) AllEllipsis() []antlr.TerminalNode {
	return s.GetTokens(CPP14ParserEllipsis)
}

func (s *BaseSpecifierListContext) Ellipsis(i int) antlr.TerminalNode {
	return s.GetToken(CPP14ParserEllipsis, i)
}

func (s *BaseSpecifierListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(CPP14ParserComma)
}

func (s *BaseSpecifierListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(CPP14ParserComma, i)
}

func (s *BaseSpecifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BaseSpecifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BaseSpecifierListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterBaseSpecifierList(s)
	}
}

func (s *BaseSpecifierListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitBaseSpecifierList(s)
	}
}

func (s *BaseSpecifierListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitBaseSpecifierList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) BaseSpecifierList() (localctx IBaseSpecifierListContext) {
	localctx = NewBaseSpecifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, CPP14ParserRULE_baseSpecifierList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1760)
		p.BaseSpecifier()
	}
	p.SetState(1762)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CPP14ParserEllipsis {
		{
			p.SetState(1761)
			p.Match(CPP14ParserEllipsis)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1771)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CPP14ParserComma {
		{
			p.SetState(1764)
			p.Match(CPP14ParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1765)
			p.BaseSpecifier()
		}
		p.SetState(1767)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CPP14ParserEllipsis {
			{
				p.SetState(1766)
				p.Match(CPP14ParserEllipsis)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

		p.SetState(1773)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBaseSpecifierContext is an interface to support dynamic dispatch.
type IBaseSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BaseTypeSpecifier() IBaseTypeSpecifierContext
	Virtual() antlr.TerminalNode
	AccessSpecifier() IAccessSpecifierContext
	AttributeSpecifierSeq() IAttributeSpecifierSeqContext

	// IsBaseSpecifierContext differentiates from other interfaces.
	IsBaseSpecifierContext()
}

type BaseSpecifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBaseSpecifierContext() *BaseSpecifierContext {
	var p = new(BaseSpecifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_baseSpecifier
	return p
}

func InitEmptyBaseSpecifierContext(p *BaseSpecifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_baseSpecifier
}

func (*BaseSpecifierContext) IsBaseSpecifierContext() {}

func NewBaseSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BaseSpecifierContext {
	var p = new(BaseSpecifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_baseSpecifier

	return p
}

func (s *BaseSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *BaseSpecifierContext) BaseTypeSpecifier() IBaseTypeSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseTypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseTypeSpecifierContext)
}

func (s *BaseSpecifierContext) Virtual() antlr.TerminalNode {
	return s.GetToken(CPP14ParserVirtual, 0)
}

func (s *BaseSpecifierContext) AccessSpecifier() IAccessSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessSpecifierContext)
}

func (s *BaseSpecifierContext) AttributeSpecifierSeq() IAttributeSpecifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSpecifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSpecifierSeqContext)
}

func (s *BaseSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BaseSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BaseSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterBaseSpecifier(s)
	}
}

func (s *BaseSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitBaseSpecifier(s)
	}
}

func (s *BaseSpecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitBaseSpecifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) BaseSpecifier() (localctx IBaseSpecifierContext) {
	localctx = NewBaseSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, CPP14ParserRULE_baseSpecifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1775)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CPP14ParserAlignas || _la == CPP14ParserLeftBracket {
		{
			p.SetState(1774)
			p.AttributeSpecifierSeq()
		}

	}
	p.SetState(1789)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CPP14ParserDecltype, CPP14ParserDoublecolon, CPP14ParserIdentifier:
		{
			p.SetState(1777)
			p.BaseTypeSpecifier()
		}

	case CPP14ParserVirtual:
		{
			p.SetState(1778)
			p.Match(CPP14ParserVirtual)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1780)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&126100789566373888) != 0 {
			{
				p.SetState(1779)
				p.AccessSpecifier()
			}

		}
		{
			p.SetState(1782)
			p.BaseTypeSpecifier()
		}

	case CPP14ParserPrivate, CPP14ParserProtected, CPP14ParserPublic:
		{
			p.SetState(1783)
			p.AccessSpecifier()
		}
		p.SetState(1785)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CPP14ParserVirtual {
			{
				p.SetState(1784)
				p.Match(CPP14ParserVirtual)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1787)
			p.BaseTypeSpecifier()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassOrDeclTypeContext is an interface to support dynamic dispatch.
type IClassOrDeclTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ClassName() IClassNameContext
	NestedNameSpecifier() INestedNameSpecifierContext
	DecltypeSpecifier() IDecltypeSpecifierContext

	// IsClassOrDeclTypeContext differentiates from other interfaces.
	IsClassOrDeclTypeContext()
}

type ClassOrDeclTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassOrDeclTypeContext() *ClassOrDeclTypeContext {
	var p = new(ClassOrDeclTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_classOrDeclType
	return p
}

func InitEmptyClassOrDeclTypeContext(p *ClassOrDeclTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_classOrDeclType
}

func (*ClassOrDeclTypeContext) IsClassOrDeclTypeContext() {}

func NewClassOrDeclTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassOrDeclTypeContext {
	var p = new(ClassOrDeclTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_classOrDeclType

	return p
}

func (s *ClassOrDeclTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassOrDeclTypeContext) ClassName() IClassNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassNameContext)
}

func (s *ClassOrDeclTypeContext) NestedNameSpecifier() INestedNameSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedNameSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedNameSpecifierContext)
}

func (s *ClassOrDeclTypeContext) DecltypeSpecifier() IDecltypeSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecltypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecltypeSpecifierContext)
}

func (s *ClassOrDeclTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassOrDeclTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassOrDeclTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterClassOrDeclType(s)
	}
}

func (s *ClassOrDeclTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitClassOrDeclType(s)
	}
}

func (s *ClassOrDeclTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitClassOrDeclType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) ClassOrDeclType() (localctx IClassOrDeclTypeContext) {
	localctx = NewClassOrDeclTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, CPP14ParserRULE_classOrDeclType)
	p.SetState(1796)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 250, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1792)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 249, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1791)
				p.nestedNameSpecifier(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(1794)
			p.ClassName()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1795)
			p.DecltypeSpecifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBaseTypeSpecifierContext is an interface to support dynamic dispatch.
type IBaseTypeSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ClassOrDeclType() IClassOrDeclTypeContext

	// IsBaseTypeSpecifierContext differentiates from other interfaces.
	IsBaseTypeSpecifierContext()
}

type BaseTypeSpecifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBaseTypeSpecifierContext() *BaseTypeSpecifierContext {
	var p = new(BaseTypeSpecifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_baseTypeSpecifier
	return p
}

func InitEmptyBaseTypeSpecifierContext(p *BaseTypeSpecifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_baseTypeSpecifier
}

func (*BaseTypeSpecifierContext) IsBaseTypeSpecifierContext() {}

func NewBaseTypeSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BaseTypeSpecifierContext {
	var p = new(BaseTypeSpecifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_baseTypeSpecifier

	return p
}

func (s *BaseTypeSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *BaseTypeSpecifierContext) ClassOrDeclType() IClassOrDeclTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassOrDeclTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassOrDeclTypeContext)
}

func (s *BaseTypeSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BaseTypeSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BaseTypeSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterBaseTypeSpecifier(s)
	}
}

func (s *BaseTypeSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitBaseTypeSpecifier(s)
	}
}

func (s *BaseTypeSpecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitBaseTypeSpecifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) BaseTypeSpecifier() (localctx IBaseTypeSpecifierContext) {
	localctx = NewBaseTypeSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, CPP14ParserRULE_baseTypeSpecifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1798)
		p.ClassOrDeclType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAccessSpecifierContext is an interface to support dynamic dispatch.
type IAccessSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Private() antlr.TerminalNode
	Protected() antlr.TerminalNode
	Public() antlr.TerminalNode

	// IsAccessSpecifierContext differentiates from other interfaces.
	IsAccessSpecifierContext()
}

type AccessSpecifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAccessSpecifierContext() *AccessSpecifierContext {
	var p = new(AccessSpecifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_accessSpecifier
	return p
}

func InitEmptyAccessSpecifierContext(p *AccessSpecifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_accessSpecifier
}

func (*AccessSpecifierContext) IsAccessSpecifierContext() {}

func NewAccessSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AccessSpecifierContext {
	var p = new(AccessSpecifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_accessSpecifier

	return p
}

func (s *AccessSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *AccessSpecifierContext) Private() antlr.TerminalNode {
	return s.GetToken(CPP14ParserPrivate, 0)
}

func (s *AccessSpecifierContext) Protected() antlr.TerminalNode {
	return s.GetToken(CPP14ParserProtected, 0)
}

func (s *AccessSpecifierContext) Public() antlr.TerminalNode {
	return s.GetToken(CPP14ParserPublic, 0)
}

func (s *AccessSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AccessSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AccessSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterAccessSpecifier(s)
	}
}

func (s *AccessSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitAccessSpecifier(s)
	}
}

func (s *AccessSpecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitAccessSpecifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) AccessSpecifier() (localctx IAccessSpecifierContext) {
	localctx = NewAccessSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, CPP14ParserRULE_accessSpecifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1800)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&126100789566373888) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConversionFunctionIdContext is an interface to support dynamic dispatch.
type IConversionFunctionIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Operator() antlr.TerminalNode
	ConversionTypeId() IConversionTypeIdContext

	// IsConversionFunctionIdContext differentiates from other interfaces.
	IsConversionFunctionIdContext()
}

type ConversionFunctionIdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConversionFunctionIdContext() *ConversionFunctionIdContext {
	var p = new(ConversionFunctionIdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_conversionFunctionId
	return p
}

func InitEmptyConversionFunctionIdContext(p *ConversionFunctionIdContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_conversionFunctionId
}

func (*ConversionFunctionIdContext) IsConversionFunctionIdContext() {}

func NewConversionFunctionIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConversionFunctionIdContext {
	var p = new(ConversionFunctionIdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_conversionFunctionId

	return p
}

func (s *ConversionFunctionIdContext) GetParser() antlr.Parser { return s.parser }

func (s *ConversionFunctionIdContext) Operator() antlr.TerminalNode {
	return s.GetToken(CPP14ParserOperator, 0)
}

func (s *ConversionFunctionIdContext) ConversionTypeId() IConversionTypeIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConversionTypeIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConversionTypeIdContext)
}

func (s *ConversionFunctionIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConversionFunctionIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConversionFunctionIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterConversionFunctionId(s)
	}
}

func (s *ConversionFunctionIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitConversionFunctionId(s)
	}
}

func (s *ConversionFunctionIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitConversionFunctionId(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) ConversionFunctionId() (localctx IConversionFunctionIdContext) {
	localctx = NewConversionFunctionIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, CPP14ParserRULE_conversionFunctionId)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1802)
		p.Match(CPP14ParserOperator)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1803)
		p.ConversionTypeId()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConversionTypeIdContext is an interface to support dynamic dispatch.
type IConversionTypeIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeSpecifierSeq() ITypeSpecifierSeqContext
	ConversionDeclarator() IConversionDeclaratorContext

	// IsConversionTypeIdContext differentiates from other interfaces.
	IsConversionTypeIdContext()
}

type ConversionTypeIdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConversionTypeIdContext() *ConversionTypeIdContext {
	var p = new(ConversionTypeIdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_conversionTypeId
	return p
}

func InitEmptyConversionTypeIdContext(p *ConversionTypeIdContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_conversionTypeId
}

func (*ConversionTypeIdContext) IsConversionTypeIdContext() {}

func NewConversionTypeIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConversionTypeIdContext {
	var p = new(ConversionTypeIdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_conversionTypeId

	return p
}

func (s *ConversionTypeIdContext) GetParser() antlr.Parser { return s.parser }

func (s *ConversionTypeIdContext) TypeSpecifierSeq() ITypeSpecifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSpecifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSpecifierSeqContext)
}

func (s *ConversionTypeIdContext) ConversionDeclarator() IConversionDeclaratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConversionDeclaratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConversionDeclaratorContext)
}

func (s *ConversionTypeIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConversionTypeIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConversionTypeIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterConversionTypeId(s)
	}
}

func (s *ConversionTypeIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitConversionTypeId(s)
	}
}

func (s *ConversionTypeIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitConversionTypeId(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) ConversionTypeId() (localctx IConversionTypeIdContext) {
	localctx = NewConversionTypeIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, CPP14ParserRULE_conversionTypeId)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1805)
		p.TypeSpecifierSeq()
	}
	p.SetState(1807)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 251, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1806)
			p.ConversionDeclarator()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConversionDeclaratorContext is an interface to support dynamic dispatch.
type IConversionDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PointerOperator() IPointerOperatorContext
	ConversionDeclarator() IConversionDeclaratorContext

	// IsConversionDeclaratorContext differentiates from other interfaces.
	IsConversionDeclaratorContext()
}

type ConversionDeclaratorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConversionDeclaratorContext() *ConversionDeclaratorContext {
	var p = new(ConversionDeclaratorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_conversionDeclarator
	return p
}

func InitEmptyConversionDeclaratorContext(p *ConversionDeclaratorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_conversionDeclarator
}

func (*ConversionDeclaratorContext) IsConversionDeclaratorContext() {}

func NewConversionDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConversionDeclaratorContext {
	var p = new(ConversionDeclaratorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_conversionDeclarator

	return p
}

func (s *ConversionDeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *ConversionDeclaratorContext) PointerOperator() IPointerOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPointerOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPointerOperatorContext)
}

func (s *ConversionDeclaratorContext) ConversionDeclarator() IConversionDeclaratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConversionDeclaratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConversionDeclaratorContext)
}

func (s *ConversionDeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConversionDeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConversionDeclaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterConversionDeclarator(s)
	}
}

func (s *ConversionDeclaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitConversionDeclarator(s)
	}
}

func (s *ConversionDeclaratorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitConversionDeclarator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) ConversionDeclarator() (localctx IConversionDeclaratorContext) {
	localctx = NewConversionDeclaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, CPP14ParserRULE_conversionDeclarator)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1809)
		p.PointerOperator()
	}
	p.SetState(1811)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 252, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1810)
			p.ConversionDeclarator()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstructorInitializerContext is an interface to support dynamic dispatch.
type IConstructorInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Colon() antlr.TerminalNode
	MemInitializerList() IMemInitializerListContext

	// IsConstructorInitializerContext differentiates from other interfaces.
	IsConstructorInitializerContext()
}

type ConstructorInitializerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstructorInitializerContext() *ConstructorInitializerContext {
	var p = new(ConstructorInitializerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_constructorInitializer
	return p
}

func InitEmptyConstructorInitializerContext(p *ConstructorInitializerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_constructorInitializer
}

func (*ConstructorInitializerContext) IsConstructorInitializerContext() {}

func NewConstructorInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstructorInitializerContext {
	var p = new(ConstructorInitializerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_constructorInitializer

	return p
}

func (s *ConstructorInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstructorInitializerContext) Colon() antlr.TerminalNode {
	return s.GetToken(CPP14ParserColon, 0)
}

func (s *ConstructorInitializerContext) MemInitializerList() IMemInitializerListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMemInitializerListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMemInitializerListContext)
}

func (s *ConstructorInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstructorInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstructorInitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterConstructorInitializer(s)
	}
}

func (s *ConstructorInitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitConstructorInitializer(s)
	}
}

func (s *ConstructorInitializerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitConstructorInitializer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) ConstructorInitializer() (localctx IConstructorInitializerContext) {
	localctx = NewConstructorInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, CPP14ParserRULE_constructorInitializer)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1813)
		p.Match(CPP14ParserColon)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1814)
		p.MemInitializerList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMemInitializerListContext is an interface to support dynamic dispatch.
type IMemInitializerListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMemInitializer() []IMemInitializerContext
	MemInitializer(i int) IMemInitializerContext
	AllEllipsis() []antlr.TerminalNode
	Ellipsis(i int) antlr.TerminalNode
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsMemInitializerListContext differentiates from other interfaces.
	IsMemInitializerListContext()
}

type MemInitializerListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMemInitializerListContext() *MemInitializerListContext {
	var p = new(MemInitializerListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_memInitializerList
	return p
}

func InitEmptyMemInitializerListContext(p *MemInitializerListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_memInitializerList
}

func (*MemInitializerListContext) IsMemInitializerListContext() {}

func NewMemInitializerListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MemInitializerListContext {
	var p = new(MemInitializerListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_memInitializerList

	return p
}

func (s *MemInitializerListContext) GetParser() antlr.Parser { return s.parser }

func (s *MemInitializerListContext) AllMemInitializer() []IMemInitializerContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMemInitializerContext); ok {
			len++
		}
	}

	tst := make([]IMemInitializerContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMemInitializerContext); ok {
			tst[i] = t.(IMemInitializerContext)
			i++
		}
	}

	return tst
}

func (s *MemInitializerListContext) MemInitializer(i int) IMemInitializerContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMemInitializerContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMemInitializerContext)
}

func (s *MemInitializerListContext) AllEllipsis() []antlr.TerminalNode {
	return s.GetTokens(CPP14ParserEllipsis)
}

func (s *MemInitializerListContext) Ellipsis(i int) antlr.TerminalNode {
	return s.GetToken(CPP14ParserEllipsis, i)
}

func (s *MemInitializerListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(CPP14ParserComma)
}

func (s *MemInitializerListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(CPP14ParserComma, i)
}

func (s *MemInitializerListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemInitializerListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MemInitializerListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterMemInitializerList(s)
	}
}

func (s *MemInitializerListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitMemInitializerList(s)
	}
}

func (s *MemInitializerListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitMemInitializerList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) MemInitializerList() (localctx IMemInitializerListContext) {
	localctx = NewMemInitializerListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, CPP14ParserRULE_memInitializerList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1816)
		p.MemInitializer()
	}
	p.SetState(1818)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CPP14ParserEllipsis {
		{
			p.SetState(1817)
			p.Match(CPP14ParserEllipsis)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1827)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CPP14ParserComma {
		{
			p.SetState(1820)
			p.Match(CPP14ParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1821)
			p.MemInitializer()
		}
		p.SetState(1823)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CPP14ParserEllipsis {
			{
				p.SetState(1822)
				p.Match(CPP14ParserEllipsis)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

		p.SetState(1829)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMemInitializerContext is an interface to support dynamic dispatch.
type IMemInitializerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Meminitializerid() IMeminitializeridContext
	LeftParen() antlr.TerminalNode
	RightParen() antlr.TerminalNode
	BracedInitList() IBracedInitListContext
	ExpressionList() IExpressionListContext

	// IsMemInitializerContext differentiates from other interfaces.
	IsMemInitializerContext()
}

type MemInitializerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMemInitializerContext() *MemInitializerContext {
	var p = new(MemInitializerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_memInitializer
	return p
}

func InitEmptyMemInitializerContext(p *MemInitializerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_memInitializer
}

func (*MemInitializerContext) IsMemInitializerContext() {}

func NewMemInitializerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MemInitializerContext {
	var p = new(MemInitializerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_memInitializer

	return p
}

func (s *MemInitializerContext) GetParser() antlr.Parser { return s.parser }

func (s *MemInitializerContext) Meminitializerid() IMeminitializeridContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMeminitializeridContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMeminitializeridContext)
}

func (s *MemInitializerContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CPP14ParserLeftParen, 0)
}

func (s *MemInitializerContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CPP14ParserRightParen, 0)
}

func (s *MemInitializerContext) BracedInitList() IBracedInitListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBracedInitListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBracedInitListContext)
}

func (s *MemInitializerContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *MemInitializerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemInitializerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MemInitializerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterMemInitializer(s)
	}
}

func (s *MemInitializerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitMemInitializer(s)
	}
}

func (s *MemInitializerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitMemInitializer(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) MemInitializer() (localctx IMemInitializerContext) {
	localctx = NewMemInitializerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, CPP14ParserRULE_memInitializer)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1830)
		p.Meminitializerid()
	}
	p.SetState(1837)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CPP14ParserLeftParen:
		{
			p.SetState(1831)
			p.Match(CPP14ParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1833)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8364979464334764286) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&4719772474400910417) != 0) || _la == CPP14ParserIdentifier {
			{
				p.SetState(1832)
				p.ExpressionList()
			}

		}
		{
			p.SetState(1835)
			p.Match(CPP14ParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case CPP14ParserLeftBrace:
		{
			p.SetState(1836)
			p.BracedInitList()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMeminitializeridContext is an interface to support dynamic dispatch.
type IMeminitializeridContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ClassOrDeclType() IClassOrDeclTypeContext
	Identifier() antlr.TerminalNode

	// IsMeminitializeridContext differentiates from other interfaces.
	IsMeminitializeridContext()
}

type MeminitializeridContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMeminitializeridContext() *MeminitializeridContext {
	var p = new(MeminitializeridContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_meminitializerid
	return p
}

func InitEmptyMeminitializeridContext(p *MeminitializeridContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_meminitializerid
}

func (*MeminitializeridContext) IsMeminitializeridContext() {}

func NewMeminitializeridContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MeminitializeridContext {
	var p = new(MeminitializeridContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_meminitializerid

	return p
}

func (s *MeminitializeridContext) GetParser() antlr.Parser { return s.parser }

func (s *MeminitializeridContext) ClassOrDeclType() IClassOrDeclTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassOrDeclTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassOrDeclTypeContext)
}

func (s *MeminitializeridContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CPP14ParserIdentifier, 0)
}

func (s *MeminitializeridContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MeminitializeridContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MeminitializeridContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterMeminitializerid(s)
	}
}

func (s *MeminitializeridContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitMeminitializerid(s)
	}
}

func (s *MeminitializeridContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitMeminitializerid(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) Meminitializerid() (localctx IMeminitializeridContext) {
	localctx = NewMeminitializeridContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, CPP14ParserRULE_meminitializerid)
	p.SetState(1841)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 258, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1839)
			p.ClassOrDeclType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1840)
			p.Match(CPP14ParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOperatorFunctionIdContext is an interface to support dynamic dispatch.
type IOperatorFunctionIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Operator() antlr.TerminalNode
	TheOperator() ITheOperatorContext

	// IsOperatorFunctionIdContext differentiates from other interfaces.
	IsOperatorFunctionIdContext()
}

type OperatorFunctionIdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOperatorFunctionIdContext() *OperatorFunctionIdContext {
	var p = new(OperatorFunctionIdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_operatorFunctionId
	return p
}

func InitEmptyOperatorFunctionIdContext(p *OperatorFunctionIdContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_operatorFunctionId
}

func (*OperatorFunctionIdContext) IsOperatorFunctionIdContext() {}

func NewOperatorFunctionIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OperatorFunctionIdContext {
	var p = new(OperatorFunctionIdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_operatorFunctionId

	return p
}

func (s *OperatorFunctionIdContext) GetParser() antlr.Parser { return s.parser }

func (s *OperatorFunctionIdContext) Operator() antlr.TerminalNode {
	return s.GetToken(CPP14ParserOperator, 0)
}

func (s *OperatorFunctionIdContext) TheOperator() ITheOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITheOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITheOperatorContext)
}

func (s *OperatorFunctionIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OperatorFunctionIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OperatorFunctionIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterOperatorFunctionId(s)
	}
}

func (s *OperatorFunctionIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitOperatorFunctionId(s)
	}
}

func (s *OperatorFunctionIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitOperatorFunctionId(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) OperatorFunctionId() (localctx IOperatorFunctionIdContext) {
	localctx = NewOperatorFunctionIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, CPP14ParserRULE_operatorFunctionId)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1843)
		p.Match(CPP14ParserOperator)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1844)
		p.TheOperator()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralOperatorIdContext is an interface to support dynamic dispatch.
type ILiteralOperatorIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Operator() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode
	Identifier() antlr.TerminalNode
	UserDefinedStringLiteral() antlr.TerminalNode

	// IsLiteralOperatorIdContext differentiates from other interfaces.
	IsLiteralOperatorIdContext()
}

type LiteralOperatorIdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralOperatorIdContext() *LiteralOperatorIdContext {
	var p = new(LiteralOperatorIdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_literalOperatorId
	return p
}

func InitEmptyLiteralOperatorIdContext(p *LiteralOperatorIdContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_literalOperatorId
}

func (*LiteralOperatorIdContext) IsLiteralOperatorIdContext() {}

func NewLiteralOperatorIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralOperatorIdContext {
	var p = new(LiteralOperatorIdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_literalOperatorId

	return p
}

func (s *LiteralOperatorIdContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralOperatorIdContext) Operator() antlr.TerminalNode {
	return s.GetToken(CPP14ParserOperator, 0)
}

func (s *LiteralOperatorIdContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(CPP14ParserStringLiteral, 0)
}

func (s *LiteralOperatorIdContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CPP14ParserIdentifier, 0)
}

func (s *LiteralOperatorIdContext) UserDefinedStringLiteral() antlr.TerminalNode {
	return s.GetToken(CPP14ParserUserDefinedStringLiteral, 0)
}

func (s *LiteralOperatorIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralOperatorIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralOperatorIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterLiteralOperatorId(s)
	}
}

func (s *LiteralOperatorIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitLiteralOperatorId(s)
	}
}

func (s *LiteralOperatorIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitLiteralOperatorId(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) LiteralOperatorId() (localctx ILiteralOperatorIdContext) {
	localctx = NewLiteralOperatorIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, CPP14ParserRULE_literalOperatorId)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1846)
		p.Match(CPP14ParserOperator)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1850)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CPP14ParserStringLiteral:
		{
			p.SetState(1847)
			p.Match(CPP14ParserStringLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1848)
			p.Match(CPP14ParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case CPP14ParserUserDefinedStringLiteral:
		{
			p.SetState(1849)
			p.Match(CPP14ParserUserDefinedStringLiteral)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITemplateDeclarationContext is an interface to support dynamic dispatch.
type ITemplateDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Template() antlr.TerminalNode
	Less() antlr.TerminalNode
	TemplateparameterList() ITemplateparameterListContext
	Greater() antlr.TerminalNode
	Declaration() IDeclarationContext

	// IsTemplateDeclarationContext differentiates from other interfaces.
	IsTemplateDeclarationContext()
}

type TemplateDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTemplateDeclarationContext() *TemplateDeclarationContext {
	var p = new(TemplateDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_templateDeclaration
	return p
}

func InitEmptyTemplateDeclarationContext(p *TemplateDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_templateDeclaration
}

func (*TemplateDeclarationContext) IsTemplateDeclarationContext() {}

func NewTemplateDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TemplateDeclarationContext {
	var p = new(TemplateDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_templateDeclaration

	return p
}

func (s *TemplateDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *TemplateDeclarationContext) Template() antlr.TerminalNode {
	return s.GetToken(CPP14ParserTemplate, 0)
}

func (s *TemplateDeclarationContext) Less() antlr.TerminalNode {
	return s.GetToken(CPP14ParserLess, 0)
}

func (s *TemplateDeclarationContext) TemplateparameterList() ITemplateparameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITemplateparameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITemplateparameterListContext)
}

func (s *TemplateDeclarationContext) Greater() antlr.TerminalNode {
	return s.GetToken(CPP14ParserGreater, 0)
}

func (s *TemplateDeclarationContext) Declaration() IDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *TemplateDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TemplateDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TemplateDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterTemplateDeclaration(s)
	}
}

func (s *TemplateDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitTemplateDeclaration(s)
	}
}

func (s *TemplateDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitTemplateDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) TemplateDeclaration() (localctx ITemplateDeclarationContext) {
	localctx = NewTemplateDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, CPP14ParserRULE_templateDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1852)
		p.Match(CPP14ParserTemplate)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1853)
		p.Match(CPP14ParserLess)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1854)
		p.TemplateparameterList()
	}
	{
		p.SetState(1855)
		p.Match(CPP14ParserGreater)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1856)
		p.Declaration()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITemplateparameterListContext is an interface to support dynamic dispatch.
type ITemplateparameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTemplateParameter() []ITemplateParameterContext
	TemplateParameter(i int) ITemplateParameterContext
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsTemplateparameterListContext differentiates from other interfaces.
	IsTemplateparameterListContext()
}

type TemplateparameterListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTemplateparameterListContext() *TemplateparameterListContext {
	var p = new(TemplateparameterListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_templateparameterList
	return p
}

func InitEmptyTemplateparameterListContext(p *TemplateparameterListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_templateparameterList
}

func (*TemplateparameterListContext) IsTemplateparameterListContext() {}

func NewTemplateparameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TemplateparameterListContext {
	var p = new(TemplateparameterListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_templateparameterList

	return p
}

func (s *TemplateparameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *TemplateparameterListContext) AllTemplateParameter() []ITemplateParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITemplateParameterContext); ok {
			len++
		}
	}

	tst := make([]ITemplateParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITemplateParameterContext); ok {
			tst[i] = t.(ITemplateParameterContext)
			i++
		}
	}

	return tst
}

func (s *TemplateparameterListContext) TemplateParameter(i int) ITemplateParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITemplateParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITemplateParameterContext)
}

func (s *TemplateparameterListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(CPP14ParserComma)
}

func (s *TemplateparameterListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(CPP14ParserComma, i)
}

func (s *TemplateparameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TemplateparameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TemplateparameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterTemplateparameterList(s)
	}
}

func (s *TemplateparameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitTemplateparameterList(s)
	}
}

func (s *TemplateparameterListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitTemplateparameterList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) TemplateparameterList() (localctx ITemplateparameterListContext) {
	localctx = NewTemplateparameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, CPP14ParserRULE_templateparameterList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1858)
		p.TemplateParameter()
	}
	p.SetState(1863)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CPP14ParserComma {
		{
			p.SetState(1859)
			p.Match(CPP14ParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1860)
			p.TemplateParameter()
		}

		p.SetState(1865)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITemplateParameterContext is an interface to support dynamic dispatch.
type ITemplateParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeParameter() ITypeParameterContext
	ParameterDeclaration() IParameterDeclarationContext

	// IsTemplateParameterContext differentiates from other interfaces.
	IsTemplateParameterContext()
}

type TemplateParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTemplateParameterContext() *TemplateParameterContext {
	var p = new(TemplateParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_templateParameter
	return p
}

func InitEmptyTemplateParameterContext(p *TemplateParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_templateParameter
}

func (*TemplateParameterContext) IsTemplateParameterContext() {}

func NewTemplateParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TemplateParameterContext {
	var p = new(TemplateParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_templateParameter

	return p
}

func (s *TemplateParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *TemplateParameterContext) TypeParameter() ITypeParameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParameterContext)
}

func (s *TemplateParameterContext) ParameterDeclaration() IParameterDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterDeclarationContext)
}

func (s *TemplateParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TemplateParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TemplateParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterTemplateParameter(s)
	}
}

func (s *TemplateParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitTemplateParameter(s)
	}
}

func (s *TemplateParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitTemplateParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) TemplateParameter() (localctx ITemplateParameterContext) {
	localctx = NewTemplateParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, CPP14ParserRULE_templateParameter)
	p.SetState(1868)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 261, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1866)
			p.TypeParameter()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1867)
			p.ParameterDeclaration()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeParameterContext is an interface to support dynamic dispatch.
type ITypeParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Class() antlr.TerminalNode
	Typename_() antlr.TerminalNode
	Assign() antlr.TerminalNode
	TheTypeId() ITheTypeIdContext
	Template() antlr.TerminalNode
	Less() antlr.TerminalNode
	TemplateparameterList() ITemplateparameterListContext
	Greater() antlr.TerminalNode
	Ellipsis() antlr.TerminalNode
	Identifier() antlr.TerminalNode

	// IsTypeParameterContext differentiates from other interfaces.
	IsTypeParameterContext()
}

type TypeParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterContext() *TypeParameterContext {
	var p = new(TypeParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_typeParameter
	return p
}

func InitEmptyTypeParameterContext(p *TypeParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_typeParameter
}

func (*TypeParameterContext) IsTypeParameterContext() {}

func NewTypeParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterContext {
	var p = new(TypeParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_typeParameter

	return p
}

func (s *TypeParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterContext) Class() antlr.TerminalNode {
	return s.GetToken(CPP14ParserClass, 0)
}

func (s *TypeParameterContext) Typename_() antlr.TerminalNode {
	return s.GetToken(CPP14ParserTypename_, 0)
}

func (s *TypeParameterContext) Assign() antlr.TerminalNode {
	return s.GetToken(CPP14ParserAssign, 0)
}

func (s *TypeParameterContext) TheTypeId() ITheTypeIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITheTypeIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITheTypeIdContext)
}

func (s *TypeParameterContext) Template() antlr.TerminalNode {
	return s.GetToken(CPP14ParserTemplate, 0)
}

func (s *TypeParameterContext) Less() antlr.TerminalNode {
	return s.GetToken(CPP14ParserLess, 0)
}

func (s *TypeParameterContext) TemplateparameterList() ITemplateparameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITemplateparameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITemplateparameterListContext)
}

func (s *TypeParameterContext) Greater() antlr.TerminalNode {
	return s.GetToken(CPP14ParserGreater, 0)
}

func (s *TypeParameterContext) Ellipsis() antlr.TerminalNode {
	return s.GetToken(CPP14ParserEllipsis, 0)
}

func (s *TypeParameterContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CPP14ParserIdentifier, 0)
}

func (s *TypeParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterTypeParameter(s)
	}
}

func (s *TypeParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitTypeParameter(s)
	}
}

func (s *TypeParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitTypeParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) TypeParameter() (localctx ITypeParameterContext) {
	localctx = NewTypeParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, CPP14ParserRULE_typeParameter)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1879)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CPP14ParserClass, CPP14ParserTemplate:
		p.SetState(1875)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CPP14ParserTemplate {
			{
				p.SetState(1870)
				p.Match(CPP14ParserTemplate)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1871)
				p.Match(CPP14ParserLess)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1872)
				p.TemplateparameterList()
			}
			{
				p.SetState(1873)
				p.Match(CPP14ParserGreater)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1877)
			p.Match(CPP14ParserClass)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case CPP14ParserTypename_:
		{
			p.SetState(1878)
			p.Match(CPP14ParserTypename_)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(1892)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 267, p.GetParserRuleContext()) {
	case 1:
		p.SetState(1882)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CPP14ParserEllipsis {
			{
				p.SetState(1881)
				p.Match(CPP14ParserEllipsis)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1885)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CPP14ParserIdentifier {
			{
				p.SetState(1884)
				p.Match(CPP14ParserIdentifier)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		p.SetState(1888)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CPP14ParserIdentifier {
			{
				p.SetState(1887)
				p.Match(CPP14ParserIdentifier)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1890)
			p.Match(CPP14ParserAssign)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1891)
			p.TheTypeId()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleTemplateIdContext is an interface to support dynamic dispatch.
type ISimpleTemplateIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TemplateName() ITemplateNameContext
	Less() antlr.TerminalNode
	Greater() antlr.TerminalNode
	TemplateArgumentList() ITemplateArgumentListContext

	// IsSimpleTemplateIdContext differentiates from other interfaces.
	IsSimpleTemplateIdContext()
}

type SimpleTemplateIdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleTemplateIdContext() *SimpleTemplateIdContext {
	var p = new(SimpleTemplateIdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_simpleTemplateId
	return p
}

func InitEmptySimpleTemplateIdContext(p *SimpleTemplateIdContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_simpleTemplateId
}

func (*SimpleTemplateIdContext) IsSimpleTemplateIdContext() {}

func NewSimpleTemplateIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleTemplateIdContext {
	var p = new(SimpleTemplateIdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_simpleTemplateId

	return p
}

func (s *SimpleTemplateIdContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleTemplateIdContext) TemplateName() ITemplateNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITemplateNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITemplateNameContext)
}

func (s *SimpleTemplateIdContext) Less() antlr.TerminalNode {
	return s.GetToken(CPP14ParserLess, 0)
}

func (s *SimpleTemplateIdContext) Greater() antlr.TerminalNode {
	return s.GetToken(CPP14ParserGreater, 0)
}

func (s *SimpleTemplateIdContext) TemplateArgumentList() ITemplateArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITemplateArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITemplateArgumentListContext)
}

func (s *SimpleTemplateIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleTemplateIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleTemplateIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterSimpleTemplateId(s)
	}
}

func (s *SimpleTemplateIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitSimpleTemplateId(s)
	}
}

func (s *SimpleTemplateIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitSimpleTemplateId(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) SimpleTemplateId() (localctx ISimpleTemplateIdContext) {
	localctx = NewSimpleTemplateIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, CPP14ParserRULE_simpleTemplateId)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1894)
		p.TemplateName()
	}
	{
		p.SetState(1895)
		p.Match(CPP14ParserLess)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1897)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8364979472930990334) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&4719772474384268307) != 0) || _la == CPP14ParserIdentifier {
		{
			p.SetState(1896)
			p.TemplateArgumentList()
		}

	}
	{
		p.SetState(1899)
		p.Match(CPP14ParserGreater)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITemplateIdContext is an interface to support dynamic dispatch.
type ITemplateIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleTemplateId() ISimpleTemplateIdContext
	Less() antlr.TerminalNode
	Greater() antlr.TerminalNode
	OperatorFunctionId() IOperatorFunctionIdContext
	LiteralOperatorId() ILiteralOperatorIdContext
	TemplateArgumentList() ITemplateArgumentListContext

	// IsTemplateIdContext differentiates from other interfaces.
	IsTemplateIdContext()
}

type TemplateIdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTemplateIdContext() *TemplateIdContext {
	var p = new(TemplateIdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_templateId
	return p
}

func InitEmptyTemplateIdContext(p *TemplateIdContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_templateId
}

func (*TemplateIdContext) IsTemplateIdContext() {}

func NewTemplateIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TemplateIdContext {
	var p = new(TemplateIdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_templateId

	return p
}

func (s *TemplateIdContext) GetParser() antlr.Parser { return s.parser }

func (s *TemplateIdContext) SimpleTemplateId() ISimpleTemplateIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleTemplateIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleTemplateIdContext)
}

func (s *TemplateIdContext) Less() antlr.TerminalNode {
	return s.GetToken(CPP14ParserLess, 0)
}

func (s *TemplateIdContext) Greater() antlr.TerminalNode {
	return s.GetToken(CPP14ParserGreater, 0)
}

func (s *TemplateIdContext) OperatorFunctionId() IOperatorFunctionIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOperatorFunctionIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOperatorFunctionIdContext)
}

func (s *TemplateIdContext) LiteralOperatorId() ILiteralOperatorIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralOperatorIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralOperatorIdContext)
}

func (s *TemplateIdContext) TemplateArgumentList() ITemplateArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITemplateArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITemplateArgumentListContext)
}

func (s *TemplateIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TemplateIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TemplateIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterTemplateId(s)
	}
}

func (s *TemplateIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitTemplateId(s)
	}
}

func (s *TemplateIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitTemplateId(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) TemplateId() (localctx ITemplateIdContext) {
	localctx = NewTemplateIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, CPP14ParserRULE_templateId)
	var _la int

	p.SetState(1912)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CPP14ParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1901)
			p.SimpleTemplateId()
		}

	case CPP14ParserOperator:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1904)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 269, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1902)
				p.OperatorFunctionId()
			}

		case 2:
			{
				p.SetState(1903)
				p.LiteralOperatorId()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(1906)
			p.Match(CPP14ParserLess)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1908)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8364979472930990334) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&4719772474384268307) != 0) || _la == CPP14ParserIdentifier {
			{
				p.SetState(1907)
				p.TemplateArgumentList()
			}

		}
		{
			p.SetState(1910)
			p.Match(CPP14ParserGreater)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITemplateNameContext is an interface to support dynamic dispatch.
type ITemplateNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() antlr.TerminalNode

	// IsTemplateNameContext differentiates from other interfaces.
	IsTemplateNameContext()
}

type TemplateNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTemplateNameContext() *TemplateNameContext {
	var p = new(TemplateNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_templateName
	return p
}

func InitEmptyTemplateNameContext(p *TemplateNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_templateName
}

func (*TemplateNameContext) IsTemplateNameContext() {}

func NewTemplateNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TemplateNameContext {
	var p = new(TemplateNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_templateName

	return p
}

func (s *TemplateNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TemplateNameContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CPP14ParserIdentifier, 0)
}

func (s *TemplateNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TemplateNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TemplateNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterTemplateName(s)
	}
}

func (s *TemplateNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitTemplateName(s)
	}
}

func (s *TemplateNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitTemplateName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) TemplateName() (localctx ITemplateNameContext) {
	localctx = NewTemplateNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, CPP14ParserRULE_templateName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1914)
		p.Match(CPP14ParserIdentifier)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITemplateArgumentListContext is an interface to support dynamic dispatch.
type ITemplateArgumentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTemplateArgument() []ITemplateArgumentContext
	TemplateArgument(i int) ITemplateArgumentContext
	AllEllipsis() []antlr.TerminalNode
	Ellipsis(i int) antlr.TerminalNode
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsTemplateArgumentListContext differentiates from other interfaces.
	IsTemplateArgumentListContext()
}

type TemplateArgumentListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTemplateArgumentListContext() *TemplateArgumentListContext {
	var p = new(TemplateArgumentListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_templateArgumentList
	return p
}

func InitEmptyTemplateArgumentListContext(p *TemplateArgumentListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_templateArgumentList
}

func (*TemplateArgumentListContext) IsTemplateArgumentListContext() {}

func NewTemplateArgumentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TemplateArgumentListContext {
	var p = new(TemplateArgumentListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_templateArgumentList

	return p
}

func (s *TemplateArgumentListContext) GetParser() antlr.Parser { return s.parser }

func (s *TemplateArgumentListContext) AllTemplateArgument() []ITemplateArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITemplateArgumentContext); ok {
			len++
		}
	}

	tst := make([]ITemplateArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITemplateArgumentContext); ok {
			tst[i] = t.(ITemplateArgumentContext)
			i++
		}
	}

	return tst
}

func (s *TemplateArgumentListContext) TemplateArgument(i int) ITemplateArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITemplateArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITemplateArgumentContext)
}

func (s *TemplateArgumentListContext) AllEllipsis() []antlr.TerminalNode {
	return s.GetTokens(CPP14ParserEllipsis)
}

func (s *TemplateArgumentListContext) Ellipsis(i int) antlr.TerminalNode {
	return s.GetToken(CPP14ParserEllipsis, i)
}

func (s *TemplateArgumentListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(CPP14ParserComma)
}

func (s *TemplateArgumentListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(CPP14ParserComma, i)
}

func (s *TemplateArgumentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TemplateArgumentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TemplateArgumentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterTemplateArgumentList(s)
	}
}

func (s *TemplateArgumentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitTemplateArgumentList(s)
	}
}

func (s *TemplateArgumentListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitTemplateArgumentList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) TemplateArgumentList() (localctx ITemplateArgumentListContext) {
	localctx = NewTemplateArgumentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 348, CPP14ParserRULE_templateArgumentList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1916)
		p.TemplateArgument()
	}
	p.SetState(1918)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CPP14ParserEllipsis {
		{
			p.SetState(1917)
			p.Match(CPP14ParserEllipsis)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1927)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CPP14ParserComma {
		{
			p.SetState(1920)
			p.Match(CPP14ParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1921)
			p.TemplateArgument()
		}
		p.SetState(1923)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CPP14ParserEllipsis {
			{
				p.SetState(1922)
				p.Match(CPP14ParserEllipsis)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

		p.SetState(1929)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITemplateArgumentContext is an interface to support dynamic dispatch.
type ITemplateArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TheTypeId() ITheTypeIdContext
	ConstantExpression() IConstantExpressionContext
	IdExpression() IIdExpressionContext

	// IsTemplateArgumentContext differentiates from other interfaces.
	IsTemplateArgumentContext()
}

type TemplateArgumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTemplateArgumentContext() *TemplateArgumentContext {
	var p = new(TemplateArgumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_templateArgument
	return p
}

func InitEmptyTemplateArgumentContext(p *TemplateArgumentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_templateArgument
}

func (*TemplateArgumentContext) IsTemplateArgumentContext() {}

func NewTemplateArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TemplateArgumentContext {
	var p = new(TemplateArgumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_templateArgument

	return p
}

func (s *TemplateArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *TemplateArgumentContext) TheTypeId() ITheTypeIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITheTypeIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITheTypeIdContext)
}

func (s *TemplateArgumentContext) ConstantExpression() IConstantExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantExpressionContext)
}

func (s *TemplateArgumentContext) IdExpression() IIdExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdExpressionContext)
}

func (s *TemplateArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TemplateArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TemplateArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterTemplateArgument(s)
	}
}

func (s *TemplateArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitTemplateArgument(s)
	}
}

func (s *TemplateArgumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitTemplateArgument(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) TemplateArgument() (localctx ITemplateArgumentContext) {
	localctx = NewTemplateArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 350, CPP14ParserRULE_templateArgument)
	p.SetState(1933)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 275, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1930)
			p.TheTypeId()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1931)
			p.ConstantExpression()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1932)
			p.IdExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeNameSpecifierContext is an interface to support dynamic dispatch.
type ITypeNameSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Typename_() antlr.TerminalNode
	NestedNameSpecifier() INestedNameSpecifierContext
	Identifier() antlr.TerminalNode
	SimpleTemplateId() ISimpleTemplateIdContext
	Template() antlr.TerminalNode

	// IsTypeNameSpecifierContext differentiates from other interfaces.
	IsTypeNameSpecifierContext()
}

type TypeNameSpecifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeNameSpecifierContext() *TypeNameSpecifierContext {
	var p = new(TypeNameSpecifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_typeNameSpecifier
	return p
}

func InitEmptyTypeNameSpecifierContext(p *TypeNameSpecifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_typeNameSpecifier
}

func (*TypeNameSpecifierContext) IsTypeNameSpecifierContext() {}

func NewTypeNameSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeNameSpecifierContext {
	var p = new(TypeNameSpecifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_typeNameSpecifier

	return p
}

func (s *TypeNameSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeNameSpecifierContext) Typename_() antlr.TerminalNode {
	return s.GetToken(CPP14ParserTypename_, 0)
}

func (s *TypeNameSpecifierContext) NestedNameSpecifier() INestedNameSpecifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedNameSpecifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedNameSpecifierContext)
}

func (s *TypeNameSpecifierContext) Identifier() antlr.TerminalNode {
	return s.GetToken(CPP14ParserIdentifier, 0)
}

func (s *TypeNameSpecifierContext) SimpleTemplateId() ISimpleTemplateIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleTemplateIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleTemplateIdContext)
}

func (s *TypeNameSpecifierContext) Template() antlr.TerminalNode {
	return s.GetToken(CPP14ParserTemplate, 0)
}

func (s *TypeNameSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeNameSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeNameSpecifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterTypeNameSpecifier(s)
	}
}

func (s *TypeNameSpecifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitTypeNameSpecifier(s)
	}
}

func (s *TypeNameSpecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitTypeNameSpecifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) TypeNameSpecifier() (localctx ITypeNameSpecifierContext) {
	localctx = NewTypeNameSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 352, CPP14ParserRULE_typeNameSpecifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1935)
		p.Match(CPP14ParserTypename_)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1936)
		p.nestedNameSpecifier(0)
	}
	p.SetState(1942)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 277, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1937)
			p.Match(CPP14ParserIdentifier)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.SetState(1939)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CPP14ParserTemplate {
			{
				p.SetState(1938)
				p.Match(CPP14ParserTemplate)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1941)
			p.SimpleTemplateId()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExplicitInstantiationContext is an interface to support dynamic dispatch.
type IExplicitInstantiationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Template() antlr.TerminalNode
	Declaration() IDeclarationContext
	Extern() antlr.TerminalNode

	// IsExplicitInstantiationContext differentiates from other interfaces.
	IsExplicitInstantiationContext()
}

type ExplicitInstantiationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplicitInstantiationContext() *ExplicitInstantiationContext {
	var p = new(ExplicitInstantiationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_explicitInstantiation
	return p
}

func InitEmptyExplicitInstantiationContext(p *ExplicitInstantiationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_explicitInstantiation
}

func (*ExplicitInstantiationContext) IsExplicitInstantiationContext() {}

func NewExplicitInstantiationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExplicitInstantiationContext {
	var p = new(ExplicitInstantiationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_explicitInstantiation

	return p
}

func (s *ExplicitInstantiationContext) GetParser() antlr.Parser { return s.parser }

func (s *ExplicitInstantiationContext) Template() antlr.TerminalNode {
	return s.GetToken(CPP14ParserTemplate, 0)
}

func (s *ExplicitInstantiationContext) Declaration() IDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *ExplicitInstantiationContext) Extern() antlr.TerminalNode {
	return s.GetToken(CPP14ParserExtern, 0)
}

func (s *ExplicitInstantiationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplicitInstantiationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExplicitInstantiationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterExplicitInstantiation(s)
	}
}

func (s *ExplicitInstantiationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitExplicitInstantiation(s)
	}
}

func (s *ExplicitInstantiationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitExplicitInstantiation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) ExplicitInstantiation() (localctx IExplicitInstantiationContext) {
	localctx = NewExplicitInstantiationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 354, CPP14ParserRULE_explicitInstantiation)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1945)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CPP14ParserExtern {
		{
			p.SetState(1944)
			p.Match(CPP14ParserExtern)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1947)
		p.Match(CPP14ParserTemplate)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1948)
		p.Declaration()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExplicitSpecializationContext is an interface to support dynamic dispatch.
type IExplicitSpecializationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Template() antlr.TerminalNode
	Less() antlr.TerminalNode
	Greater() antlr.TerminalNode
	Declaration() IDeclarationContext

	// IsExplicitSpecializationContext differentiates from other interfaces.
	IsExplicitSpecializationContext()
}

type ExplicitSpecializationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplicitSpecializationContext() *ExplicitSpecializationContext {
	var p = new(ExplicitSpecializationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_explicitSpecialization
	return p
}

func InitEmptyExplicitSpecializationContext(p *ExplicitSpecializationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_explicitSpecialization
}

func (*ExplicitSpecializationContext) IsExplicitSpecializationContext() {}

func NewExplicitSpecializationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExplicitSpecializationContext {
	var p = new(ExplicitSpecializationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_explicitSpecialization

	return p
}

func (s *ExplicitSpecializationContext) GetParser() antlr.Parser { return s.parser }

func (s *ExplicitSpecializationContext) Template() antlr.TerminalNode {
	return s.GetToken(CPP14ParserTemplate, 0)
}

func (s *ExplicitSpecializationContext) Less() antlr.TerminalNode {
	return s.GetToken(CPP14ParserLess, 0)
}

func (s *ExplicitSpecializationContext) Greater() antlr.TerminalNode {
	return s.GetToken(CPP14ParserGreater, 0)
}

func (s *ExplicitSpecializationContext) Declaration() IDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclarationContext)
}

func (s *ExplicitSpecializationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplicitSpecializationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExplicitSpecializationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterExplicitSpecialization(s)
	}
}

func (s *ExplicitSpecializationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitExplicitSpecialization(s)
	}
}

func (s *ExplicitSpecializationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitExplicitSpecialization(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) ExplicitSpecialization() (localctx IExplicitSpecializationContext) {
	localctx = NewExplicitSpecializationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 356, CPP14ParserRULE_explicitSpecialization)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1950)
		p.Match(CPP14ParserTemplate)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1951)
		p.Match(CPP14ParserLess)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1952)
		p.Match(CPP14ParserGreater)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1953)
		p.Declaration()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITryBlockContext is an interface to support dynamic dispatch.
type ITryBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Try() antlr.TerminalNode
	CompoundStatement() ICompoundStatementContext
	HandlerSeq() IHandlerSeqContext

	// IsTryBlockContext differentiates from other interfaces.
	IsTryBlockContext()
}

type TryBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTryBlockContext() *TryBlockContext {
	var p = new(TryBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_tryBlock
	return p
}

func InitEmptyTryBlockContext(p *TryBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_tryBlock
}

func (*TryBlockContext) IsTryBlockContext() {}

func NewTryBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TryBlockContext {
	var p = new(TryBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_tryBlock

	return p
}

func (s *TryBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *TryBlockContext) Try() antlr.TerminalNode {
	return s.GetToken(CPP14ParserTry, 0)
}

func (s *TryBlockContext) CompoundStatement() ICompoundStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementContext)
}

func (s *TryBlockContext) HandlerSeq() IHandlerSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHandlerSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHandlerSeqContext)
}

func (s *TryBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TryBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TryBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterTryBlock(s)
	}
}

func (s *TryBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitTryBlock(s)
	}
}

func (s *TryBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitTryBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) TryBlock() (localctx ITryBlockContext) {
	localctx = NewTryBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 358, CPP14ParserRULE_tryBlock)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1955)
		p.Match(CPP14ParserTry)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1956)
		p.CompoundStatement()
	}
	{
		p.SetState(1957)
		p.HandlerSeq()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionTryBlockContext is an interface to support dynamic dispatch.
type IFunctionTryBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Try() antlr.TerminalNode
	CompoundStatement() ICompoundStatementContext
	HandlerSeq() IHandlerSeqContext
	ConstructorInitializer() IConstructorInitializerContext

	// IsFunctionTryBlockContext differentiates from other interfaces.
	IsFunctionTryBlockContext()
}

type FunctionTryBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionTryBlockContext() *FunctionTryBlockContext {
	var p = new(FunctionTryBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_functionTryBlock
	return p
}

func InitEmptyFunctionTryBlockContext(p *FunctionTryBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_functionTryBlock
}

func (*FunctionTryBlockContext) IsFunctionTryBlockContext() {}

func NewFunctionTryBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionTryBlockContext {
	var p = new(FunctionTryBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_functionTryBlock

	return p
}

func (s *FunctionTryBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionTryBlockContext) Try() antlr.TerminalNode {
	return s.GetToken(CPP14ParserTry, 0)
}

func (s *FunctionTryBlockContext) CompoundStatement() ICompoundStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementContext)
}

func (s *FunctionTryBlockContext) HandlerSeq() IHandlerSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHandlerSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHandlerSeqContext)
}

func (s *FunctionTryBlockContext) ConstructorInitializer() IConstructorInitializerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstructorInitializerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstructorInitializerContext)
}

func (s *FunctionTryBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionTryBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionTryBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterFunctionTryBlock(s)
	}
}

func (s *FunctionTryBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitFunctionTryBlock(s)
	}
}

func (s *FunctionTryBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitFunctionTryBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) FunctionTryBlock() (localctx IFunctionTryBlockContext) {
	localctx = NewFunctionTryBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 360, CPP14ParserRULE_functionTryBlock)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1959)
		p.Match(CPP14ParserTry)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1961)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CPP14ParserColon {
		{
			p.SetState(1960)
			p.ConstructorInitializer()
		}

	}
	{
		p.SetState(1963)
		p.CompoundStatement()
	}
	{
		p.SetState(1964)
		p.HandlerSeq()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHandlerSeqContext is an interface to support dynamic dispatch.
type IHandlerSeqContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllHandler() []IHandlerContext
	Handler(i int) IHandlerContext

	// IsHandlerSeqContext differentiates from other interfaces.
	IsHandlerSeqContext()
}

type HandlerSeqContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHandlerSeqContext() *HandlerSeqContext {
	var p = new(HandlerSeqContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_handlerSeq
	return p
}

func InitEmptyHandlerSeqContext(p *HandlerSeqContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_handlerSeq
}

func (*HandlerSeqContext) IsHandlerSeqContext() {}

func NewHandlerSeqContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HandlerSeqContext {
	var p = new(HandlerSeqContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_handlerSeq

	return p
}

func (s *HandlerSeqContext) GetParser() antlr.Parser { return s.parser }

func (s *HandlerSeqContext) AllHandler() []IHandlerContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IHandlerContext); ok {
			len++
		}
	}

	tst := make([]IHandlerContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IHandlerContext); ok {
			tst[i] = t.(IHandlerContext)
			i++
		}
	}

	return tst
}

func (s *HandlerSeqContext) Handler(i int) IHandlerContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHandlerContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHandlerContext)
}

func (s *HandlerSeqContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerSeqContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HandlerSeqContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterHandlerSeq(s)
	}
}

func (s *HandlerSeqContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitHandlerSeq(s)
	}
}

func (s *HandlerSeqContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitHandlerSeq(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) HandlerSeq() (localctx IHandlerSeqContext) {
	localctx = NewHandlerSeqContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 362, CPP14ParserRULE_handlerSeq)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1967)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == CPP14ParserCatch {
		{
			p.SetState(1966)
			p.Handler()
		}

		p.SetState(1969)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHandlerContext is an interface to support dynamic dispatch.
type IHandlerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Catch() antlr.TerminalNode
	LeftParen() antlr.TerminalNode
	ExceptionDeclaration() IExceptionDeclarationContext
	RightParen() antlr.TerminalNode
	CompoundStatement() ICompoundStatementContext

	// IsHandlerContext differentiates from other interfaces.
	IsHandlerContext()
}

type HandlerContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHandlerContext() *HandlerContext {
	var p = new(HandlerContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_handler
	return p
}

func InitEmptyHandlerContext(p *HandlerContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_handler
}

func (*HandlerContext) IsHandlerContext() {}

func NewHandlerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HandlerContext {
	var p = new(HandlerContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_handler

	return p
}

func (s *HandlerContext) GetParser() antlr.Parser { return s.parser }

func (s *HandlerContext) Catch() antlr.TerminalNode {
	return s.GetToken(CPP14ParserCatch, 0)
}

func (s *HandlerContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CPP14ParserLeftParen, 0)
}

func (s *HandlerContext) ExceptionDeclaration() IExceptionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExceptionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExceptionDeclarationContext)
}

func (s *HandlerContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CPP14ParserRightParen, 0)
}

func (s *HandlerContext) CompoundStatement() ICompoundStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompoundStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompoundStatementContext)
}

func (s *HandlerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HandlerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HandlerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterHandler(s)
	}
}

func (s *HandlerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitHandler(s)
	}
}

func (s *HandlerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitHandler(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) Handler() (localctx IHandlerContext) {
	localctx = NewHandlerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 364, CPP14ParserRULE_handler)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1971)
		p.Match(CPP14ParserCatch)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1972)
		p.Match(CPP14ParserLeftParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1973)
		p.ExceptionDeclaration()
	}
	{
		p.SetState(1974)
		p.Match(CPP14ParserRightParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1975)
		p.CompoundStatement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExceptionDeclarationContext is an interface to support dynamic dispatch.
type IExceptionDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeSpecifierSeq() ITypeSpecifierSeqContext
	AttributeSpecifierSeq() IAttributeSpecifierSeqContext
	Declarator() IDeclaratorContext
	AbstractDeclarator() IAbstractDeclaratorContext
	Ellipsis() antlr.TerminalNode

	// IsExceptionDeclarationContext differentiates from other interfaces.
	IsExceptionDeclarationContext()
}

type ExceptionDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExceptionDeclarationContext() *ExceptionDeclarationContext {
	var p = new(ExceptionDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_exceptionDeclaration
	return p
}

func InitEmptyExceptionDeclarationContext(p *ExceptionDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_exceptionDeclaration
}

func (*ExceptionDeclarationContext) IsExceptionDeclarationContext() {}

func NewExceptionDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExceptionDeclarationContext {
	var p = new(ExceptionDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_exceptionDeclaration

	return p
}

func (s *ExceptionDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ExceptionDeclarationContext) TypeSpecifierSeq() ITypeSpecifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSpecifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSpecifierSeqContext)
}

func (s *ExceptionDeclarationContext) AttributeSpecifierSeq() IAttributeSpecifierSeqContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAttributeSpecifierSeqContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAttributeSpecifierSeqContext)
}

func (s *ExceptionDeclarationContext) Declarator() IDeclaratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeclaratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeclaratorContext)
}

func (s *ExceptionDeclarationContext) AbstractDeclarator() IAbstractDeclaratorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAbstractDeclaratorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAbstractDeclaratorContext)
}

func (s *ExceptionDeclarationContext) Ellipsis() antlr.TerminalNode {
	return s.GetToken(CPP14ParserEllipsis, 0)
}

func (s *ExceptionDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExceptionDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExceptionDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterExceptionDeclaration(s)
	}
}

func (s *ExceptionDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitExceptionDeclaration(s)
	}
}

func (s *ExceptionDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitExceptionDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) ExceptionDeclaration() (localctx IExceptionDeclarationContext) {
	localctx = NewExceptionDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 366, CPP14ParserRULE_exceptionDeclaration)
	var _la int

	p.SetState(1986)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CPP14ParserAlignas, CPP14ParserAuto, CPP14ParserBool, CPP14ParserChar, CPP14ParserChar16, CPP14ParserChar32, CPP14ParserClass, CPP14ParserConst, CPP14ParserDecltype, CPP14ParserDouble, CPP14ParserEnum, CPP14ParserFloat, CPP14ParserInt, CPP14ParserLong, CPP14ParserShort, CPP14ParserSigned, CPP14ParserStruct, CPP14ParserTypename_, CPP14ParserUnion, CPP14ParserUnsigned, CPP14ParserVoid, CPP14ParserVolatile, CPP14ParserWchar, CPP14ParserLeftBracket, CPP14ParserDoublecolon, CPP14ParserIdentifier:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1978)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CPP14ParserAlignas || _la == CPP14ParserLeftBracket {
			{
				p.SetState(1977)
				p.AttributeSpecifierSeq()
			}

		}
		{
			p.SetState(1980)
			p.TypeSpecifierSeq()
		}
		p.SetState(1983)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 282, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1981)
				p.Declarator()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 282, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(1982)
				p.AbstractDeclarator()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case CPP14ParserEllipsis:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1985)
			p.Match(CPP14ParserEllipsis)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IThrowExpressionContext is an interface to support dynamic dispatch.
type IThrowExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Throw() antlr.TerminalNode
	AssignmentExpression() IAssignmentExpressionContext

	// IsThrowExpressionContext differentiates from other interfaces.
	IsThrowExpressionContext()
}

type ThrowExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThrowExpressionContext() *ThrowExpressionContext {
	var p = new(ThrowExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_throwExpression
	return p
}

func InitEmptyThrowExpressionContext(p *ThrowExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_throwExpression
}

func (*ThrowExpressionContext) IsThrowExpressionContext() {}

func NewThrowExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ThrowExpressionContext {
	var p = new(ThrowExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_throwExpression

	return p
}

func (s *ThrowExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ThrowExpressionContext) Throw() antlr.TerminalNode {
	return s.GetToken(CPP14ParserThrow, 0)
}

func (s *ThrowExpressionContext) AssignmentExpression() IAssignmentExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentExpressionContext)
}

func (s *ThrowExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThrowExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ThrowExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterThrowExpression(s)
	}
}

func (s *ThrowExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitThrowExpression(s)
	}
}

func (s *ThrowExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitThrowExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) ThrowExpression() (localctx IThrowExpressionContext) {
	localctx = NewThrowExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 368, CPP14ParserRULE_throwExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1988)
		p.Match(CPP14ParserThrow)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1990)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8364979464334764286) != 0) || ((int64((_la-65)) & ^0x3f) == 0 && ((int64(1)<<(_la-65))&4719772474384133201) != 0) || _la == CPP14ParserIdentifier {
		{
			p.SetState(1989)
			p.AssignmentExpression()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExceptionSpecificationContext is an interface to support dynamic dispatch.
type IExceptionSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DynamicExceptionSpecification() IDynamicExceptionSpecificationContext
	NoeExceptSpecification() INoeExceptSpecificationContext

	// IsExceptionSpecificationContext differentiates from other interfaces.
	IsExceptionSpecificationContext()
}

type ExceptionSpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExceptionSpecificationContext() *ExceptionSpecificationContext {
	var p = new(ExceptionSpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_exceptionSpecification
	return p
}

func InitEmptyExceptionSpecificationContext(p *ExceptionSpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_exceptionSpecification
}

func (*ExceptionSpecificationContext) IsExceptionSpecificationContext() {}

func NewExceptionSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExceptionSpecificationContext {
	var p = new(ExceptionSpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_exceptionSpecification

	return p
}

func (s *ExceptionSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *ExceptionSpecificationContext) DynamicExceptionSpecification() IDynamicExceptionSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDynamicExceptionSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDynamicExceptionSpecificationContext)
}

func (s *ExceptionSpecificationContext) NoeExceptSpecification() INoeExceptSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INoeExceptSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INoeExceptSpecificationContext)
}

func (s *ExceptionSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExceptionSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExceptionSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterExceptionSpecification(s)
	}
}

func (s *ExceptionSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitExceptionSpecification(s)
	}
}

func (s *ExceptionSpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitExceptionSpecification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) ExceptionSpecification() (localctx IExceptionSpecificationContext) {
	localctx = NewExceptionSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 370, CPP14ParserRULE_exceptionSpecification)
	p.SetState(1994)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CPP14ParserThrow:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1992)
			p.DynamicExceptionSpecification()
		}

	case CPP14ParserNoexcept:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1993)
			p.NoeExceptSpecification()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDynamicExceptionSpecificationContext is an interface to support dynamic dispatch.
type IDynamicExceptionSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Throw() antlr.TerminalNode
	LeftParen() antlr.TerminalNode
	RightParen() antlr.TerminalNode
	TypeIdList() ITypeIdListContext

	// IsDynamicExceptionSpecificationContext differentiates from other interfaces.
	IsDynamicExceptionSpecificationContext()
}

type DynamicExceptionSpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDynamicExceptionSpecificationContext() *DynamicExceptionSpecificationContext {
	var p = new(DynamicExceptionSpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_dynamicExceptionSpecification
	return p
}

func InitEmptyDynamicExceptionSpecificationContext(p *DynamicExceptionSpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_dynamicExceptionSpecification
}

func (*DynamicExceptionSpecificationContext) IsDynamicExceptionSpecificationContext() {}

func NewDynamicExceptionSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DynamicExceptionSpecificationContext {
	var p = new(DynamicExceptionSpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_dynamicExceptionSpecification

	return p
}

func (s *DynamicExceptionSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *DynamicExceptionSpecificationContext) Throw() antlr.TerminalNode {
	return s.GetToken(CPP14ParserThrow, 0)
}

func (s *DynamicExceptionSpecificationContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CPP14ParserLeftParen, 0)
}

func (s *DynamicExceptionSpecificationContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CPP14ParserRightParen, 0)
}

func (s *DynamicExceptionSpecificationContext) TypeIdList() ITypeIdListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeIdListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeIdListContext)
}

func (s *DynamicExceptionSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DynamicExceptionSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DynamicExceptionSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterDynamicExceptionSpecification(s)
	}
}

func (s *DynamicExceptionSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitDynamicExceptionSpecification(s)
	}
}

func (s *DynamicExceptionSpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitDynamicExceptionSpecification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) DynamicExceptionSpecification() (localctx IDynamicExceptionSpecificationContext) {
	localctx = NewDynamicExceptionSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 372, CPP14ParserRULE_dynamicExceptionSpecification)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1996)
		p.Match(CPP14ParserThrow)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1997)
		p.Match(CPP14ParserLeftParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1999)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64((_la-13)) & ^0x3f) == 0 && ((int64(1)<<(_la-13))&-9213942612181769245) != 0) || ((int64((_la-77)) & ^0x3f) == 0 && ((int64(1)<<(_la-77))&37154696925806707) != 0) {
		{
			p.SetState(1998)
			p.TypeIdList()
		}

	}
	{
		p.SetState(2001)
		p.Match(CPP14ParserRightParen)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeIdListContext is an interface to support dynamic dispatch.
type ITypeIdListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTheTypeId() []ITheTypeIdContext
	TheTypeId(i int) ITheTypeIdContext
	AllEllipsis() []antlr.TerminalNode
	Ellipsis(i int) antlr.TerminalNode
	AllComma() []antlr.TerminalNode
	Comma(i int) antlr.TerminalNode

	// IsTypeIdListContext differentiates from other interfaces.
	IsTypeIdListContext()
}

type TypeIdListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeIdListContext() *TypeIdListContext {
	var p = new(TypeIdListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_typeIdList
	return p
}

func InitEmptyTypeIdListContext(p *TypeIdListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_typeIdList
}

func (*TypeIdListContext) IsTypeIdListContext() {}

func NewTypeIdListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeIdListContext {
	var p = new(TypeIdListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_typeIdList

	return p
}

func (s *TypeIdListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeIdListContext) AllTheTypeId() []ITheTypeIdContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITheTypeIdContext); ok {
			len++
		}
	}

	tst := make([]ITheTypeIdContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITheTypeIdContext); ok {
			tst[i] = t.(ITheTypeIdContext)
			i++
		}
	}

	return tst
}

func (s *TypeIdListContext) TheTypeId(i int) ITheTypeIdContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITheTypeIdContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITheTypeIdContext)
}

func (s *TypeIdListContext) AllEllipsis() []antlr.TerminalNode {
	return s.GetTokens(CPP14ParserEllipsis)
}

func (s *TypeIdListContext) Ellipsis(i int) antlr.TerminalNode {
	return s.GetToken(CPP14ParserEllipsis, i)
}

func (s *TypeIdListContext) AllComma() []antlr.TerminalNode {
	return s.GetTokens(CPP14ParserComma)
}

func (s *TypeIdListContext) Comma(i int) antlr.TerminalNode {
	return s.GetToken(CPP14ParserComma, i)
}

func (s *TypeIdListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeIdListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeIdListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterTypeIdList(s)
	}
}

func (s *TypeIdListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitTypeIdList(s)
	}
}

func (s *TypeIdListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitTypeIdList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) TypeIdList() (localctx ITypeIdListContext) {
	localctx = NewTypeIdListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 374, CPP14ParserRULE_typeIdList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2003)
		p.TheTypeId()
	}
	p.SetState(2005)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == CPP14ParserEllipsis {
		{
			p.SetState(2004)
			p.Match(CPP14ParserEllipsis)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(2014)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == CPP14ParserComma {
		{
			p.SetState(2007)
			p.Match(CPP14ParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2008)
			p.TheTypeId()
		}
		p.SetState(2010)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == CPP14ParserEllipsis {
			{
				p.SetState(2009)
				p.Match(CPP14ParserEllipsis)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

		p.SetState(2016)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INoeExceptSpecificationContext is an interface to support dynamic dispatch.
type INoeExceptSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Noexcept() antlr.TerminalNode
	LeftParen() antlr.TerminalNode
	ConstantExpression() IConstantExpressionContext
	RightParen() antlr.TerminalNode

	// IsNoeExceptSpecificationContext differentiates from other interfaces.
	IsNoeExceptSpecificationContext()
}

type NoeExceptSpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNoeExceptSpecificationContext() *NoeExceptSpecificationContext {
	var p = new(NoeExceptSpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_noeExceptSpecification
	return p
}

func InitEmptyNoeExceptSpecificationContext(p *NoeExceptSpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_noeExceptSpecification
}

func (*NoeExceptSpecificationContext) IsNoeExceptSpecificationContext() {}

func NewNoeExceptSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NoeExceptSpecificationContext {
	var p = new(NoeExceptSpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_noeExceptSpecification

	return p
}

func (s *NoeExceptSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *NoeExceptSpecificationContext) Noexcept() antlr.TerminalNode {
	return s.GetToken(CPP14ParserNoexcept, 0)
}

func (s *NoeExceptSpecificationContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CPP14ParserLeftParen, 0)
}

func (s *NoeExceptSpecificationContext) ConstantExpression() IConstantExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstantExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstantExpressionContext)
}

func (s *NoeExceptSpecificationContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CPP14ParserRightParen, 0)
}

func (s *NoeExceptSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NoeExceptSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NoeExceptSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterNoeExceptSpecification(s)
	}
}

func (s *NoeExceptSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitNoeExceptSpecification(s)
	}
}

func (s *NoeExceptSpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitNoeExceptSpecification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) NoeExceptSpecification() (localctx INoeExceptSpecificationContext) {
	localctx = NewNoeExceptSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 376, CPP14ParserRULE_noeExceptSpecification)
	p.SetState(2023)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 290, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2017)
			p.Match(CPP14ParserNoexcept)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2018)
			p.Match(CPP14ParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2019)
			p.ConstantExpression()
		}
		{
			p.SetState(2020)
			p.Match(CPP14ParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2022)
			p.Match(CPP14ParserNoexcept)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITheOperatorContext is an interface to support dynamic dispatch.
type ITheOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	New() antlr.TerminalNode
	LeftBracket() antlr.TerminalNode
	RightBracket() antlr.TerminalNode
	Delete() antlr.TerminalNode
	Plus() antlr.TerminalNode
	Minus() antlr.TerminalNode
	Star() antlr.TerminalNode
	Div() antlr.TerminalNode
	Mod() antlr.TerminalNode
	Caret() antlr.TerminalNode
	And() antlr.TerminalNode
	Or() antlr.TerminalNode
	Tilde() antlr.TerminalNode
	Not() antlr.TerminalNode
	Assign() antlr.TerminalNode
	AllGreater() []antlr.TerminalNode
	Greater(i int) antlr.TerminalNode
	AllLess() []antlr.TerminalNode
	Less(i int) antlr.TerminalNode
	GreaterEqual() antlr.TerminalNode
	PlusAssign() antlr.TerminalNode
	MinusAssign() antlr.TerminalNode
	StarAssign() antlr.TerminalNode
	ModAssign() antlr.TerminalNode
	XorAssign() antlr.TerminalNode
	AndAssign() antlr.TerminalNode
	OrAssign() antlr.TerminalNode
	RightShiftAssign() antlr.TerminalNode
	LeftShiftAssign() antlr.TerminalNode
	Equal() antlr.TerminalNode
	NotEqual() antlr.TerminalNode
	LessEqual() antlr.TerminalNode
	AndAnd() antlr.TerminalNode
	OrOr() antlr.TerminalNode
	PlusPlus() antlr.TerminalNode
	MinusMinus() antlr.TerminalNode
	Comma() antlr.TerminalNode
	ArrowStar() antlr.TerminalNode
	Arrow() antlr.TerminalNode
	LeftParen() antlr.TerminalNode
	RightParen() antlr.TerminalNode

	// IsTheOperatorContext differentiates from other interfaces.
	IsTheOperatorContext()
}

type TheOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTheOperatorContext() *TheOperatorContext {
	var p = new(TheOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_theOperator
	return p
}

func InitEmptyTheOperatorContext(p *TheOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_theOperator
}

func (*TheOperatorContext) IsTheOperatorContext() {}

func NewTheOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TheOperatorContext {
	var p = new(TheOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_theOperator

	return p
}

func (s *TheOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *TheOperatorContext) New() antlr.TerminalNode {
	return s.GetToken(CPP14ParserNew, 0)
}

func (s *TheOperatorContext) LeftBracket() antlr.TerminalNode {
	return s.GetToken(CPP14ParserLeftBracket, 0)
}

func (s *TheOperatorContext) RightBracket() antlr.TerminalNode {
	return s.GetToken(CPP14ParserRightBracket, 0)
}

func (s *TheOperatorContext) Delete() antlr.TerminalNode {
	return s.GetToken(CPP14ParserDelete, 0)
}

func (s *TheOperatorContext) Plus() antlr.TerminalNode {
	return s.GetToken(CPP14ParserPlus, 0)
}

func (s *TheOperatorContext) Minus() antlr.TerminalNode {
	return s.GetToken(CPP14ParserMinus, 0)
}

func (s *TheOperatorContext) Star() antlr.TerminalNode {
	return s.GetToken(CPP14ParserStar, 0)
}

func (s *TheOperatorContext) Div() antlr.TerminalNode {
	return s.GetToken(CPP14ParserDiv, 0)
}

func (s *TheOperatorContext) Mod() antlr.TerminalNode {
	return s.GetToken(CPP14ParserMod, 0)
}

func (s *TheOperatorContext) Caret() antlr.TerminalNode {
	return s.GetToken(CPP14ParserCaret, 0)
}

func (s *TheOperatorContext) And() antlr.TerminalNode {
	return s.GetToken(CPP14ParserAnd, 0)
}

func (s *TheOperatorContext) Or() antlr.TerminalNode {
	return s.GetToken(CPP14ParserOr, 0)
}

func (s *TheOperatorContext) Tilde() antlr.TerminalNode {
	return s.GetToken(CPP14ParserTilde, 0)
}

func (s *TheOperatorContext) Not() antlr.TerminalNode {
	return s.GetToken(CPP14ParserNot, 0)
}

func (s *TheOperatorContext) Assign() antlr.TerminalNode {
	return s.GetToken(CPP14ParserAssign, 0)
}

func (s *TheOperatorContext) AllGreater() []antlr.TerminalNode {
	return s.GetTokens(CPP14ParserGreater)
}

func (s *TheOperatorContext) Greater(i int) antlr.TerminalNode {
	return s.GetToken(CPP14ParserGreater, i)
}

func (s *TheOperatorContext) AllLess() []antlr.TerminalNode {
	return s.GetTokens(CPP14ParserLess)
}

func (s *TheOperatorContext) Less(i int) antlr.TerminalNode {
	return s.GetToken(CPP14ParserLess, i)
}

func (s *TheOperatorContext) GreaterEqual() antlr.TerminalNode {
	return s.GetToken(CPP14ParserGreaterEqual, 0)
}

func (s *TheOperatorContext) PlusAssign() antlr.TerminalNode {
	return s.GetToken(CPP14ParserPlusAssign, 0)
}

func (s *TheOperatorContext) MinusAssign() antlr.TerminalNode {
	return s.GetToken(CPP14ParserMinusAssign, 0)
}

func (s *TheOperatorContext) StarAssign() antlr.TerminalNode {
	return s.GetToken(CPP14ParserStarAssign, 0)
}

func (s *TheOperatorContext) ModAssign() antlr.TerminalNode {
	return s.GetToken(CPP14ParserModAssign, 0)
}

func (s *TheOperatorContext) XorAssign() antlr.TerminalNode {
	return s.GetToken(CPP14ParserXorAssign, 0)
}

func (s *TheOperatorContext) AndAssign() antlr.TerminalNode {
	return s.GetToken(CPP14ParserAndAssign, 0)
}

func (s *TheOperatorContext) OrAssign() antlr.TerminalNode {
	return s.GetToken(CPP14ParserOrAssign, 0)
}

func (s *TheOperatorContext) RightShiftAssign() antlr.TerminalNode {
	return s.GetToken(CPP14ParserRightShiftAssign, 0)
}

func (s *TheOperatorContext) LeftShiftAssign() antlr.TerminalNode {
	return s.GetToken(CPP14ParserLeftShiftAssign, 0)
}

func (s *TheOperatorContext) Equal() antlr.TerminalNode {
	return s.GetToken(CPP14ParserEqual, 0)
}

func (s *TheOperatorContext) NotEqual() antlr.TerminalNode {
	return s.GetToken(CPP14ParserNotEqual, 0)
}

func (s *TheOperatorContext) LessEqual() antlr.TerminalNode {
	return s.GetToken(CPP14ParserLessEqual, 0)
}

func (s *TheOperatorContext) AndAnd() antlr.TerminalNode {
	return s.GetToken(CPP14ParserAndAnd, 0)
}

func (s *TheOperatorContext) OrOr() antlr.TerminalNode {
	return s.GetToken(CPP14ParserOrOr, 0)
}

func (s *TheOperatorContext) PlusPlus() antlr.TerminalNode {
	return s.GetToken(CPP14ParserPlusPlus, 0)
}

func (s *TheOperatorContext) MinusMinus() antlr.TerminalNode {
	return s.GetToken(CPP14ParserMinusMinus, 0)
}

func (s *TheOperatorContext) Comma() antlr.TerminalNode {
	return s.GetToken(CPP14ParserComma, 0)
}

func (s *TheOperatorContext) ArrowStar() antlr.TerminalNode {
	return s.GetToken(CPP14ParserArrowStar, 0)
}

func (s *TheOperatorContext) Arrow() antlr.TerminalNode {
	return s.GetToken(CPP14ParserArrow, 0)
}

func (s *TheOperatorContext) LeftParen() antlr.TerminalNode {
	return s.GetToken(CPP14ParserLeftParen, 0)
}

func (s *TheOperatorContext) RightParen() antlr.TerminalNode {
	return s.GetToken(CPP14ParserRightParen, 0)
}

func (s *TheOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TheOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TheOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterTheOperator(s)
	}
}

func (s *TheOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitTheOperator(s)
	}
}

func (s *TheOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitTheOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) TheOperator() (localctx ITheOperatorContext) {
	localctx = NewTheOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 378, CPP14ParserRULE_theOperator)
	p.SetState(2076)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 293, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2025)
			p.Match(CPP14ParserNew)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2028)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 291, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2026)
				p.Match(CPP14ParserLeftBracket)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2027)
				p.Match(CPP14ParserRightBracket)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2030)
			p.Match(CPP14ParserDelete)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2033)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 292, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2031)
				p.Match(CPP14ParserLeftBracket)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2032)
				p.Match(CPP14ParserRightBracket)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2035)
			p.Match(CPP14ParserPlus)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2036)
			p.Match(CPP14ParserMinus)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2037)
			p.Match(CPP14ParserStar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2038)
			p.Match(CPP14ParserDiv)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2039)
			p.Match(CPP14ParserMod)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2040)
			p.Match(CPP14ParserCaret)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(2041)
			p.Match(CPP14ParserAnd)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(2042)
			p.Match(CPP14ParserOr)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(2043)
			p.Match(CPP14ParserTilde)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(2044)
			p.Match(CPP14ParserNot)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(2045)
			p.Match(CPP14ParserAssign)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(2046)
			p.Match(CPP14ParserGreater)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(2047)
			p.Match(CPP14ParserLess)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(2048)
			p.Match(CPP14ParserGreaterEqual)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(2049)
			p.Match(CPP14ParserPlusAssign)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(2050)
			p.Match(CPP14ParserMinusAssign)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(2051)
			p.Match(CPP14ParserStarAssign)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(2052)
			p.Match(CPP14ParserModAssign)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(2053)
			p.Match(CPP14ParserXorAssign)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(2054)
			p.Match(CPP14ParserAndAssign)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(2055)
			p.Match(CPP14ParserOrAssign)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(2056)
			p.Match(CPP14ParserLess)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2057)
			p.Match(CPP14ParserLess)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(2058)
			p.Match(CPP14ParserGreater)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2059)
			p.Match(CPP14ParserGreater)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(2060)
			p.Match(CPP14ParserRightShiftAssign)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(2061)
			p.Match(CPP14ParserLeftShiftAssign)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 28:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(2062)
			p.Match(CPP14ParserEqual)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 29:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(2063)
			p.Match(CPP14ParserNotEqual)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 30:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(2064)
			p.Match(CPP14ParserLessEqual)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 31:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(2065)
			p.Match(CPP14ParserAndAnd)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 32:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(2066)
			p.Match(CPP14ParserOrOr)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 33:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(2067)
			p.Match(CPP14ParserPlusPlus)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 34:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(2068)
			p.Match(CPP14ParserMinusMinus)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 35:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(2069)
			p.Match(CPP14ParserComma)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 36:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(2070)
			p.Match(CPP14ParserArrowStar)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 37:
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(2071)
			p.Match(CPP14ParserArrow)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 38:
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(2072)
			p.Match(CPP14ParserLeftParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2073)
			p.Match(CPP14ParserRightParen)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 39:
		p.EnterOuterAlt(localctx, 39)
		{
			p.SetState(2074)
			p.Match(CPP14ParserLeftBracket)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2075)
			p.Match(CPP14ParserRightBracket)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IntegerLiteral() antlr.TerminalNode
	CharacterLiteral() antlr.TerminalNode
	FloatingLiteral() antlr.TerminalNode
	StringLiteral() antlr.TerminalNode
	BooleanLiteral() antlr.TerminalNode
	PointerLiteral() antlr.TerminalNode
	UserDefinedLiteral() antlr.TerminalNode

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_literal
	return p
}

func InitEmptyLiteralContext(p *LiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CPP14ParserRULE_literal
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CPP14ParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) IntegerLiteral() antlr.TerminalNode {
	return s.GetToken(CPP14ParserIntegerLiteral, 0)
}

func (s *LiteralContext) CharacterLiteral() antlr.TerminalNode {
	return s.GetToken(CPP14ParserCharacterLiteral, 0)
}

func (s *LiteralContext) FloatingLiteral() antlr.TerminalNode {
	return s.GetToken(CPP14ParserFloatingLiteral, 0)
}

func (s *LiteralContext) StringLiteral() antlr.TerminalNode {
	return s.GetToken(CPP14ParserStringLiteral, 0)
}

func (s *LiteralContext) BooleanLiteral() antlr.TerminalNode {
	return s.GetToken(CPP14ParserBooleanLiteral, 0)
}

func (s *LiteralContext) PointerLiteral() antlr.TerminalNode {
	return s.GetToken(CPP14ParserPointerLiteral, 0)
}

func (s *LiteralContext) UserDefinedLiteral() antlr.TerminalNode {
	return s.GetToken(CPP14ParserUserDefinedLiteral, 0)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(CPP14ParserListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (s *LiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CPP14ParserVisitor:
		return t.VisitLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *CPP14Parser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 380, CPP14ParserRULE_literal)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2078)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&254) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *CPP14Parser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 5:
		var t *NestedNameSpecifierContext = nil
		if localctx != nil {
			t = localctx.(*NestedNameSpecifierContext)
		}
		return p.NestedNameSpecifier_Sempred(t, predIndex)

	case 15:
		var t *PostfixExpressionContext = nil
		if localctx != nil {
			t = localctx.(*PostfixExpressionContext)
		}
		return p.PostfixExpression_Sempred(t, predIndex)

	case 25:
		var t *NoPointerNewDeclaratorContext = nil
		if localctx != nil {
			t = localctx.(*NoPointerNewDeclaratorContext)
		}
		return p.NoPointerNewDeclarator_Sempred(t, predIndex)

	case 115:
		var t *NoPointerDeclaratorContext = nil
		if localctx != nil {
			t = localctx.(*NoPointerDeclaratorContext)
		}
		return p.NoPointerDeclarator_Sempred(t, predIndex)

	case 126:
		var t *NoPointerAbstractDeclaratorContext = nil
		if localctx != nil {
			t = localctx.(*NoPointerAbstractDeclaratorContext)
		}
		return p.NoPointerAbstractDeclarator_Sempred(t, predIndex)

	case 128:
		var t *NoPointerAbstractPackDeclaratorContext = nil
		if localctx != nil {
			t = localctx.(*NoPointerAbstractPackDeclaratorContext)
		}
		return p.NoPointerAbstractPackDeclarator_Sempred(t, predIndex)

	case 148:
		var t *MemberDeclaratorContext = nil
		if localctx != nil {
			t = localctx.(*MemberDeclaratorContext)
		}
		return p.MemberDeclarator_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *CPP14Parser) NestedNameSpecifier_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *CPP14Parser) PostfixExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 1:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 2:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 3)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *CPP14Parser) NoPointerNewDeclarator_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 5:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *CPP14Parser) NoPointerDeclarator_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 6:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *CPP14Parser) NoPointerAbstractDeclarator_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 7:
		return p.Precpred(p.GetParserRuleContext(), 4)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *CPP14Parser) NoPointerAbstractPackDeclarator_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 8:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *CPP14Parser) MemberDeclarator_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 9:
		return p.IsPureSpecifierAllowed()

	case 10:
		return p.IsPureSpecifierAllowed()

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
